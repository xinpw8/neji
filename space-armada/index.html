<!DOCTYPE html>
<html>
<head>
    <title>Space Armada</title>
    <!-- Google Font: Orbitron as fallback for EV:O's Crillee font -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            overflow: hidden;
            background: #000;
            font-family: 'Orbitron', 'Courier New', monospace;
        }
        #gameCanvas { display: block; }

        #crosshair {
            position: fixed;
            pointer-events: none;
            z-index: 50;
            width: 40px;
            height: 40px;
            transform: translate(-50%, -50%);
        }
        #crosshair::before, #crosshair::after {
            content: '';
            position: absolute;
            background: rgba(255, 100, 100, 0.8);
        }
        #crosshair::before {
            width: 2px;
            height: 40px;
            left: 19px;
        }
        #crosshair::after {
            width: 40px;
            height: 2px;
            top: 19px;
        }
        #crosshair .dot {
            position: absolute;
            width: 6px;
            height: 6px;
            background: #f00;
            border-radius: 50%;
            top: 17px;
            left: 17px;
        }

        /* SIMPLIFIED HUD - Minimal UI */
        #ui {
            position: fixed;
            top: 10px;
            left: 10px;
            color: #0f0;
            font-size: 12px;
            z-index: 100;
            background: rgba(0, 15, 0, 0.7);
            padding: 8px 12px;
            border: 1px solid #0a0;
            border-radius: 3px;
            min-width: 160px;
        }

        #ui .title {
            display: none; /* Hide title */
        }

        #ui .stat {
            margin: 3px 0;
            display: flex;
            justify-content: space-between;
            font-size: 11px;
        }

        #ui .bar-container {
            width: 100%;
            height: 8px;
            background: #001100;
            border: 1px solid #050;
            margin: 2px 0;
        }

        #ui .bar {
            height: 100%;
            transition: width 0.3s;
        }

        /* EV:O style status bars - green for shields, red/orange for hull */
        .health-bar { background: linear-gradient(90deg, #880000, #ff4400, #ff8800); }
        .shield-bar { background: linear-gradient(90deg, #003300, #00aa00, #00ff00); }
        .energy-bar { background: linear-gradient(90deg, #333300, #888800, #ffff00); }

        /* Weapon info - smaller, bottom center */
        #weaponInfo {
            position: fixed;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            color: #0ff;
            font-size: 11px;
            z-index: 100;
            background: rgba(0, 15, 20, 0.7);
            padding: 6px 15px;
            border: 1px solid #066;
            border-radius: 3px;
            text-align: center;
        }

        #weaponInfo .weapon-name {
            font-size: 13px;
            color: #fff;
            margin-bottom: 2px;
        }

        #weaponInfo .weapon-type {
            font-size: 10px;
            color: #088;
        }

        #lockIndicator {
            position: fixed;
            pointer-events: none;
            z-index: 60;
            display: none;
        }

        #lockIndicator .lock-box {
            width: 60px;
            height: 60px;
            border: 2px solid #f00;
            transform: translate(-50%, -50%);
            animation: lockPulse 0.5s infinite;
        }

        @keyframes lockPulse {
            0%, 100% { border-color: #f00; }
            50% { border-color: #ff0; }
        }

        #minimap {
            position: fixed;
            bottom: 15px;
            right: 15px;
            width: 200px;
            height: 200px;
            background: rgba(0, 20, 0, 0.85);
            border: 1px solid #0f0;
            border-radius: 5px;
        }

        /* Hidden - Controls panel removed for cleaner UI */
        #controls {
            display: none !important;
        }

        /* Hidden - Heading indicator removed for cleaner UI */
        #headingIndicator {
            display: none !important;
        }

        /* Hidden - Sector info removed (no more sectors) */
        #sectorInfo {
            display: none !important;
        }

        #upgradePanel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 30, 0, 0.95);
            border: 2px solid #0f0;
            border-radius: 10px;
            padding: 20px;
            z-index: 200;
            display: none;
            min-width: 450px;
            max-height: 80vh;
            overflow-y: auto;
        }

        #upgradePanel h2 {
            color: #0ff;
            margin-bottom: 15px;
            text-align: center;
        }

        .upgrade-section {
            margin: 15px 0;
            border-top: 1px solid #050;
            padding-top: 10px;
        }

        .upgrade-section h3 {
            color: #0f0;
            font-size: 14px;
            margin-bottom: 10px;
        }

        .upgrade-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            margin: 4px 0;
            background: rgba(0, 50, 0, 0.5);
            border: 1px solid #030;
            cursor: pointer;
            transition: all 0.2s;
        }

        .upgrade-item:hover {
            background: rgba(0, 80, 0, 0.5);
            border-color: #0f0;
        }

        .upgrade-item .name { color: #0f0; }
        .upgrade-item .cost { color: #ff0; }
        .upgrade-item .level { color: #0ff; font-size: 11px; }

        /* Station Menu Panel */
        #stationMenu {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 20, 30, 0.97);
            border: 2px solid #0af;
            border-radius: 10px;
            padding: 0;
            z-index: 250;
            display: none;
            width: 700px;
            max-height: 85vh;
            overflow: hidden;
            flex-direction: column;
        }

        #stationMenu .menu-header {
            background: linear-gradient(180deg, #0af 0%, #058 100%);
            padding: 12px 20px;
            text-align: center;
        }

        #stationMenu .menu-header h2 {
            color: #fff;
            margin: 0;
            font-size: 18px;
            letter-spacing: 3px;
        }

        #stationMenu .menu-tabs {
            display: flex;
            background: rgba(0, 40, 60, 0.8);
            border-bottom: 1px solid #068;
        }

        #stationMenu .menu-tab {
            flex: 1;
            padding: 10px 15px;
            text-align: center;
            color: #088;
            cursor: pointer;
            border: none;
            background: transparent;
            font-family: inherit;
            font-size: 11px;
            letter-spacing: 1px;
            transition: all 0.2s;
        }

        #stationMenu .menu-tab:hover {
            background: rgba(0, 100, 150, 0.3);
            color: #0cf;
        }

        #stationMenu .menu-tab.active {
            background: rgba(0, 80, 120, 0.5);
            color: #0ff;
            border-bottom: 2px solid #0ff;
        }

        #stationMenu .menu-content {
            padding: 15px;
            flex: 1;
            min-height: 0;
            overflow-y: auto;
        }

        #stationMenu .service-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 15px;
            margin: 5px 0;
            background: rgba(0, 40, 60, 0.5);
            border: 1px solid #046;
            border-radius: 5px;
        }

        #stationMenu .service-info {
            flex: 1;
        }

        #stationMenu .service-name {
            color: #0cf;
            font-size: 12px;
            margin-bottom: 3px;
        }

        #stationMenu .service-desc {
            color: #068;
            font-size: 10px;
        }

        #stationMenu .service-btn {
            padding: 8px 15px;
            background: rgba(0, 100, 150, 0.5);
            border: 1px solid #0af;
            color: #0ff;
            cursor: pointer;
            font-family: inherit;
            font-size: 10px;
            border-radius: 3px;
            transition: all 0.2s;
        }

        #stationMenu .service-btn:hover {
            background: rgba(0, 150, 200, 0.6);
            box-shadow: 0 0 10px rgba(0, 170, 255, 0.4);
        }

        #stationMenu .service-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Shipyard styles */
        .ship-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
        }

        .ship-card {
            background: rgba(0, 30, 50, 0.6);
            border: 1px solid #046;
            border-radius: 5px;
            padding: 10px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .ship-card:hover {
            background: rgba(0, 50, 80, 0.6);
            border-color: #0af;
        }

        .ship-card.owned {
            border-color: #0f0;
            background: rgba(0, 50, 30, 0.6);
        }

        .ship-card.cant-afford {
            opacity: 0.5;
        }

        .ship-card .ship-name {
            color: #0ff;
            font-size: 11px;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .ship-card .ship-stats {
            font-size: 9px;
            color: #088;
            line-height: 1.4;
        }

        .ship-card .ship-price {
            color: #ff0;
            font-size: 10px;
            margin-top: 5px;
        }

        .ship-card .ship-price.owned-label {
            color: #0f0;
        }

        .ship-category {
            color: #0af;
            font-size: 12px;
            margin: 15px 0 8px 0;
            padding-bottom: 5px;
            border-bottom: 1px solid #046;
        }

        .ship-category:first-child {
            margin-top: 0;
        }

        /* Shipyard Preview System */
        .shipyard-container {
            display: flex;
            gap: 15px;
            height: calc(60vh - 60px);
            min-height: 300px;
            max-height: calc(85vh - 180px);
        }

        .shipyard-list {
            width: 40%;
            overflow-y: auto;
            border-right: 1px solid #046;
            padding-right: 10px;
        }

        .shipyard-preview {
            width: 60%;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .ship-preview-canvas {
            width: 300px;
            height: 300px;
            border: 1px solid #068;
            border-radius: 5px;
            background: radial-gradient(ellipse at center, #001020 0%, #000508 100%);
            cursor: grab;
        }

        .ship-preview-canvas:active {
            cursor: grabbing;
        }

        .ship-preview-details {
            width: 100%;
            padding: 15px;
            text-align: center;
        }

        .ship-preview-name {
            color: #0ff;
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 8px;
        }

        .ship-preview-stats {
            color: #088;
            font-size: 11px;
            line-height: 1.5;
            margin-bottom: 8px;
        }

        .ship-preview-desc {
            color: #068;
            font-size: 10px;
            font-style: italic;
            margin-bottom: 12px;
            max-height: 40px;
            overflow: hidden;
        }

        .ship-preview-buy {
            padding: 10px 25px;
            background: linear-gradient(180deg, #0af 0%, #058 100%);
            border: 1px solid #0cf;
            color: #fff;
            cursor: pointer;
            font-family: inherit;
            font-size: 11px;
            border-radius: 4px;
            transition: all 0.2s;
            text-shadow: 0 1px 2px rgba(0,0,0,0.5);
        }

        .ship-preview-buy:hover:not(:disabled) {
            box-shadow: 0 0 15px rgba(0, 170, 255, 0.6);
            background: linear-gradient(180deg, #0cf 0%, #06a 100%);
        }

        .ship-preview-buy:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            background: linear-gradient(180deg, #666 0%, #444 100%);
            border-color: #888;
        }

        .ship-preview-buy.owned {
            background: linear-gradient(180deg, #0a0 0%, #050 100%);
            border-color: #0f0;
        }

        /* Compact ship cards for list */
        .ship-card-compact {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 10px;
            margin: 3px 0;
            background: rgba(0, 30, 50, 0.6);
            border: 1px solid #046;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .ship-card-compact:hover {
            background: rgba(0, 50, 80, 0.6);
            border-color: #0af;
        }

        .ship-card-compact.selected {
            border-color: #0ff;
            background: rgba(0, 80, 120, 0.5);
            box-shadow: 0 0 8px rgba(0, 255, 255, 0.3);
        }

        .ship-card-compact.owned {
            border-left: 3px solid #0f0;
        }

        .ship-card-compact.cant-afford {
            opacity: 0.5;
        }

        .ship-card-compact .ship-name {
            color: #0ff;
            font-size: 10px;
        }

        .ship-card-compact .ship-price {
            color: #ff0;
            font-size: 9px;
        }

        .ship-card-compact .ship-price.owned-label {
            color: #0f0;
        }

        /* Docking indicator */
        #dockingIndicator {
            position: fixed;
            top: 20%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 50, 80, 0.9);
            border: 2px solid #0af;
            border-radius: 8px;
            padding: 15px 30px;
            z-index: 180;
            display: none;
            text-align: center;
        }

        #dockingIndicator .docking-text {
            color: #0ff;
            font-size: 16px;
            letter-spacing: 3px;
            animation: dockingPulse 1s infinite;
        }

        @keyframes dockingPulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        #message {
            position: fixed;
            top: 30%;
            left: 50%;
            transform: translateX(-50%);
            color: #0f0;
            font-size: 28px;
            text-shadow: 0 0 20px #0f0;
            z-index: 150;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
        }

        #message.show { opacity: 1; }

        #startScreen {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(ellipse at center, #001020 0%, #000 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 300;
        }

        #startScreen h1 {
            font-size: 72px;
            color: #0ff;
            text-shadow: 0 0 30px #0ff, 0 0 60px #00f;
            margin-bottom: 20px;
            letter-spacing: 10px;
        }

        #startScreen .subtitle {
            color: #0a0;
            font-size: 18px;
            margin-bottom: 40px;
            letter-spacing: 5px;
        }

        #startScreen p {
            color: #0f0;
            font-size: 14px;
            max-width: 700px;
            text-align: center;
            line-height: 1.8;
            margin-bottom: 30px;
        }

        .btn {
            padding: 15px 50px;
            font-size: 20px;
            background: transparent;
            color: #0f0;
            border: 2px solid #0f0;
            cursor: pointer;
            font-family: inherit;
            letter-spacing: 3px;
            transition: all 0.3s;
        }

        .btn:hover {
            background: #0f0;
            color: #000;
            box-shadow: 0 0 30px #0f0;
        }

        #gameOverScreen {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 300;
        }

        #gameOverScreen h1 {
            font-size: 48px;
            color: #f00;
            text-shadow: 0 0 20px #f00;
            margin-bottom: 20px;
        }

        #gameOverScreen .stats {
            color: #0f0;
            font-size: 16px;
            margin: 20px 0;
            text-align: center;
            line-height: 2;
        }

        /* Hidden - Faction panel removed for cleaner UI */
        #factionPanel {
            display: none !important;
        }
        #factionPanel .faction-title { display: none; }
        #factionPanel .faction-item { display: none; }
        #factionPanel .faction-name { display: none; }
        #factionPanel .rep-bar { display: none; }
        #factionPanel .rep-fill { display: none; }
        #factionPanel .rep-value { display: none; }

        /* Hidden - Encounter info removed for cleaner UI */
        #encounterInfo {
            display: none !important;
        }
        #encounterInfo .encounter-faction { display: none; }
        #encounterInfo .encounter-ships { display: none; }
        #encounterInfo .encounter-attitude { display: none; }

        #missionPanel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(10, 20, 40, 0.97);
            border: 2px solid #48f;
            border-radius: 10px;
            padding: 20px;
            z-index: 250;
            display: none;
            min-width: 480px;
            max-width: 600px;
            max-height: 75vh;
            overflow-y: auto;
        }
        #missionPanel h2 { color: #8af; margin-bottom: 10px; text-align: center; font-size: 16px; }
        .mission-item { background: rgba(30, 50, 80, 0.6); border: 1px solid #368; padding: 10px; margin: 6px 0; cursor: pointer; transition: all 0.2s; }
        .mission-item:hover { background: rgba(50, 80, 120, 0.7); border-color: #8af; }
        .mission-item.active { border-color: #0f0; background: rgba(30, 80, 50, 0.6); }
        .mission-item .mission-title { color: #fff; font-size: 12px; margin-bottom: 3px; }
        .mission-item .mission-giver { font-size: 9px; margin-bottom: 5px; }
        .mission-item .mission-desc { color: #aaa; font-size: 10px; line-height: 1.4; }
        .mission-item .mission-reward { color: #ff0; font-size: 10px; margin-top: 5px; }

        /* Hidden - Active mission panel removed for cleaner UI */
        #activeMission {
            display: none !important;
        }
        #activeMission .mission-header { display: none; }
        #activeMission .mission-objective { display: none; }
        #activeMission .mission-progress { display: none; }

        #dialoguePanel {
            position: fixed;
            bottom: 70px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 20, 40, 0.95);
            border: 2px solid #0af;
            border-radius: 8px;
            padding: 12px;
            z-index: 180;
            display: none;
            min-width: 400px;
            max-width: 550px;
        }
        #dialoguePanel .speaker { font-size: 12px; margin-bottom: 6px; }
        #dialoguePanel .dialogue-text { color: #ccc; font-size: 11px; line-height: 1.4; margin-bottom: 10px; }
        #dialoguePanel .dialogue-options { display: flex; flex-wrap: wrap; gap: 6px; }
        #dialoguePanel .dialogue-btn { padding: 5px 10px; background: rgba(0, 80, 120, 0.5); border: 1px solid #0af; color: #0ff; cursor: pointer; font-family: inherit; font-size: 10px; }
        #dialoguePanel .dialogue-btn:hover { background: rgba(0, 120, 180, 0.6); }

        .storyline-notification {
            position: fixed;
            top: 12%;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, rgba(50, 20, 80, 0.95), rgba(20, 40, 80, 0.95));
            border: 2px solid #a8f;
            border-radius: 8px;
            padding: 15px 25px;
            z-index: 300;
            text-align: center;
            animation: storylineGlow 2s infinite;
            display: none;
        }
        @keyframes storylineGlow { 0%, 100% { box-shadow: 0 0 15px rgba(150, 100, 255, 0.5); } 50% { box-shadow: 0 0 30px rgba(150, 100, 255, 0.8); } }
        .storyline-notification h3 { color: #fff; font-size: 14px; margin-bottom: 6px; }
        .storyline-notification p { color: #aaf; font-size: 11px; margin-bottom: 10px; }
        .storyline-notification button { padding: 5px 12px; background: rgba(100, 50, 150, 0.6); border: 1px solid #a8f; color: #fff; cursor: pointer; font-family: inherit; font-size: 10px; }

        /* ============================================
           EV:O (Escape Velocity: Override) STYLE UI
           ============================================ */

        /* SIMPLIFIED Target Display Panel - only shows when targeting */
        #evTargetPanel {
            position: fixed;
            top: 10px;
            left: 180px;
            width: 180px;
            background: rgba(0, 15, 0, 0.8);
            border: 1px solid #0a0;
            border-radius: 3px;
            padding: 8px;
            z-index: 100;
            display: none;
            font-family: 'Orbitron', monospace;
        }

        #evTargetPanel .target-header {
            color: #0f0;
            font-size: 9px;
            text-align: center;
            border-bottom: 1px solid #040;
            padding-bottom: 3px;
            margin-bottom: 5px;
            letter-spacing: 1px;
        }

        /* Hide the wireframe views for cleaner UI */
        #evTargetPanel .target-views {
            display: none;
        }

        #evTargetPanel .target-view {
            display: none;
        }

        #evTargetPanel .target-view-label {
            display: none;
        }

        #evTargetPanel .target-info {
            color: #0f0;
            font-size: 9px;
            line-height: 1.4;
        }

        #evTargetPanel .target-name {
            color: #0f0;
            font-size: 11px;
            font-weight: bold;
            margin-bottom: 3px;
        }

        #evTargetPanel .target-faction {
            color: #080;
            font-size: 8px;
            margin-bottom: 5px;
        }

        #evTargetPanel .target-stat {
            display: flex;
            justify-content: space-between;
            margin: 2px 0;
            font-size: 9px;
        }

        #evTargetPanel .target-stat-label {
            color: #080;
        }

        #evTargetPanel .target-stat-value {
            color: #0f0;
        }

        #evTargetPanel .target-bar-container {
            width: 100%;
            height: 6px;
            background: #010;
            border: 1px solid #030;
            margin: 2px 0;
        }

        #evTargetPanel .target-bar {
            height: 100%;
            transition: width 0.2s;
        }

        #evTargetPanel .target-hull-bar {
            background: linear-gradient(90deg, #884400, #ff8800);
        }

        #evTargetPanel .target-shield-bar {
            background: linear-gradient(90deg, #004400, #00ff00);
        }

        /* EV-style Comm Panel */
        #evCommPanel {
            position: fixed;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            width: 500px;
            background: #001100;
            border: 3px solid #00aa00;
            border-radius: 5px;
            padding: 15px;
            z-index: 200;
            display: none;
            font-family: 'Orbitron', monospace;
        }

        #evCommPanel .comm-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #004400;
            padding-bottom: 8px;
            margin-bottom: 10px;
        }

        #evCommPanel .comm-title {
            color: #00ff00;
            font-size: 12px;
            letter-spacing: 3px;
        }

        #evCommPanel .comm-freq {
            color: #008800;
            font-size: 9px;
        }

        #evCommPanel .comm-body {
            display: flex;
            gap: 15px;
        }

        #evCommPanel .comm-portrait {
            width: 100px;
            height: 100px;
            background: #000800;
            border: 2px solid #003300;
            flex-shrink: 0;
        }

        #evCommPanel .comm-content {
            flex: 1;
        }

        #evCommPanel .comm-speaker {
            color: #00ff00;
            font-size: 11px;
            margin-bottom: 5px;
        }

        #evCommPanel .comm-text {
            color: #00aa00;
            font-size: 10px;
            line-height: 1.5;
            margin-bottom: 12px;
            min-height: 50px;
        }

        #evCommPanel .comm-options {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        #evCommPanel .comm-btn {
            padding: 6px 12px;
            background: #002200;
            border: 1px solid #00aa00;
            color: #00ff00;
            cursor: pointer;
            font-family: 'Orbitron', monospace;
            font-size: 9px;
            letter-spacing: 1px;
            transition: all 0.2s;
        }

        #evCommPanel .comm-btn:hover {
            background: #003300;
            border-color: #00ff00;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.3);
        }

        /* Smaller Scanner/Radar minimap */
        #minimap {
            position: fixed;
            bottom: 10px;
            right: 10px;
            width: 140px;
            height: 140px;
            background: #010;
            border: 1px solid #0a0;
            border-radius: 50%;
            overflow: hidden;
        }

        #minimap::before {
            display: none; /* Remove SCANNER label */
        }

        #minimapCanvas {
            border-radius: 50%;
        }

        /* Scanner sweep animation overlay */
        #scannerSweep {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            border-radius: 50%;
            background: conic-gradient(
                from 0deg,
                transparent 0deg,
                rgba(0, 255, 0, 0.1) 20deg,
                transparent 40deg
            );
            animation: scannerRotate 3s linear infinite;
        }

        @keyframes scannerRotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div id="startScreen">
        <h1>SPACE ARMADA</h1>
        <div class="subtitle">INFINITE SPACE COMBAT</div>
        <p style="font-size:11px;line-height:1.6;color:#aaf;margin-bottom:15px;text-align:center;max-width:500px;">
            Explore an infinite universe. Fight enemies, collect credits, upgrade your ship.
            The deeper you go, the more dangerous it gets.
        </p>
        <p>
            <b>CONTROLS:</b><br>
            <span style="color:#0ff">WASD</span> - Move | <span style="color:#0ff">MOUSE</span> - Aim | <span style="color:#0ff">SHIFT</span> - Boost<br>
            <span style="color:#0ff">SPACE</span> - Primary weapon | <span style="color:#f80">CLICK</span> - Turret | <span style="color:#f0f">1-4</span> - Select weapon<br>
            <span style="color:#0f0">TAB</span> - Upgrades | <span style="color:#0f0">SLOW NEAR STATION</span> - Auto-dock | <span style="color:#0f0">T</span> - Target enemy
        </p>
        <button class="btn" onclick="startGame()">LAUNCH</button>
    </div>

    <div id="gameOverScreen">
        <h1>SHIP DESTROYED</h1>
        <div class="stats">
            Distance Traveled: <span id="finalSectors">0</span><br>
            Enemies Destroyed: <span id="finalKills">0</span><br>
            Credits Earned: <span id="finalCredits">0</span><br>
            Final Ship Level: <span id="finalLevel">1</span>
        </div>
        <button class="btn" onclick="location.reload()">TRY AGAIN</button>
    </div>

    <div id="crosshair" style="display:none;"><div class="dot"></div></div>
    <div id="lockIndicator"><div class="lock-box"></div></div>

    <div id="ui" style="display:none;">
        <div class="title">SHIP STATUS</div>
        <div class="stat"><span>HULL</span><span id="hullVal">100/100</span></div>
        <div class="bar-container"><div class="bar health-bar" id="hullBar" style="width:100%"></div></div>
        <div class="stat"><span>SHIELDS</span><span id="shieldVal">50/50</span></div>
        <div class="bar-container"><div class="bar shield-bar" id="shieldBar" style="width:100%"></div></div>
        <div class="stat"><span>ENERGY</span><span id="energyVal">100/100</span></div>
        <div class="bar-container"><div class="bar energy-bar" id="energyBar" style="width:100%"></div></div>
        <div class="stat" style="margin-top:12px;border-top:1px solid #050;padding-top:10px;">
            <span>CREDITS</span><span id="credits" style="color:#ff0">0</span>
        </div>
        <div class="stat"><span>KILLS</span><span id="kills">0</span></div>
        <div class="stat"><span>RATING</span><span id="combatRating" style="color:#666666">Harmless</span></div>
        <div class="stat"><span>MISSILES</span><span id="missiles" style="color:#f0f">5</span></div>
    </div>

    <div id="sectorInfo" style="display:none;">
        <div style="color:#0ff;margin-bottom:10px;font-size:16px;">SECTOR <span id="sectorNum">0-0</span></div>
        <div style="color:#0a0;font-size:12px;">
            Enemies: <span id="enemyCount">0</span><br>
            Threat: <span id="threatLevel">LOW</span>
        </div>
    </div>

    <div id="controls" style="display:none;">
        <b style="color:#0ff">MOVEMENT</b><br>
        WASD - Move ship<br>
        MOUSE - Aim direction<br>
        SHIFT - Boost<br><br>
        <b style="color:#0ff">WEAPONS</b><br>
        SPACE - Primary (forward)<br>
        CLICK - Fire turret (at cursor)<br>
        F - Fire missile | T - Lock target<br><br>
        <b style="color:#0ff">OTHER</b><br>
        TAB - Upgrades | Auto-dock when slow near station<br>
        M - Missions | H - Hail faction
    </div>

    <div id="headingIndicator" style="display:none;">
        <canvas id="headingCanvas"></canvas>
    </div>

    <div id="weaponInfo" style="display:none;">
        <div class="weapon-name">PULSE CANNON</div>
        <div class="weapon-type">PRIMARY - FORWARD MOUNT</div>
    </div>

    <div id="minimap" style="display:none;">
        <canvas id="minimapCanvas"></canvas>
        <div id="scannerSweep"></div>
    </div>

    <!-- EV:O Style Target Display Panel -->
    <div id="evTargetPanel">
        <div class="target-header">TARGET ACQUIRED</div>
        <div class="target-views">
            <div>
                <canvas id="targetViewFront" class="target-view" width="100" height="80"></canvas>
                <div class="target-view-label">FRONT</div>
            </div>
            <div>
                <canvas id="targetViewSide" class="target-view" width="100" height="80"></canvas>
                <div class="target-view-label">SIDE</div>
            </div>
        </div>
        <div class="target-info">
            <div class="target-name" id="targetName">Unknown</div>
            <div class="target-faction" id="targetFaction">Unknown Faction</div>
            <div class="target-stat">
                <span class="target-stat-label">SHIELDS</span>
                <span class="target-stat-value" id="targetShieldVal">0%</span>
            </div>
            <div class="target-bar-container">
                <div class="target-bar target-shield-bar" id="targetShieldBar" style="width:0%"></div>
            </div>
            <div class="target-stat">
                <span class="target-stat-label">HULL</span>
                <span class="target-stat-value" id="targetHullVal">0%</span>
            </div>
            <div class="target-bar-container">
                <div class="target-bar target-hull-bar" id="targetHullBar" style="width:0%"></div>
            </div>
            <div class="target-stat" style="margin-top:8px;">
                <span class="target-stat-label">DISTANCE</span>
                <span class="target-stat-value" id="targetDistance">0m</span>
            </div>
        </div>
    </div>

    <!-- EV:O Style Comm Panel -->
    <div id="evCommPanel">
        <div class="comm-header">
            <span class="comm-title">INCOMING TRANSMISSION</span>
            <span class="comm-freq">FREQ: <span id="commFreq">127.3</span> MHz</span>
        </div>
        <div class="comm-body">
            <canvas id="commPortrait" class="comm-portrait" width="100" height="100"></canvas>
            <div class="comm-content">
                <div class="comm-speaker" id="commSpeaker">Unknown</div>
                <div class="comm-text" id="commText">...</div>
                <div class="comm-options" id="commOptions"></div>
            </div>
        </div>
    </div>

    <!-- Docking Indicator -->
    <div id="dockingIndicator">
        <div class="docking-text">DOCKING...</div>
    </div>

    <!-- Station Menu -->
    <div id="stationMenu">
        <div class="menu-header">
            <h2>SPACE STATION</h2>
        </div>
        <div class="menu-tabs">
            <button class="menu-tab active" onclick="showStationTab('services')">SERVICES</button>
            <button class="menu-tab" onclick="showStationTab('shipyard')">SHIPYARD</button>
            <button class="menu-tab" onclick="showStationTab('outfitter')">OUTFITTER</button>
        </div>
        <div class="menu-content" id="stationMenuContent">
            <!-- Content populated by JavaScript -->
        </div>
        <div style="text-align:center;padding:10px;border-top:1px solid #046;">
            <button class="service-btn" onclick="closeStationMenu()">UNDOCK</button>
            <span style="color:#068;font-size:10px;margin-left:15px;">Press ESC to undock</span>
        </div>
    </div>

    <div id="upgradePanel">
        <h2>SHIP UPGRADES</h2>
        <div id="upgradeList"></div>
        <div style="text-align:center;margin-top:15px;color:#0a0;font-size:12px;">
            Press TAB to close
        </div>
    </div>

    <div id="message"></div>

    <!-- Faction and Mission UI Elements -->
    <div id="factionPanel" style="display:none;">
        <div class="faction-title">FACTION STANDING</div>
        <div id="factionList"></div>
    </div>

    <div id="encounterInfo">
        <div class="encounter-faction" id="encounterFaction">Unknown Faction</div>
        <div class="encounter-ships" id="encounterShips">Ships: 0</div>
        <div class="encounter-attitude" id="encounterAttitude">Attitude: Neutral</div>
    </div>

    <div id="missionPanel">
        <h2>AVAILABLE MISSIONS</h2>
        <div id="missionList"></div>
        <div style="text-align:center;margin-top:12px;color:#0a0;font-size:10px;">Press M to close</div>
    </div>

    <div id="activeMission">
        <div class="mission-header">ACTIVE MISSION</div>
        <div class="mission-objective" id="missionObjective">No active mission</div>
        <div class="mission-progress" id="missionProgress"></div>
    </div>

    <div id="dialoguePanel">
        <div class="speaker" id="dialogueSpeaker">Unknown</div>
        <div class="dialogue-text" id="dialogueText">...</div>
        <div class="dialogue-options" id="dialogueOptions"></div>
    </div>

    <div class="storyline-notification" id="storylineNotification">
        <h3 id="storylineTitle">New Storyline</h3>
        <p id="storylineDesc">A new chapter begins...</p>
        <button onclick="closeStorylineNotification()">Continue</button>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        // Game constants
        const SHIP_SCALE = 0.4; // Scale down all ships to 40% of original size
        const WORLD_CHUNK_SIZE = 1500; // Size of procedural generation chunks
        const SPAWN_RADIUS = 800; // How far from player to spawn new content
        const DESPAWN_RADIUS = 2000; // How far before content is removed
        const SAFE_SPAWN_RADIUS = 400; // Enemies spawn at least this far from player
        const MAX_ENEMIES = 15; // Maximum enemies at any time
        const MAX_STATIONS = 3; // Maximum stations at any time
        const SECTOR_SIZE = WORLD_CHUNK_SIZE; // Keep for compatibility with some functions

        // ============================================================
        // EV NOVA STYLE SHIP STATS SYSTEM
        // Based on ev_bible.md analysis - comprehensive ship statistics
        // Shield/Armor dual-health, recharge rates, movement stats
        // Values scaled for game balance (EV: 300 = average, here: 1.0 = average)
        // ============================================================

        const EV_SHIP_STATS = {
            // FIGHTERS - Fast, light armor, weak shields
            fighter: {
                shield: 25, maxShield: 25,
                armor: 15, maxArmor: 15,
                shieldRecharge: 0.8,  // Points per second (EV: 1000 = 30/sec)
                armorRecharge: 0,     // Most ships don't regen armor
                accel: 1.2,           // EV: 300 = 1.0
                speed: 1.3,           // EV: 300 = 1.0
                turnRate: 1.4,        // EV: 10 = 30deg/sec, scale
                crew: 1,
                strength: 20,         // Combat strength for AI calculations
                mass: 15,             // Tons
                disableThreshold: 0.33, // Disabled at 33% armor
                aiType: 'interceptor' // Default AI behavior
            },
            // HEAVY FIGHTERS - More armor, slower
            heavy: {
                shield: 60, maxShield: 60,
                armor: 80, maxArmor: 80,
                shieldRecharge: 1.2,
                armorRecharge: 0,
                accel: 0.8,
                speed: 0.9,
                turnRate: 0.8,
                crew: 3,
                strength: 80,
                mass: 60,
                disableThreshold: 0.33,
                aiType: 'warship'
            },
            // BOSS/CAPITAL - Heavy armor and shields, slow
            boss: {
                shield: 200, maxShield: 200,
                armor: 300, maxArmor: 300,
                shieldRecharge: 2.5,
                armorRecharge: 0.5,   // Capital ships have light armor regen
                accel: 0.4,
                speed: 0.5,
                turnRate: 0.4,
                crew: 50,
                strength: 500,
                mass: 500,
                disableThreshold: 0.33,
                aiType: 'warship'
            },
            // FREIGHTER - Cargo hauler, weak combat
            freighter: {
                shield: 40, maxShield: 40,
                armor: 60, maxArmor: 60,
                shieldRecharge: 0.6,
                armorRecharge: 0,
                accel: 0.5,
                speed: 0.6,
                turnRate: 0.5,
                crew: 5,
                strength: 30,
                mass: 150,
                disableThreshold: 0.33,
                aiType: 'wimpyTrader'
            },
            // COURIER - Fast trader
            courier: {
                shield: 30, maxShield: 30,
                armor: 20, maxArmor: 20,
                shieldRecharge: 1.0,
                armorRecharge: 0,
                accel: 1.1,
                speed: 1.2,
                turnRate: 1.1,
                crew: 2,
                strength: 15,
                mass: 30,
                disableThreshold: 0.33,
                aiType: 'braveTrader'
            }
        };

        // AI Behavior Types from EV Bible
        // 1: Wimpy Trader - runs away when attacked
        // 2: Brave Trader - fights back but flees when attacker out of range
        // 3: Warship - seeks enemies, fights to the end
        // 4: Interceptor - aggressive, scans for targets
        const AI_BEHAVIORS = {
            wimpyTrader: {
                aggression: 0,      // Never initiates
                fleeThreshold: 0.9, // Flees at 90% health
                pursuitRange: 0,    // Doesn't pursue
                preferredRange: 500 // Tries to stay far
            },
            braveTrader: {
                aggression: 0.3,
                fleeThreshold: 0.5,
                pursuitRange: 300,
                preferredRange: 200
            },
            warship: {
                aggression: 0.8,
                fleeThreshold: 0.15,
                pursuitRange: 600,
                preferredRange: 150
            },
            interceptor: {
                aggression: 1.0,
                fleeThreshold: 0.1,
                pursuitRange: 800,
                preferredRange: 100
            }
        };

        // Combat Rating thresholds (from ev_bible)
        const COMBAT_RATINGS = [
            { kills: 0, name: 'Harmless', color: '#666666' },
            { kills: 1, name: 'Mostly Harmless', color: '#888888' },
            { kills: 10, name: 'Poor', color: '#aaaaaa' },
            { kills: 25, name: 'Average', color: '#cccccc' },
            { kills: 50, name: 'Above Average', color: '#00aa00' },
            { kills: 100, name: 'Competent', color: '#00cc00' },
            { kills: 200, name: 'Dangerous', color: '#ffaa00' },
            { kills: 400, name: 'Deadly', color: '#ff6600' },
            { kills: 800, name: 'Elite', color: '#ff0000' },
            { kills: 1600, name: 'Elite II', color: '#ff00ff' },
            { kills: 3200, name: 'Elite III', color: '#00ffff' }
        ];

        function getCombatRating(kills) {
            for (let i = COMBAT_RATINGS.length - 1; i >= 0; i--) {
                if (kills >= COMBAT_RATINGS[i].kills) {
                    return COMBAT_RATINGS[i];
                }
            }
            return COMBAT_RATINGS[0];
        }

        // EV-style damage application
        // energyDmg hits shields first, massDmg hits armor
        // Shield damage bleeds through when shields depleted
        function applyEVDamage(target, energyDmg, massDmg) {
            let remainingEnergy = energyDmg;
            let remainingMass = massDmg;

            // Energy damage hits shields first
            if (target.shield > 0 && remainingEnergy > 0) {
                const shieldDmg = Math.min(target.shield, remainingEnergy);
                target.shield -= shieldDmg;
                remainingEnergy -= shieldDmg;
            }

            // Remaining energy bleeds to armor at 50% effectiveness
            if (remainingEnergy > 0) {
                remainingMass += remainingEnergy * 0.5;
            }

            // Mass damage hits armor directly
            if (target.armor > 0 && remainingMass > 0) {
                target.armor -= remainingMass;
            }

            // Check for disable (33% armor threshold)
            if (target.armor > 0 && target.armor <= target.maxArmor * target.disableThreshold) {
                target.disabled = true;
            }

            // Check for destruction
            if (target.armor <= 0) {
                target.armor = 0;
                target.destroyed = true;
            }

            // Update legacy health for compatibility
            target.health = target.shield + target.armor;
            target.maxHealth = target.maxShield + target.maxArmor;

            return target.destroyed;
        }

        // Shield/Armor regeneration update
        function updateShipRegeneration(ship, deltaTime) {
            if (ship.destroyed || ship.disabled) return;

            // Shield regeneration
            if (ship.shield < ship.maxShield && ship.shieldRecharge > 0) {
                ship.shield = Math.min(ship.maxShield, ship.shield + ship.shieldRecharge * deltaTime);
            }

            // Armor regeneration (rare, usually only capital ships)
            if (ship.armor < ship.maxArmor && ship.armorRecharge > 0) {
                ship.armor = Math.min(ship.maxArmor, ship.armor + ship.armorRecharge * deltaTime);
            }

            // Update legacy health
            ship.health = ship.shield + ship.armor;
        }

        // Expose EV functions for testing/verification
        window.EV_SHIP_STATS = EV_SHIP_STATS;
        window.AI_BEHAVIORS = AI_BEHAVIORS;
        window.COMBAT_RATINGS = COMBAT_RATINGS;
        window.getCombatRating = getCombatRating;
        window.applyEVDamage = applyEVDamage;
        window.updateShipRegeneration = updateShipRegeneration;

        // ========== FACTION LORE AND DATA ==========
        // Inspired by Escape Velocity and Realspace trilogy

        const FACTIONS = {
            // HUMAN FACTIONS
            terranConfederacy: {
                id: 'terranConfederacy',
                name: 'Terran Confederacy',
                shortName: 'Confederacy',
                color: '#4488ff',
                description: 'The main human government spanning from the Solar System to colonies across the galaxy. The United Fleet has been fighting the Katuri for 40 years.',
                shipTypes: ['uf_fighter', 'uf_corvette', 'uf_cruiser'],
                attitude: 'lawful',
                defaultRep: 0,
                allies: ['bhu', 'galacticPolice', 'freeCompanies'],
                enemies: ['secondRebellion', 'cau', 'katuri', 'pirates', 'renegades']
            },
            secondRebellion: {
                id: 'secondRebellion',
                name: 'Second Rebellion',
                shortName: 'Rebels',
                color: '#ff4444',
                description: 'A revolution against the corrupt, totalitarian, over-militaristic Confederacy. They fight for freedom and democracy.',
                shipTypes: ['rebel_fighter', 'rebel_gunship', 'rebel_carrier'],
                attitude: 'revolutionary',
                defaultRep: 0,
                allies: ['cau'],
                enemies: ['terranConfederacy', 'bhu']
            },
            cau: {
                id: 'cau',
                name: 'Colonial Allied Union',
                shortName: 'CAU',
                color: '#88ff44',
                description: 'A secret group of frontier colonies, many allied with the Katuri against Confederate expansion.',
                shipTypes: ['cau_scout', 'cau_transport', 'cau_defender'],
                attitude: 'secretive',
                defaultRep: 0,
                allies: ['secondRebellion', 'katuri'],
                enemies: ['terranConfederacy']
            },
            unitedEarth: {
                id: 'unitedEarth',
                name: 'United Earth Loyalists',
                shortName: 'UE Loyalists',
                color: '#44ffff',
                description: 'Remnants of the original United Earth government formed during the Voinian invasion. 10-11 loyal admirals still fight to restore the original UE.',
                shipTypes: ['ue_destroyer', 'ue_carrier', 'ue_battleship'],
                attitude: 'nostalgic',
                defaultRep: 10,
                allies: [],
                enemies: ['voinian']
            },
            pirates: {
                id: 'pirates',
                name: 'Pirates',
                shortName: 'Pirates',
                color: '#ff8800',
                description: 'Real raiders who loot both Confederate and Rebel ships. Honor among thieves is their only code.',
                shipTypes: ['pirate_raider', 'pirate_marauder', 'pirate_dreadnought'],
                attitude: 'hostile',
                defaultRep: -30,
                allies: [],
                enemies: ['terranConfederacy', 'bhu', 'galacticPolice', 'miranu']
            },
            bhu: {
                id: 'bhu',
                name: 'Bounty Hunters Unlimited',
                shortName: 'BHU',
                color: '#ffff44',
                description: 'Licensed privateers who escort and protect merchants. Usually honorable, but credits speak louder than morals.',
                shipTypes: ['bhu_interceptor', 'bhu_gunboat'],
                attitude: 'mercenary',
                defaultRep: 0,
                allies: ['terranConfederacy', 'freeCompanies'],
                enemies: ['pirates', 'renegades']
            },
            renegades: {
                id: 'renegades',
                name: 'Renegades',
                shortName: 'Renegades',
                color: '#880000',
                description: 'Violent extremists rejected by all factions. They kill all captives. Major groups: North Tip and South Tip Renegades.',
                shipTypes: ['renegade_raider', 'renegade_warship'],
                attitude: 'psychotic',
                defaultRep: -50,
                allies: [],
                enemies: ['terranConfederacy', 'secondRebellion', 'bhu', 'galacticPolice', 'miranu', 'katuri']
            },
            freeCompanies: {
                id: 'freeCompanies',
                name: 'Free Companies',
                shortName: 'Free Co.',
                color: '#44ff88',
                description: 'Federation of wealthy businesses: Stellar Corp, Luminus Life Services, OmniArms Infinite. Profit above all.',
                shipTypes: ['fc_freighter', 'fc_escort', 'fc_security'],
                attitude: 'corporate',
                defaultRep: 0,
                allies: ['terranConfederacy', 'bhu'],
                enemies: ['helionova', 'pirates']
            },
            helionova: {
                id: 'helionova',
                name: 'Helionova Initiative',
                shortName: 'Helionova',
                color: '#aa44ff',
                description: 'Think-tank researching weapons and extraterrestrial life. Suspected SETI connection. Currently in Trade Wars with Free Companies.',
                shipTypes: ['helionova_research', 'helionova_prototype'],
                attitude: 'secretive',
                defaultRep: 0,
                allies: ['seti'],
                enemies: ['freeCompanies']
            },
            galacticPolice: {
                id: 'galacticPolice',
                name: 'Galactic Police',
                shortName: 'GP',
                color: '#ffffff',
                description: 'Multispecies law enforcement operating above the political fray. They enforce galactic law impartially.',
                shipTypes: ['gp_patrol', 'gp_cruiser'],
                attitude: 'lawful',
                defaultRep: 20,
                allies: ['terranConfederacy', 'miranu'],
                enemies: ['pirates', 'renegades']
            },

            // ALIEN FACTIONS
            katuri: {
                id: 'katuri',
                name: 'Katuri Empire',
                shortName: 'Katuri',
                color: '#ff44ff',
                description: 'Proud warrior race from Sirius Prime. The war began when the United Fleet tried to invade their homeworld 40 years ago.',
                shipTypes: ['katuri_interceptor', 'katuri_destroyer', 'katuri_dreadnought'],
                attitude: 'warrior',
                defaultRep: -20,
                allies: ['cau'],
                enemies: ['terranConfederacy', 'unitedEarth', 'renegades']
            },
            simnuvia: {
                id: 'simnuvia',
                name: 'Simnuvia Technocracy',
                shortName: 'Simnuvia',
                color: '#00ffaa',
                description: 'Minor race risen to power via lightspeed engine technology. Obsessed with science. Allied with Miranu, at war with Kliaphin.',
                shipTypes: ['simnuvia_scout', 'simnuvia_research', 'simnuvia_warship'],
                attitude: 'scientific',
                defaultRep: 0,
                allies: ['miranu'],
                enemies: ['kliaphin', 'simnuviaPF']
            },
            simnuviaPF: {
                id: 'simnuviaPF',
                name: 'Simnuvia Purification Front',
                shortName: 'Purifiers',
                color: '#00aa88',
                description: 'Extremist Simnuvia faction believing in genetic purity. Violently opposed to the main Technocracy.',
                shipTypes: ['spf_fighter', 'spf_cruiser'],
                attitude: 'extremist',
                defaultRep: -10,
                allies: [],
                enemies: ['simnuvia', 'miranu']
            },
            kliaphin: {
                id: 'kliaphin',
                name: 'Kliaphin Republic',
                shortName: 'Kliaphin',
                color: '#8844ff',
                description: 'Powerful but cowardly race favoring diplomacy and assassination over direct combat. Known to use Renegades as proxies.',
                shipTypes: ['kliaphin_courier', 'kliaphin_assassin', 'kliaphin_capital'],
                attitude: 'scheming',
                defaultRep: 0,
                allies: [],
                enemies: ['simnuvia', 'unitedEarth', 'katuri', 'voinian']
            },
            miranu: {
                id: 'miranu',
                name: 'Miranu Trading Empire',
                shortName: 'Miranu',
                color: '#ffaa44',
                description: 'Peaceful traders including the Mrainu and Zachit subfactions. They prefer commerce over conflict.',
                shipTypes: ['miranu_courier', 'miranu_freighter', 'zachit_fighter'],
                attitude: 'peaceful',
                defaultRep: 10,
                allies: ['simnuvia', 'galacticPolice'],
                enemies: ['pirates', 'renegades']
            },
            gadzair: {
                id: 'gadzair',
                name: 'Gadzair Strands',
                shortName: 'Strands',
                color: '#ff4488',
                description: 'Ancient race divided into Strands: Zidagar, Azdgari, Igazdra, Ragadiz (the hidden first Strand), Dragiza, and the Strandless.',
                shipTypes: ['zidagar_fighter', 'azdgari_warship', 'igazdra_cruiser'],
                attitude: 'divided',
                defaultRep: 0,
                allies: [],
                enemies: []
            },
            voinian: {
                id: 'voinian',
                name: 'Voinian Explorers',
                shortName: 'Voinians',
                color: '#884400',
                description: 'Remnants of the Voinian Empire that once invaded human space and was pushed back. Now reduced to exploration.',
                shipTypes: ['voinian_fighter', 'voinian_cruiser', 'voinian_dreadnought'],
                attitude: 'expansionist',
                defaultRep: -10,
                allies: [],
                enemies: ['unitedEarth', 'kliaphin', 'emalgha']
            },
            emalgha: {
                id: 'emalgha',
                name: 'Emalgha Coalition',
                shortName: 'Emalgha',
                color: '#44aa44',
                description: 'Alien coalition that resisted Voinian conquest. Fierce and proud warriors.',
                shipTypes: ['emalgha_fighter', 'emalgha_warship'],
                attitude: 'resistant',
                defaultRep: 0,
                allies: ['hinwar'],
                enemies: ['voinian']
            },
            hinwar: {
                id: 'hinwar',
                name: 'Hinwar Commonwealth',
                shortName: 'Hinwar',
                color: '#4488aa',
                description: 'Alien commonwealth seeking peaceful coexistence with other species.',
                shipTypes: ['hinwar_shuttle', 'hinwar_defender'],
                attitude: 'peaceful',
                defaultRep: 5,
                allies: ['emalgha'],
                enemies: ['voinian']
            },
            talramuv: {
                id: 'talramuv',
                name: 'Talramuv Imperium',
                shortName: 'Talramuv',
                color: '#ffdd00',
                description: 'Ancient galaxy-spanning empire, now scattered. Homeworld Xiv\'Naza location unknown, but recent sightings at the frontier.',
                shipTypes: ['talramuv_scout', 'talramuv_cruiser', 'talramuv_titan'],
                attitude: 'ancient',
                defaultRep: 0,
                allies: [],
                enemies: []
            },

            // MYSTERY FACTIONS
            theAliens: {
                id: 'theAliens',
                name: 'The Aliens',
                shortName: 'Aliens',
                color: '#00ff00',
                description: 'Ancient marauders from the First Encounter, scared away by suicidal militias. Recent sightings at the frontier suggest their return.',
                shipTypes: ['alien_scout', 'alien_destroyer', 'alien_mothership'],
                attitude: 'unknown',
                defaultRep: -100,
                allies: [],
                enemies: ['terranConfederacy', 'katuri', 'miranu', 'gadzair']
            },
            seti: {
                id: 'seti',
                name: 'SETI',
                shortName: 'SETI',
                color: '#00aaff',
                description: 'Special Extraterrestrial Task force Indigo. Secret UF branch investigating The Aliens. Suspected of past alien contact.',
                shipTypes: ['seti_stealth', 'seti_research'],
                attitude: 'covert',
                defaultRep: 0,
                allies: ['helionova'],
                enemies: []
            }
        };

        // Storylines inspired by EV/Realspace
        const STORYLINES = {
            terranKaturiWar: {
                id: 'terranKaturiWar',
                name: 'The Terran-Katuri War',
                description: 'The 40-year conflict between the Confederacy and the Katuri Empire. Choose your side.',
                factions: ['terranConfederacy', 'katuri'],
                triggerCondition: 'kills >= 10',
                priority: 1
            },
            secondCivilWar: {
                id: 'secondCivilWar',
                name: 'The Second Civil War',
                description: 'The Confederacy faces internal strife as the Second Rebellion grows in power.',
                factions: ['terranConfederacy', 'secondRebellion'],
                triggerCondition: 'sectorsCleared >= 3',
                priority: 2
            },
            tradeWar: {
                id: 'tradeWar',
                name: 'Trade Wars',
                description: 'Free Companies and Helionova Initiative clash over resources and secrets.',
                factions: ['freeCompanies', 'helionova'],
                triggerCondition: 'credits >= 500',
                priority: 3
            },
            strandsCoup: {
                id: 'strandsCoup',
                name: 'Strands Coup',
                description: 'Political upheaval among the Gadzair as the hidden Ragadiz Strand emerges.',
                factions: ['gadzair'],
                triggerCondition: 'sectorsCleared >= 8',
                priority: 4
            },
            secretOfSeti: {
                id: 'secretOfSeti',
                name: 'Secret of SETI',
                description: 'Uncover the conspiracy behind SETI and their connection to The Aliens.',
                factions: ['seti', 'helionova', 'theAliens'],
                triggerCondition: 'kills >= 50',
                priority: 5
            },
            revengeOfAliens: {
                id: 'revengeOfAliens',
                name: 'Revenge of The Aliens',
                description: 'The ancient marauders return. The galaxy must unite or perish.',
                factions: ['theAliens'],
                triggerCondition: 'sectorsCleared >= 15',
                priority: 6
            },
            fuelOfSorrows: {
                id: 'fuelOfSorrows',
                name: 'Fuel of Sorrows',
                description: 'Crystallized Plasma - the strange matter fuel coveted by all. Control it, control the galaxy.',
                factions: ['freeCompanies', 'miranu', 'katuri'],
                triggerCondition: 'credits >= 1000',
                priority: 3
            },
            pirateKings: {
                id: 'pirateKings',
                name: 'Rise of the Pirate Kings',
                description: 'The scattered pirate clans unite under new leadership. A new power rises.',
                factions: ['pirates'],
                triggerCondition: 'reputation.pirates >= 20',
                priority: 4
            }
        };

        // Mission templates
        const MISSION_TEMPLATES = {
            patrol: {
                titleTemplates: ['Patrol {sector}', 'Secure {sector}', 'Sweep {sector}'],
                descTemplates: [
                    'Eliminate hostile forces in the {sector} sector.',
                    'Clear {sector} of enemy ships threatening our operations.',
                    'Our intelligence reports hostiles in {sector}. Neutralize them.'
                ],
                type: 'combat',
                baseReward: 100
            },
            escort: {
                titleTemplates: ['Escort Convoy', 'Protect Transport', 'Guard Shipment'],
                descTemplates: [
                    'Escort a convoy of {faction} ships safely through hostile space.',
                    'A valuable cargo shipment needs protection. Guard it with your life.',
                    'Pirates have been targeting our transports. Provide escort.'
                ],
                type: 'escort',
                baseReward: 150
            },
            assassination: {
                titleTemplates: ['Eliminate Target', 'High Value Target', 'Bounty Hunt'],
                descTemplates: [
                    'A dangerous {enemy} commander threatens our interests. Eliminate them.',
                    'There\'s a bounty on a notorious {enemy} captain. Collect it.',
                    'Intelligence has located a high-value target. Strike now.'
                ],
                type: 'assassination',
                baseReward: 200
            },
            delivery: {
                titleTemplates: ['Deliver Supplies', 'Critical Cargo', 'Emergency Transport'],
                descTemplates: [
                    'Deliver critical supplies to our forces in {sector}.',
                    'Time-sensitive cargo requires immediate transport.',
                    'Our outpost in {sector} desperately needs these supplies.'
                ],
                type: 'delivery',
                baseReward: 80
            },
            reconnaissance: {
                titleTemplates: ['Scout {sector}', 'Intelligence Gathering', 'Reconnaissance Mission'],
                descTemplates: [
                    'Scout the {sector} sector and report enemy positions.',
                    'We need intelligence on {enemy} movements. Investigate carefully.',
                    'Survey {sector} without engaging hostile forces.'
                ],
                type: 'recon',
                baseReward: 120
            },
            storyline: {
                titleTemplates: ['Special Operation', 'Priority Mission', 'Command Authority'],
                descTemplates: [
                    'High Command has authorized a special operation. Details classified.',
                    'This mission comes directly from {faction} leadership.',
                    'A unique opportunity has arisen. Success will change everything.'
                ],
                type: 'storyline',
                baseReward: 500
            }
        };

        // Dialogue for different factions
        const FACTION_DIALOGUE = {
            terranConfederacy: {
                hail: [
                    'This is Confederate patrol. State your business, pilot.',
                    'United Fleet command. Maintain your course and prepare for inspection.',
                    'Confederacy vessel hailing. The war effort needs pilots like you.'
                ],
                friendly: [
                    'Good to see loyal citizens out here. The Katuri won\'t defeat themselves.',
                    'The Confederacy appreciates your service. President Bebellrov sends regards.',
                    'We\'ve held the line for 40 years. With pilots like you, we\'ll hold it 40 more.'
                ],
                hostile: [
                    'Hostile contact! All ships, engage the traitor!',
                    'You\'ve chosen the wrong side. Prepare to be neutralized.',
                    'Confederate justice finds all who oppose us.'
                ]
            },
            secondRebellion: {
                hail: [
                    'Freedom fighter hailing. Are you friend or Confederacy stooge?',
                    'Rebel command. We fight against tyranny - do you?',
                    'The revolution will not be silenced. Where do you stand?'
                ],
                friendly: [
                    'The corrupt Confederacy must fall. Join us, and we\'ll build something better.',
                    'Bebellrov\'s war machine grinds on. Together, we can stop it.',
                    'For freedom! For democracy! For the Second Rebellion!'
                ],
                hostile: [
                    'Confederate sympathizer detected! All units, weapons free!',
                    'You serve the tyrants. You\'ll share their fate.',
                    'The revolution has no mercy for oppressors!'
                ]
            },
            katuri: {
                hail: [
                    'Human vessel. The Empire of Sirius Prime observes you.',
                    'Katuri warrior hailing. Your kind invaded our homeworld. We remember.',
                    'Forty years of war. Has humanity learned nothing?'
                ],
                friendly: [
                    'You show honor, human. Perhaps there is hope for your species.',
                    'The Empire respects strength. You have proven yours.',
                    'Not all humans are warmongers. You may pass in peace.'
                ],
                hostile: [
                    'For Sirius Prime! Death to the invaders!',
                    'Your United Fleet tried to conquer us. Now face Katuri vengeance!',
                    'Warriors of the Empire, destroy the human aggressor!'
                ]
            },
            pirates: {
                hail: [
                    'Well, well... what do we have here? A juicy target.',
                    'Arr! Drop your cargo or your shields. Your choice.',
                    'Pirate vessel to unidentified craft. You\'re in the wrong sector, friend.'
                ],
                friendly: [
                    'Ha! Another scoundrel joins the brotherhood. Welcome aboard!',
                    'You\'ve got guts, I\'ll give you that. The Pirate Kings could use you.',
                    'Credits speak louder than flags out here. You understand that.'
                ],
                hostile: [
                    'That\'s a nice ship you\'ve got. I think I\'ll take it!',
                    'Nothing personal, but your cargo is now ours.',
                    'Fire everything! Leave nothing but scrap!'
                ]
            },
            miranu: {
                hail: [
                    'Miranu trader hailing. We come in peace and commerce.',
                    'The Trading Empire extends greetings. May our exchange be profitable.',
                    'Zachit escort here. The trade lanes are under our protection.'
                ],
                friendly: [
                    'A reliable trading partner is worth more than credits. You are such a partner.',
                    'The Miranu remember their friends. You are always welcome in our ports.',
                    'Peace and profit - the twin pillars of civilization. You understand this.'
                ],
                hostile: [
                    'The Zachit protect Miranu interests. You threaten those interests.',
                    'Even peaceful traders can bare their teeth. Defend yourselves!',
                    'Aggression against the Trading Empire will not go unanswered!'
                ]
            },
            renegades: {
                hail: [
                    '*static* ...no survivors... *static* ...kill them all...',
                    'North Tip Renegades claim this space. All trespassers die.',
                    'South Tip sends regards. Your death will be... entertaining.'
                ],
                friendly: [
                    'You\'ve got that look. The look of someone who\'s killed without remorse. Welcome.',
                    'The rejected and the damned. We take all kinds.',
                    'No rules. No mercy. No regrets. That\'s the Renegade way.'
                ],
                hostile: [
                    'DESTROY! CONSUME! ANNIHILATE!',
                    'Your screams will echo in the void forever!',
                    'We take no prisoners! We show no mercy!'
                ]
            },
            theAliens: {
                hail: [
                    '*incomprehensible signal*',
                    '...RETURN... ...CLAIM... ...CONSUME...',
                    '*reality distortion detected*'
                ],
                friendly: [
                    '...YOU... ...DIFFERENT... ...OBSERVE...',
                    '*curious scanning*',
                    '...POTENTIAL... ...SPECIMEN...'
                ],
                hostile: [
                    '...CLEANSE... ...HARVEST... ...ERADICATE...',
                    '*hostile intent detected* ...FIRST ENCOUNTER REPEATS...',
                    '...YOU DROVE US AWAY ONCE... ...NEVER AGAIN...'
                ]
            },
            seti: {
                hail: [
                    'SETI operative. This channel is classified. State authorization.',
                    'Task Force Indigo. You\'re not supposed to be here.',
                    'Unknown vessel, this is restricted space. Leave immediately.'
                ],
                friendly: [
                    'The truth is out there, pilot. Help us find it.',
                    'We\'ve seen things... things the public can\'t know. Not yet.',
                    'Welcome to SETI. What you learn here stays here. Understood?'
                ],
                hostile: [
                    'You\'ve seen too much. This is a containment operation.',
                    'SETI security protocol initiated. No witnesses.',
                    'Some secrets are worth killing for.'
                ]
            },
            gadzair: {
                hail: [
                    'Strand vessel to unknown craft. Identify your Strand allegiance.',
                    'Zidagar patrol. The Strands watch all who enter our space.',
                    'Azdgari hunter here. Prepare for speed and death.'
                ],
                friendly: [
                    'The Strands have long memories. You have earned a place in ours.',
                    'Igazdra engineers respect ingenuity. You have shown it.',
                    'The Ragadiz emerge from shadow. Perhaps you will see our truth.'
                ],
                hostile: [
                    'Strand honor demands we destroy you!',
                    'The Gadzair do not forgive. The Gadzair do not forget!',
                    'For the glory of the Strands!'
                ]
            }
        };

        // Faction state management
        let factionState = {
            reputation: {},  // Will be populated with faction IDs and reputation values
            discoveredFactions: new Set(['terranConfederacy', 'pirates']),  // Start with basic knowledge
            activeStorylines: new Set(),
            completedStorylines: new Set(),
            currentMission: null,
            availableMissions: [],
            missionProgress: {},
            currentEncounter: null,
            crystallizedPlasma: 0  // Special resource
        };

        // Initialize faction reputation
        function initFactionReputation() {
            for (const [id, faction] of Object.entries(FACTIONS)) {
                factionState.reputation[id] = faction.defaultRep;
            }
        }

        // Get faction attitude towards player based on reputation
        function getFactionAttitude(factionId) {
            const rep = factionState.reputation[factionId] || 0;
            if (rep >= 50) return 'allied';
            if (rep >= 20) return 'friendly';
            if (rep >= -20) return 'neutral';
            if (rep >= -50) return 'unfriendly';
            return 'hostile';
        }

        // Modify reputation
        function modifyReputation(factionId, amount) {
            const faction = FACTIONS[factionId];
            if (!faction) return;

            factionState.reputation[factionId] = Math.max(-100, Math.min(100,
                (factionState.reputation[factionId] || 0) + amount
            ));

            // Allied factions gain/lose rep too (at reduced rate)
            faction.allies.forEach(allyId => {
                if (FACTIONS[allyId]) {
                    factionState.reputation[allyId] = Math.max(-100, Math.min(100,
                        (factionState.reputation[allyId] || 0) + Math.floor(amount * 0.3)
                    ));
                }
            });

            // Enemy factions gain/lose opposite rep
            faction.enemies.forEach(enemyId => {
                if (FACTIONS[enemyId]) {
                    factionState.reputation[enemyId] = Math.max(-100, Math.min(100,
                        (factionState.reputation[enemyId] || 0) - Math.floor(amount * 0.3)
                    ));
                }
            });

            // Discover faction if not known
            if (!factionState.discoveredFactions.has(factionId)) {
                factionState.discoveredFactions.add(factionId);
                showMessage(`Discovered: ${faction.name}`);
            }

            updateFactionPanel();
            checkStorylineTriggers();
        }

        // Check if storylines should trigger
        function checkStorylineTriggers() {
            for (const [id, storyline] of Object.entries(STORYLINES)) {
                if (factionState.activeStorylines.has(id) || factionState.completedStorylines.has(id)) {
                    continue;
                }

                let triggered = false;
                const condition = storyline.triggerCondition;

                if (condition.includes('kills')) {
                    const threshold = parseInt(condition.split('>=')[1]);
                    if (playerState.kills >= threshold) triggered = true;
                } else if (condition.includes('sectorsCleared')) {
                    const threshold = parseInt(condition.split('>=')[1]);
                    if (playerState.sectorsCleared >= threshold) triggered = true;
                } else if (condition.includes('credits')) {
                    const threshold = parseInt(condition.split('>=')[1]);
                    if (playerState.credits >= threshold) triggered = true;
                } else if (condition.includes('reputation')) {
                    const match = condition.match(/reputation\.(\w+)\s*>=\s*(-?\d+)/);
                    if (match) {
                        const factionId = match[1];
                        const threshold = parseInt(match[2]);
                        if ((factionState.reputation[factionId] || 0) >= threshold) triggered = true;
                    }
                }

                if (triggered) {
                    triggerStoryline(id);
                    break;  // Only trigger one storyline at a time
                }
            }
        }

        // Trigger a storyline
        function triggerStoryline(storylineId) {
            const storyline = STORYLINES[storylineId];
            if (!storyline) return;

            factionState.activeStorylines.add(storylineId);

            // Discover associated factions
            storyline.factions.forEach(factionId => {
                if (!factionState.discoveredFactions.has(factionId)) {
                    factionState.discoveredFactions.add(factionId);
                }
            });

            // Show notification
            showStorylineNotification(storyline.name, storyline.description);

            // Generate initial storyline mission
            generateStorylineMission(storylineId);

            updateFactionPanel();
        }

        // Show storyline notification
        function showStorylineNotification(title, description) {
            const notif = document.getElementById('storylineNotification');
            document.getElementById('storylineTitle').textContent = title;
            document.getElementById('storylineDesc').textContent = description;
            notif.style.display = 'block';
        }

        // Close storyline notification
        window.closeStorylineNotification = function() {
            document.getElementById('storylineNotification').style.display = 'none';
        };

        // Generate missions based on current state
        function generateMissions() {
            factionState.availableMissions = [];

            // Generate 2-4 missions from friendly/neutral factions
            const eligibleFactions = Array.from(factionState.discoveredFactions)
                .filter(fid => {
                    const attitude = getFactionAttitude(fid);
                    return attitude !== 'hostile' && FACTIONS[fid];
                });

            const missionCount = 2 + Math.floor(Math.random() * 3);

            for (let i = 0; i < missionCount && eligibleFactions.length > 0; i++) {
                const factionId = eligibleFactions[Math.floor(Math.random() * eligibleFactions.length)];
                const faction = FACTIONS[factionId];

                // Pick mission type based on faction attitude
                let templateTypes = ['patrol', 'escort', 'delivery', 'reconnaissance'];
                if (faction.attitude === 'warrior' || faction.attitude === 'mercenary') {
                    templateTypes = ['patrol', 'assassination', 'escort'];
                } else if (faction.attitude === 'peaceful' || faction.attitude === 'corporate') {
                    templateTypes = ['escort', 'delivery', 'reconnaissance'];
                }

                const templateType = templateTypes[Math.floor(Math.random() * templateTypes.length)];
                const template = MISSION_TEMPLATES[templateType];

                const sectorDist = Math.abs(playerState.currentSector.x) + Math.abs(playerState.currentSector.y);
                const enemyFaction = faction.enemies.length > 0
                    ? FACTIONS[faction.enemies[Math.floor(Math.random() * faction.enemies.length)]]
                    : null;

                const sectorName = `${playerState.currentSector.x + (Math.random() > 0.5 ? 1 : -1)}-${playerState.currentSector.y + (Math.random() > 0.5 ? 1 : -1)}`;

                let title = template.titleTemplates[Math.floor(Math.random() * template.titleTemplates.length)]
                    .replace('{sector}', `Sector ${sectorName}`)
                    .replace('{faction}', faction.shortName);

                let desc = template.descTemplates[Math.floor(Math.random() * template.descTemplates.length)]
                    .replace('{sector}', `Sector ${sectorName}`)
                    .replace('{faction}', faction.shortName)
                    .replace('{enemy}', enemyFaction ? enemyFaction.shortName : 'hostile');

                const reward = Math.floor(template.baseReward * (1 + sectorDist * 0.2) * (0.8 + Math.random() * 0.4));
                const repReward = Math.floor(5 + Math.random() * 10);

                factionState.availableMissions.push({
                    id: `mission_${Date.now()}_${i}`,
                    title,
                    description: desc,
                    type: template.type,
                    giver: factionId,
                    target: enemyFaction ? enemyFaction.id : null,
                    targetSector: sectorName,
                    reward,
                    repReward,
                    killsRequired: templateType === 'patrol' || templateType === 'assassination' ? 3 + Math.floor(Math.random() * 4) : 0,
                    killsProgress: 0,
                    completed: false
                });
            }

            return factionState.availableMissions;
        }

        // Generate storyline mission
        function generateStorylineMission(storylineId) {
            const storyline = STORYLINES[storylineId];
            if (!storyline || storyline.factions.length === 0) return;

            const factionId = storyline.factions[0];
            const faction = FACTIONS[factionId];
            if (!faction) return;

            const template = MISSION_TEMPLATES.storyline;
            const sectorName = `${playerState.currentSector.x + 2}-${playerState.currentSector.y + 2}`;

            const mission = {
                id: `storyline_${storylineId}_${Date.now()}`,
                title: `${storyline.name}: Chapter 1`,
                description: `${storyline.description} Report to ${faction.shortName} space to begin.`,
                type: 'storyline',
                giver: factionId,
                storylineId,
                targetSector: sectorName,
                reward: template.baseReward,
                repReward: 20,
                killsRequired: 5,
                killsProgress: 0,
                completed: false,
                isStoryline: true
            };

            factionState.availableMissions.unshift(mission);
        }

        // Accept a mission
        function acceptMission(missionId) {
            const mission = factionState.availableMissions.find(m => m.id === missionId);
            if (!mission) return;

            factionState.currentMission = mission;
            factionState.availableMissions = factionState.availableMissions.filter(m => m.id !== missionId);

            showMessage(`Mission Accepted: ${mission.title}`);
            updateActiveMissionPanel();
            toggleMissionPanel();
        }

        // Update mission progress
        function updateMissionProgress(killFactionId = null) {
            if (!factionState.currentMission) return;

            const mission = factionState.currentMission;

            if (mission.killsRequired > 0) {
                // Check if killed enemy is relevant to mission
                if (!mission.target || mission.target === killFactionId) {
                    mission.killsProgress++;

                    if (mission.killsProgress >= mission.killsRequired) {
                        completeMission();
                    } else {
                        updateActiveMissionPanel();
                    }
                }
            }
        }

        // Complete current mission
        function completeMission() {
            const mission = factionState.currentMission;
            if (!mission) return;

            playerState.credits += mission.reward;
            modifyReputation(mission.giver, mission.repReward);

            if (mission.isStoryline && mission.storylineId) {
                // Advance storyline
                showMessage(`Storyline Progress: ${STORYLINES[mission.storylineId].name}`);
            }

            showMessage(`Mission Complete! +${mission.reward} CR`);
            mission.completed = true;
            factionState.currentMission = null;
            updateActiveMissionPanel();
        }

        // Abandon current mission
        function abandonMission() {
            if (!factionState.currentMission) return;

            const mission = factionState.currentMission;
            modifyReputation(mission.giver, -5);  // Small reputation penalty
            showMessage('Mission Abandoned');
            factionState.currentMission = null;
            updateActiveMissionPanel();
        }

        // Update faction panel UI
        function updateFactionPanel() {
            const list = document.getElementById('factionList');
            if (!list) return;

            list.innerHTML = '';

            const sortedFactions = Array.from(factionState.discoveredFactions)
                .filter(fid => FACTIONS[fid])
                .sort((a, b) => Math.abs(factionState.reputation[b]) - Math.abs(factionState.reputation[a]));

            sortedFactions.slice(0, 8).forEach(factionId => {
                const faction = FACTIONS[factionId];
                const rep = factionState.reputation[factionId] || 0;
                const attitude = getFactionAttitude(factionId);

                let repColor = '#888';
                if (rep > 20) repColor = '#4f4';
                else if (rep > 0) repColor = '#8f8';
                else if (rep < -20) repColor = '#f44';
                else if (rep < 0) repColor = '#f88';

                const attitudeColors = {
                    allied: '#0f0',
                    friendly: '#8f8',
                    neutral: '#888',
                    unfriendly: '#f88',
                    hostile: '#f44'
                };

                const item = document.createElement('div');
                item.className = 'faction-item';
                item.innerHTML = `
                    <span class="faction-name" style="color:${faction.color}" title="${faction.name}">${faction.shortName}</span>
                    <div class="rep-bar">
                        <div class="rep-fill" style="background:${repColor};width:${Math.abs(rep)/2}%;left:${rep >= 0 ? '50%' : (50 - Math.abs(rep)/2) + '%'}"></div>
                    </div>
                    <span class="rep-value" style="color:${attitudeColors[attitude]}">${rep > 0 ? '+' : ''}${rep}</span>
                `;
                list.appendChild(item);
            });
        }

        // Update mission panel UI
        function updateMissionPanel() {
            const list = document.getElementById('missionList');
            if (!list) return;

            list.innerHTML = '';

            if (factionState.availableMissions.length === 0) {
                list.innerHTML = '<div style="color:#888;text-align:center;padding:20px;">No missions available. Check back after exploring more sectors.</div>';
                return;
            }

            factionState.availableMissions.forEach(mission => {
                const faction = FACTIONS[mission.giver];
                const item = document.createElement('div');
                item.className = 'mission-item' + (factionState.currentMission?.id === mission.id ? ' active' : '');
                item.innerHTML = `
                    <div class="mission-title">${mission.title}</div>
                    <div class="mission-giver" style="color:${faction?.color || '#888'}">From: ${faction?.name || 'Unknown'}</div>
                    <div class="mission-desc">${mission.description}</div>
                    <div class="mission-reward">Reward: ${mission.reward} CR | +${mission.repReward} Rep</div>
                `;
                item.onclick = () => acceptMission(mission.id);
                list.appendChild(item);
            });
        }

        // Update active mission panel
        function updateActiveMissionPanel() {
            const panel = document.getElementById('activeMission');
            if (!panel) return;

            if (!factionState.currentMission) {
                panel.style.display = 'none';
                return;
            }

            const mission = factionState.currentMission;
            panel.style.display = 'block';
            document.getElementById('missionObjective').textContent = mission.title;

            let progress = '';
            if (mission.killsRequired > 0) {
                progress = `Kills: ${mission.killsProgress}/${mission.killsRequired}`;
            } else {
                progress = `Target: Sector ${mission.targetSector}`;
            }
            document.getElementById('missionProgress').textContent = progress;
        }

        // Toggle mission panel
        function toggleMissionPanel() {
            const panel = document.getElementById('missionPanel');
            if (panel.style.display === 'block') {
                panel.style.display = 'none';
            } else {
                generateMissions();  // Refresh missions
                updateMissionPanel();
                panel.style.display = 'block';
            }
        }

        // Show dialogue
        function showDialogue(factionId, dialogueType = 'hail') {
            const faction = FACTIONS[factionId];
            if (!faction) return;

            const dialogues = FACTION_DIALOGUE[factionId];
            if (!dialogues) return;

            const lines = dialogues[dialogueType] || dialogues.hail;
            const line = lines[Math.floor(Math.random() * lines.length)];

            const panel = document.getElementById('dialoguePanel');
            document.getElementById('dialogueSpeaker').innerHTML = `<span style="color:${faction.color}">${faction.name}</span>`;
            document.getElementById('dialogueText').textContent = line;

            const options = document.getElementById('dialogueOptions');
            options.innerHTML = '';

            // Generate response options based on attitude
            const attitude = getFactionAttitude(factionId);

            const closeBtn = document.createElement('button');
            closeBtn.className = 'dialogue-btn';
            closeBtn.textContent = 'Close Channel';
            closeBtn.onclick = () => { panel.style.display = 'none'; };
            options.appendChild(closeBtn);

            if (attitude !== 'hostile' && dialogueType === 'hail') {
                const missionBtn = document.createElement('button');
                missionBtn.className = 'dialogue-btn';
                missionBtn.textContent = 'Request Mission';
                missionBtn.onclick = () => {
                    panel.style.display = 'none';
                    toggleMissionPanel();
                };
                options.appendChild(missionBtn);
            }

            panel.style.display = 'block';
        }

        // Update encounter info when enemies are present
        function updateEncounterInfo() {
            const panel = document.getElementById('encounterInfo');

            if (enemies.length === 0 || !enemies.some(e => e.health > 0)) {
                panel.style.display = 'none';
                factionState.currentEncounter = null;
                return;
            }

            // Determine dominant faction in encounter
            const factionCounts = {};
            enemies.forEach(e => {
                if (e.health > 0 && e.faction) {
                    factionCounts[e.faction] = (factionCounts[e.faction] || 0) + 1;
                }
            });

            let dominantFaction = null;
            let maxCount = 0;
            for (const [fid, count] of Object.entries(factionCounts)) {
                if (count > maxCount) {
                    maxCount = count;
                    dominantFaction = fid;
                }
            }

            if (!dominantFaction) {
                panel.style.display = 'none';
                return;
            }

            const faction = FACTIONS[dominantFaction];
            const attitude = getFactionAttitude(dominantFaction);
            const attitudeColors = {
                allied: '#0f0',
                friendly: '#8f8',
                neutral: '#888',
                unfriendly: '#f88',
                hostile: '#f44'
            };

            factionState.currentEncounter = dominantFaction;

            document.getElementById('encounterFaction').innerHTML =
                `<span style="color:${faction.color}">${faction.name}</span>`;
            document.getElementById('encounterShips').textContent =
                `Ships: ${enemies.filter(e => e.health > 0 && e.faction === dominantFaction).length}`;
            document.getElementById('encounterAttitude').innerHTML =
                `Attitude: <span style="color:${attitudeColors[attitude]}">${attitude.toUpperCase()}</span>`;

            panel.style.display = 'block';
        }

        // Game state
        let scene, camera, renderer;
        let playerShip;
        let enemies = [];
        let projectiles = [];
        let particles = [];
        let stations = [];
        let pickups = [];
        let gameRunning = false;
        let gltfLoader;

        // ============================================================
        // GLB MODEL LOADING SYSTEM - Uses hand-made Blender models
        // ============================================================
        const MODEL_PATH = 'assets/models/';
        const modelCache = new Map(); // Cache loaded models
        let modelsLoaded = false;
        let modelLoadProgress = 0;

        // Shipyard preview system state
        let shipyardPreviewRenderer = null;
        let shipyardPreviewScene = null;
        let shipyardPreviewCamera = null;
        let shipyardPreviewModel = null;
        let shipyardPreviewAnimationId = null;
        let selectedShipKey = null;
        let shipyardPreviewRotation = 0;
        let isShipyardDragging = false;
        let shipyardDragStartX = 0;
        let shipyardZoomLevel = (function() {
            // Load persisted zoom level from localStorage, default to 500
            try {
                const saved = localStorage.getItem('shipyardZoomLevel');
                if (saved) {
                    const val = parseInt(saved);
                    if (val >= 50 && val <= 1000) return val;
                }
            } catch (e) {}
            return 500;
        })();

        // Mapping from game ship types to GLB model files
        const SHIP_MODELS = {
            // Player ship
            player: 'UE Fighter.glb',

            // UE/Human ships (United Earth, Terran Confederacy, etc)
            ue_fighter: 'UE Fighter.glb',
            ue_freighter: 'UE Freighter.glb',
            ue_carrier: 'UE Carrier.glb',
            human_fighter: 'UE Fighter.glb',
            human_heavy: 'UE Freighter.glb',
            human_capital: 'UE Carrier.glb',

            // Voinian ships
            voinian_fighter: 'Voinian Heavy Fighter.glb',
            voinian_heavy: 'Voinian Cruiser.glb',
            voinian_capital: 'Voinian Dreadnaught.glb',
            voinian_frigate: 'Voinian Frigate.glb',

            // Crescent ships (Azdgari, Zidagar, Igadzra strands)
            crescent_fighter: 'Crescent Fighter.glb',
            crescent_heavy: 'Crescent Warship.glb',
            crescent_capital: 'Azdgari Warship.glb',
            azdgari_fighter: 'Azdara.glb',
            azdgari_heavy: 'Azdgari Arada.glb',
            azdgari_capital: 'Azdgari Warship.glb',
            igadzra_fighter: 'Igadzra Arada.glb',
            igadzra_heavy: 'Igazra.glb',
            zidagar_fighter: 'Lazira.glb',

            // Miranu ships
            miranu_fighter: 'Miranu Courier.glb',
            miranu_heavy: 'Miranu Gunship.glb',
            miranu_capital: 'Miranu Freighter II.glb',
            miranu_freighter: 'Miranu Freighter.glb',

            // Emalgha ships
            emalgha_fighter: 'Emalgha Fighter.glb',
            emalgha_heavy: 'Emalgha Freighter.glb',
            emalgha_capital: 'Emalgha Freighter.glb',

            // Generic/Pirate ships
            pirate_fighter: 'Krait.glb',
            pirate_heavy: 'Turncoat.glb',
            pirate_capital: 'Helian.glb',

            // Cargo/Freighters
            freighter: 'Cargo Freighter.glb',
            freight_courier: 'Freight Courier.glb',

            // Small ships
            shuttle: 'Shuttle.glb',
            scoutship: 'Scoutship.glb',
            escape_pod: 'Escape Pod.glb',

            // Special Arada variants
            arada: 'Arada.glb',
        };

        // Faction-specific colors and material properties for ships
        const SHIP_FACTION_COLORS = {
            // === UNITED EARTH / HUMAN ===
            'UE Fighter.glb':           { faction: 'ue', primary: 0xd1d5db, accent: 0x3b82f6, engine: 0x00ffff, metalness: 0.8, roughness: 0.3 },
            'UE Freighter.glb':         { faction: 'ue', primary: 0xd1d5db, accent: 0x3b82f6, engine: 0x00ffff, metalness: 0.7, roughness: 0.4 },
            'UE Carrier.glb':           { faction: 'ue', primary: 0xd1d5db, accent: 0x3b82f6, engine: 0x00ffff, metalness: 0.75, roughness: 0.35 },
            'Scoutship.glb':            { faction: 'ue', primary: 0xe5e7eb, accent: 0x60a5fa, engine: 0x38bdf8, metalness: 0.7, roughness: 0.4 },
            'Shuttle.glb':              { faction: 'ue', primary: 0xf3f4f6, accent: 0x94a3b8, engine: 0x60a5fa, metalness: 0.6, roughness: 0.5 },
            'Escape Pod.glb':           { faction: 'ue', primary: 0xffffff, accent: 0xef4444, engine: 0xfca5a5, metalness: 0.5, roughness: 0.6 },

            // === VOINIAN ===
            'Voinian Heavy Fighter.glb': { faction: 'voinian', primary: 0x78350f, accent: 0xd97706, engine: 0xf59e0b, metalness: 0.6, roughness: 0.6 },
            'Voinian Frigate.glb':       { faction: 'voinian', primary: 0x7c2d12, accent: 0xea580c, engine: 0xfb923c, metalness: 0.55, roughness: 0.65 },
            'Voinian Cruiser.glb':       { faction: 'voinian', primary: 0x713f12, accent: 0xca8a04, engine: 0xfacc15, metalness: 0.5, roughness: 0.7 },
            'Voinian Dreadnaught.glb':   { faction: 'voinian', primary: 0x451a03, accent: 0xb45309, engine: 0xf59e0b, metalness: 0.5, roughness: 0.7 },

            // === CRESCENT (Base) ===
            'Crescent Fighter.glb':      { faction: 'crescent', primary: 0x6b21a8, accent: 0xc084fc, engine: 0xe879f9, metalness: 0.85, roughness: 0.2 },
            'Crescent Warship.glb':      { faction: 'crescent', primary: 0x581c87, accent: 0xa855f7, engine: 0xd946ef, metalness: 0.85, roughness: 0.25 },

            // === AZDGARI (Green) ===
            'Azdara.glb':                { faction: 'azdgari', primary: 0x166534, accent: 0x22c55e, engine: 0x4ade80, metalness: 0.8, roughness: 0.25 },
            'Azdgari Arada.glb':         { faction: 'azdgari', primary: 0x15803d, accent: 0x34d399, engine: 0x6ee7b7, metalness: 0.8, roughness: 0.25 },
            'Azdgari Warship.glb':       { faction: 'azdgari', primary: 0x14532d, accent: 0x10b981, engine: 0x34d399, metalness: 0.8, roughness: 0.3 },

            // === IGADZRA (Yellow/Orange) ===
            'Igadzra Arada.glb':         { faction: 'igadzra', primary: 0xb45309, accent: 0xfbbf24, engine: 0xfde047, metalness: 0.8, roughness: 0.25 },
            'Igazra.glb':                { faction: 'igadzra', primary: 0x92400e, accent: 0xf59e0b, engine: 0xfcd34d, metalness: 0.8, roughness: 0.3 },

            // === ZIDAGAR (Purple) ===
            'Lazira.glb':                { faction: 'zidagar', primary: 0x6b21a8, accent: 0xa855f7, engine: 0xc084fc, metalness: 0.85, roughness: 0.2 },

            // === MIRANU (Gold) ===
            'Miranu Courier.glb':        { faction: 'miranu', primary: 0xb45309, accent: 0xfcd34d, engine: 0xfef08a, metalness: 0.75, roughness: 0.35 },
            'Miranu Freighter.glb':      { faction: 'miranu', primary: 0xa16207, accent: 0xfbbf24, engine: 0xfde68a, metalness: 0.7, roughness: 0.4 },
            'Miranu Freighter II.glb':   { faction: 'miranu', primary: 0x854d0e, accent: 0xeab308, engine: 0xfacc15, metalness: 0.7, roughness: 0.4 },
            'Miranu Gunship.glb':        { faction: 'miranu', primary: 0x92400e, accent: 0xf59e0b, engine: 0xfbbf24, metalness: 0.75, roughness: 0.35 },

            // === EMALGHA (Organic Green) ===
            'Emalgha Fighter.glb':       { faction: 'emalgha', primary: 0x365314, accent: 0x84cc16, engine: 0xa3e635, metalness: 0.4, roughness: 0.7 },
            'Emalgha Freighter.glb':     { faction: 'emalgha', primary: 0x3f6212, accent: 0x65a30d, engine: 0x84cc16, metalness: 0.35, roughness: 0.75 },

            // === GENERIC/PIRATE ===
            'Krait.glb':                 { faction: 'pirate', primary: 0x374151, accent: 0xf97316, engine: 0xfb923c, metalness: 0.6, roughness: 0.5 },
            'Turncoat.glb':              { faction: 'pirate', primary: 0x4b5563, accent: 0xef4444, engine: 0xf87171, metalness: 0.55, roughness: 0.55 },
            'Helian.glb':                { faction: 'pirate', primary: 0x52525b, accent: 0xeab308, engine: 0xfde047, metalness: 0.6, roughness: 0.5 },
            'Cargo Freighter.glb':       { faction: 'neutral', primary: 0x6b7280, accent: 0x9ca3af, engine: 0x60a5fa, metalness: 0.5, roughness: 0.6 },
            'Freight Courier.glb':       { faction: 'neutral', primary: 0x71717a, accent: 0xa1a1aa, engine: 0x38bdf8, metalness: 0.55, roughness: 0.55 },
            'Arada.glb':                 { faction: 'neutral', primary: 0x78716c, accent: 0xa8a29e, engine: 0x22d3ee, metalness: 0.65, roughness: 0.45 },
        };

        // Texture URLs from Endless Sky for ships that have them
        const SHIP_TEXTURES = {
            'Scoutship.glb': 'https://raw.githubusercontent.com/endless-sky/endless-sky/master/images/thumbnail/scout.png',
            'Shuttle.glb': 'https://raw.githubusercontent.com/endless-sky/endless-sky/master/images/thumbnail/shuttle.png',
            'UE Fighter.glb': 'https://raw.githubusercontent.com/endless-sky/endless-sky/master/images/thumbnail/fighter.png',
            'Voinian Heavy Fighter.glb': 'https://raw.githubusercontent.com/endless-sky/endless-sky/master/images/thumbnail/heavy%20fighter.png',
            'Crescent Fighter.glb': 'https://raw.githubusercontent.com/endless-sky/endless-sky/master/images/thumbnail/crescent.png',
            'Escape Pod.glb': 'https://raw.githubusercontent.com/endless-sky/endless-sky/master/images/thumbnail/escape%20pod.png',
            'UE Freighter.glb': 'https://raw.githubusercontent.com/endless-sky/endless-sky/master/images/thumbnail/freighter.png',
            'Voinian Frigate.glb': 'https://raw.githubusercontent.com/endless-sky/endless-sky/master/images/thumbnail/frigate.png',
            'Voinian Cruiser.glb': 'https://raw.githubusercontent.com/endless-sky/endless-sky/master/images/thumbnail/cruiser.png',
        };

        // Texture loader for ship textures
        const textureLoader = new THREE.TextureLoader();

        // Cache for loaded textures
        const textureCache = new Map();

        // Apply loaded texture to ship model
        function applyTextureToModel(model, texture, colorData) {
            model.traverse((child) => {
                if (child.isMesh && child.material) {
                    const meshName = (child.name || '').toLowerCase();
                    const matName = (child.material.name || '').toLowerCase();

                    // Check for engine/thruster parts - keep procedural for these
                    const isEngine = meshName.includes('engine') || meshName.includes('thrust') ||
                                    meshName.includes('exhaust') || meshName.includes('glow') ||
                                    matName.includes('engine') || matName.includes('thrust') ||
                                    matName.includes('emit') || matName.includes('glow');

                    if (isEngine) {
                        // Engine glow - use emissive material without texture
                        const engineMaterial = new THREE.MeshStandardMaterial({
                            color: colorData.engine,
                            emissive: colorData.engine,
                            emissiveIntensity: 0.5,
                            metalness: 0.2,
                            roughness: 0.8,
                            side: THREE.DoubleSide
                        });
                        child.material = engineMaterial;
                    } else {
                        // Apply texture to hull
                        const texturedMaterial = new THREE.MeshStandardMaterial({
                            map: texture,
                            metalness: colorData.metalness,
                            roughness: colorData.roughness,
                            flatShading: false,
                            side: THREE.DoubleSide
                        });

                        // Copy normal map if present
                        if (child.material.normalMap) {
                            texturedMaterial.normalMap = child.material.normalMap;
                        }

                        child.material = texturedMaterial;
                    }
                }
            });
        }

        // Apply procedural colors to ship model (fallback for ships without textures)
        function applyProceduralMaterials(model, modelName, colorData) {
            let meshIndex = 0;
            const totalMeshes = [];

            // First pass: count meshes
            model.traverse((child) => {
                if (child.isMesh) totalMeshes.push(child);
            });

            const meshCount = totalMeshes.length;

            // Second pass: apply materials with variation
            model.traverse((child) => {
                if (child.isMesh && child.material) {
                    // Create a proper MeshStandardMaterial
                    const newMaterial = new THREE.MeshStandardMaterial({
                        metalness: colorData.metalness,
                        roughness: colorData.roughness,
                        flatShading: false,
                        side: THREE.DoubleSide
                    });

                    // Determine which color to use based on mesh characteristics
                    const meshName = (child.name || '').toLowerCase();
                    const matName = (child.material.name || '').toLowerCase();

                    // Check for engine/thruster parts
                    const isEngine = meshName.includes('engine') || meshName.includes('thrust') ||
                                    meshName.includes('exhaust') || meshName.includes('glow') ||
                                    matName.includes('engine') || matName.includes('thrust') ||
                                    matName.includes('emit') || matName.includes('glow');

                    // Check for accent/detail parts
                    const isAccent = meshName.includes('detail') || meshName.includes('trim') ||
                                    meshName.includes('stripe') || meshName.includes('wing') ||
                                    meshName.includes('panel') || meshName.includes('cockpit') ||
                                    matName.includes('accent') || matName.includes('secondary');

                    if (isEngine) {
                        // Engine glow - use emissive material
                        newMaterial.color.setHex(colorData.engine);
                        newMaterial.emissive.setHex(colorData.engine);
                        newMaterial.emissiveIntensity = 0.5;
                        newMaterial.metalness = 0.2;
                        newMaterial.roughness = 0.8;
                    } else if (isAccent) {
                        // Accent/detail parts
                        newMaterial.color.setHex(colorData.accent);
                        newMaterial.metalness = Math.min(colorData.metalness + 0.1, 1.0);
                        newMaterial.roughness = Math.max(colorData.roughness - 0.1, 0.0);
                    } else {
                        // Primary hull - distribute colors based on mesh index for visual interest
                        // Small meshes (possibly details) get accent color
                        if (meshCount > 1) {
                            // For multi-mesh models, alternate between primary and accent
                            // First few meshes get primary, later ones get accent
                            const isPrimaryMesh = meshIndex < Math.ceil(meshCount * 0.7);
                            if (isPrimaryMesh) {
                                newMaterial.color.setHex(colorData.primary);
                            } else {
                                newMaterial.color.setHex(colorData.accent);
                                newMaterial.metalness = Math.min(colorData.metalness + 0.05, 1.0);
                            }
                        } else {
                            // Single mesh model - use primary
                            newMaterial.color.setHex(colorData.primary);
                        }
                    }

                    // Copy any existing texture maps if present
                    if (child.material.map) {
                        newMaterial.map = child.material.map;
                    }
                    if (child.material.normalMap) {
                        newMaterial.normalMap = child.material.normalMap;
                    }

                    child.material = newMaterial;
                    meshIndex++;
                }
            });
        }

        // Apply faction-appropriate materials to a ship model
        function applyShipMaterials(model, modelName) {
            const colorData = SHIP_FACTION_COLORS[modelName];
            if (!colorData) return;

            // Check if this ship has a texture available
            const textureUrl = SHIP_TEXTURES[modelName];

            // If texture is available, load it and apply to the model
            if (textureUrl) {
                // Check cache first
                if (textureCache.has(modelName)) {
                    applyTextureToModel(model, textureCache.get(modelName), colorData);
                } else {
                    // BUG FIX: Apply procedural materials IMMEDIATELY as fallback
                    // This prevents the model from appearing white/blank while texture loads
                    applyProceduralMaterials(model, modelName, colorData);

                    // Load texture asynchronously, will replace procedural colors when ready
                    textureLoader.load(
                        textureUrl,
                        (texture) => {
                            // Configure texture
                            texture.flipY = false;
                            texture.colorSpace = THREE.SRGBColorSpace;
                            textureCache.set(modelName, texture);
                            applyTextureToModel(model, texture, colorData);
                        },
                        undefined,
                        (error) => {
                            console.warn(`Failed to load texture for ${modelName}:`, error);
                            // Procedural colors already applied, no action needed
                        }
                    );
                }
                return;
            }

            // No texture available, use procedural colors
            applyProceduralMaterials(model, modelName, colorData);
        }

        // Faction to model type mapping
        const FACTION_SHIP_MAPPING = {
            // Human factions use UE ships
            terranConfederacy: { fighter: 'human_fighter', heavy: 'human_heavy', boss: 'human_capital' },
            unitedEarth: { fighter: 'ue_fighter', heavy: 'ue_freighter', boss: 'ue_carrier' },
            secondRebellion: { fighter: 'human_fighter', heavy: 'human_heavy', boss: 'human_capital' },
            cau: { fighter: 'human_fighter', heavy: 'human_heavy', boss: 'human_capital' },
            bhu: { fighter: 'human_fighter', heavy: 'human_heavy', boss: 'human_capital' },
            galacticPolice: { fighter: 'human_fighter', heavy: 'human_heavy', boss: 'human_capital' },
            freeCompanies: { fighter: 'freighter', heavy: 'freight_courier', boss: 'ue_carrier' },
            helionova: { fighter: 'scoutship', heavy: 'shuttle', boss: 'human_capital' },
            seti: { fighter: 'scoutship', heavy: 'human_heavy', boss: 'human_capital' },

            // Voinian faction
            voinian: { fighter: 'voinian_fighter', heavy: 'voinian_heavy', boss: 'voinian_capital' },
            emalgha: { fighter: 'emalgha_fighter', heavy: 'emalgha_heavy', boss: 'emalgha_capital' },
            hinwar: { fighter: 'shuttle', heavy: 'miranu_fighter', boss: 'miranu_heavy' },

            // Crescent factions
            gadzair: { fighter: 'azdgari_fighter', heavy: 'azdgari_heavy', boss: 'azdgari_capital' },
            simnuvia: { fighter: 'crescent_fighter', heavy: 'crescent_heavy', boss: 'crescent_capital' },
            kliaphin: { fighter: 'igadzra_fighter', heavy: 'igadzra_heavy', boss: 'crescent_capital' },
            miranu: { fighter: 'miranu_fighter', heavy: 'miranu_heavy', boss: 'miranu_capital' },
            talramuv: { fighter: 'zidagar_fighter', heavy: 'crescent_heavy', boss: 'crescent_capital' },

            // Katuri (hostile aliens - use aggressive Voinian style)
            katuri: { fighter: 'voinian_fighter', heavy: 'voinian_heavy', boss: 'voinian_capital' },
            theAliens: { fighter: 'azdgari_fighter', heavy: 'igadzra_heavy', boss: 'azdgari_capital' },

            // Pirates and renegades
            pirates: { fighter: 'pirate_fighter', heavy: 'pirate_heavy', boss: 'pirate_capital' },
            renegades: { fighter: 'pirate_fighter', heavy: 'pirate_heavy', boss: 'pirate_capital' },
        };

        // Load a single GLB model
        async function loadGLBModel(modelName) {
            if (modelCache.has(modelName)) {
                return modelCache.get(modelName);
            }

            return new Promise((resolve, reject) => {
                const url = MODEL_PATH + modelName;
                console.log(`Loading model from: ${url}`);

                gltfLoader.load(
                    url,
                    (gltf) => {
                        const model = gltf.scene;

                        // Log model structure for debugging
                        console.log(`Model ${modelName} structure:`, model);

                        // Center the model and normalize scale
                        const box = new THREE.Box3().setFromObject(model);
                        const center = box.getCenter(new THREE.Vector3());
                        const size = box.getSize(new THREE.Vector3());
                        const maxDim = Math.max(size.x, size.y, size.z);

                        console.log(`Model ${modelName} dimensions:`, size, 'max:', maxDim);

                        // Normalize to ~60 units (reasonable ship size)
                        const targetSize = 60;
                        const scale = targetSize / maxDim;
                        model.scale.set(scale, scale, scale);

                        // Center the model
                        model.position.sub(center.multiplyScalar(scale));

                        // Ensure materials are properly visible
                        model.traverse((child) => {
                            if (child.isMesh) {
                                // Make sure materials render both sides and are visible
                                if (child.material) {
                                    child.material.side = THREE.DoubleSide;
                                    child.material.needsUpdate = true;
                                    // Ensure emissive properties don't wash out colors
                                    if (child.material.emissive) {
                                        child.material.emissiveIntensity = 0.1;
                                    }
                                }
                                child.castShadow = true;
                                child.receiveShadow = true;
                            }
                        });

                        // Store in cache
                        modelCache.set(modelName, model);
                        console.log(`Successfully loaded model: ${modelName}`);
                        resolve(model);
                    },
                    (progress) => {
                        // Progress callback
                        if (progress.total > 0) {
                            const percent = (progress.loaded / progress.total * 100).toFixed(1);
                            console.log(`Loading ${modelName}: ${percent}%`);
                        }
                    },
                    (error) => {
                        console.error(`Failed to load model ${modelName}:`, error);
                        console.error(`URL attempted: ${url}`);
                        resolve(null); // Return null on error, fallback to procedural
                    }
                );
            });
        }

        // Clone a cached model for use
        function cloneModel(modelName) {
            const cached = modelCache.get(modelName);
            if (!cached) return null;

            const clone = cached.clone();
            // Deep clone materials to allow independent coloring
            clone.traverse((child) => {
                if (child.isMesh && child.material) {
                    child.material = child.material.clone();
                }
            });
            return clone;
        }

        // Preload essential models
        async function preloadModels() {
            console.log('Preloading GLB ship models...');
            // Load all available models for shipyard
            const modelsToLoad = [
                // Fighters
                'UE Fighter.glb',
                'Scoutship.glb',
                'Shuttle.glb',
                'Voinian Heavy Fighter.glb',
                'Crescent Fighter.glb',
                'Azdara.glb',
                'Krait.glb',
                'Emalgha Fighter.glb',
                'Miranu Courier.glb',
                'Escape Pod.glb',
                // Medium ships
                'Arada.glb',
                'Turncoat.glb',
                'Azdgari Arada.glb',
                'Igadzra Arada.glb',
                'Lazira.glb',
                'Helian.glb',
                // Heavy ships
                'UE Freighter.glb',
                'Voinian Frigate.glb',
                'Voinian Cruiser.glb',
                'Miranu Freighter.glb',
                'Miranu Freighter II.glb',
                'Miranu Gunship.glb',
                'Emalgha Freighter.glb',
                'Cargo Freighter.glb',
                'Freight Courier.glb',
                'Azdgari Warship.glb',
                'Crescent Warship.glb',
                // Capital ships
                'Igazra.glb',
                'UE Carrier.glb',
                'Voinian Dreadnaught.glb',
            ];

            let loaded = 0;
            for (const model of modelsToLoad) {
                await loadGLBModel(model);
                loaded++;
                modelLoadProgress = (loaded / modelsToLoad.length) * 100;
            }

            modelsLoaded = true;
            console.log(`Preloaded ${loaded} models`);
        }

        // Get model name for faction and ship type
        function getModelForFaction(faction, shipType) {
            const mapping = FACTION_SHIP_MAPPING[faction] || FACTION_SHIP_MAPPING.pirates;
            const modelKey = mapping[shipType] || mapping.fighter;
            return SHIP_MODELS[modelKey] || SHIP_MODELS.pirate_fighter;
        }

        // Mouse state
        let mouseX = 0, mouseY = 0;
        let mouseWorldX = 0, mouseWorldY = 0;

        // Player state
        let playerState = {
            x: 0, y: 0,
            vx: 0, vy: 0,
            rotation: -Math.PI / 2,
            hull: 100, maxHull: 100,
            shields: 50, maxShields: 50,
            energy: 100, maxEnergy: 100,
            credits: 0,
            kills: 0,
            missiles: 5,
            maxMissiles: 5,
            sectorsCleared: 0,
            currentSector: { x: 0, y: 0 },
            shipLevel: 1,
            lockedTarget: null,
            upgrades: {
                hull: 0,
                shields: 0,
                energy: 0,
                thrust: 0,
                primaryDamage: 0,
                turretDamage: 0,
                missileDamage: 0,
                shieldRegen: 0
            }
        };

        const BASE_STATS = {
            thrust: 250,
            maxSpeed: 350,
            rotationSpeed: 2.5,
            primaryFireRate: 0.15,
            primaryDamage: 15,
            turretFireRate: 0.25,
            turretDamage: 12,
            missileDamage: 80,
            shieldRegen: 3
        };

        function getStats() {
            const rapidBonus = (playerState.upgrades.rapidFire || 0) * 0.02;
            const homingBonus = (playerState.upgrades.homingStrength || 0) * 20;
            return {
                thrust: BASE_STATS.thrust + (playerState.upgrades.thrust || 0) * 40,
                maxSpeed: BASE_STATS.maxSpeed + (playerState.upgrades.thrust || 0) * 30,
                rotationSpeed: BASE_STATS.rotationSpeed,
                primaryFireRate: Math.max(0.06, BASE_STATS.primaryFireRate - (playerState.upgrades.primaryDamage || 0) * 0.01 - rapidBonus),
                primaryDamage: BASE_STATS.primaryDamage + (playerState.upgrades.primaryDamage || 0) * 5,
                turretFireRate: Math.max(0.10, BASE_STATS.turretFireRate - (playerState.upgrades.turretDamage || 0) * 0.015 - rapidBonus),
                turretDamage: BASE_STATS.turretDamage + (playerState.upgrades.turretDamage || 0) * 4,
                missileDamage: BASE_STATS.missileDamage + (playerState.upgrades.missileDamage || 0) * 25 + homingBonus,
                shieldRegen: BASE_STATS.shieldRegen + (playerState.upgrades.shieldRegen || 0) * 1.5
            };
        }

        const keys = {};
        let lastPrimaryFire = 0;
        let lastTurretFire = 0;
        let minimapCtx;

        // ============================================================
        // EV:O STYLE UI SYSTEM - TARGET PANEL AND COMM SYSTEM
        // ============================================================

        let currentTarget = null;
        let targetFrontCtx = null;
        let targetSideCtx = null;
        let commPortraitCtx = null;

        // Initialize EV-style canvases
        function initEVCanvases() {
            const frontCanvas = document.getElementById('targetViewFront');
            const sideCanvas = document.getElementById('targetViewSide');
            const portraitCanvas = document.getElementById('commPortrait');

            if (frontCanvas) targetFrontCtx = frontCanvas.getContext('2d');
            if (sideCanvas) targetSideCtx = sideCanvas.getContext('2d');
            if (portraitCanvas) commPortraitCtx = portraitCanvas.getContext('2d');
        }

        // Draw EV-style wireframe ship silhouette
        function drawWireframeShip(ctx, shipType, view, factionColor = '#00ff00') {
            const w = ctx.canvas.width;
            const h = ctx.canvas.height;
            const cx = w / 2;
            const cy = h / 2;

            // Clear with dark green background
            ctx.fillStyle = '#000800';
            ctx.fillRect(0, 0, w, h);

            // Draw scan lines effect
            ctx.strokeStyle = '#001800';
            ctx.lineWidth = 1;
            for (let y = 0; y < h; y += 4) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(w, y);
                ctx.stroke();
            }

            // Set wireframe style
            ctx.strokeStyle = '#00ff00';
            ctx.lineWidth = 1.5;
            ctx.shadowColor = '#00ff00';
            ctx.shadowBlur = 3;

            // Draw ship based on type and view
            if (view === 'front') {
                drawShipFront(ctx, shipType, cx, cy);
            } else {
                drawShipSide(ctx, shipType, cx, cy);
            }

            // Draw targeting reticle corners
            ctx.strokeStyle = '#008800';
            ctx.lineWidth = 1;
            ctx.shadowBlur = 0;
            const cornerSize = 8;

            // Top-left
            ctx.beginPath();
            ctx.moveTo(5, 5 + cornerSize);
            ctx.lineTo(5, 5);
            ctx.lineTo(5 + cornerSize, 5);
            ctx.stroke();

            // Top-right
            ctx.beginPath();
            ctx.moveTo(w - 5 - cornerSize, 5);
            ctx.lineTo(w - 5, 5);
            ctx.lineTo(w - 5, 5 + cornerSize);
            ctx.stroke();

            // Bottom-left
            ctx.beginPath();
            ctx.moveTo(5, h - 5 - cornerSize);
            ctx.lineTo(5, h - 5);
            ctx.lineTo(5 + cornerSize, h - 5);
            ctx.stroke();

            // Bottom-right
            ctx.beginPath();
            ctx.moveTo(w - 5 - cornerSize, h - 5);
            ctx.lineTo(w - 5, h - 5);
            ctx.lineTo(w - 5, h - 5 - cornerSize);
            ctx.stroke();
        }

        // Draw front view of ship wireframe
        function drawShipFront(ctx, shipType, cx, cy) {
            ctx.beginPath();

            if (shipType === 'fighter') {
                // Fighter - compact, angular
                ctx.moveTo(cx, cy - 25);  // Nose
                ctx.lineTo(cx + 20, cy + 5);  // Right wing
                ctx.lineTo(cx + 30, cy + 15);  // Right wing tip
                ctx.lineTo(cx + 15, cy + 10);  // Right wing inner
                ctx.lineTo(cx + 10, cy + 20);  // Right tail
                ctx.lineTo(cx, cy + 15);  // Center tail
                ctx.lineTo(cx - 10, cy + 20);  // Left tail
                ctx.lineTo(cx - 15, cy + 10);  // Left wing inner
                ctx.lineTo(cx - 30, cy + 15);  // Left wing tip
                ctx.lineTo(cx - 20, cy + 5);  // Left wing
                ctx.closePath();
                ctx.stroke();

                // Cockpit
                ctx.beginPath();
                ctx.arc(cx, cy - 10, 6, 0, Math.PI * 2);
                ctx.stroke();

            } else if (shipType === 'heavy') {
                // Heavy - bulkier, more armored look
                ctx.moveTo(cx, cy - 30);  // Nose
                ctx.lineTo(cx + 15, cy - 20);
                ctx.lineTo(cx + 25, cy - 5);
                ctx.lineTo(cx + 35, cy + 5);  // Right wing
                ctx.lineTo(cx + 25, cy + 15);
                ctx.lineTo(cx + 15, cy + 25);
                ctx.lineTo(cx, cy + 20);
                ctx.lineTo(cx - 15, cy + 25);
                ctx.lineTo(cx - 25, cy + 15);
                ctx.lineTo(cx - 35, cy + 5);  // Left wing
                ctx.lineTo(cx - 25, cy - 5);
                ctx.lineTo(cx - 15, cy - 20);
                ctx.closePath();
                ctx.stroke();

                // Bridge
                ctx.beginPath();
                ctx.rect(cx - 8, cy - 15, 16, 12);
                ctx.stroke();

                // Engine pods
                ctx.beginPath();
                ctx.rect(cx + 15, cy + 5, 8, 12);
                ctx.rect(cx - 23, cy + 5, 8, 12);
                ctx.stroke();

            } else {
                // Boss - massive, imposing
                ctx.moveTo(cx, cy - 35);  // Nose
                ctx.lineTo(cx + 20, cy - 25);
                ctx.lineTo(cx + 35, cy - 10);
                ctx.lineTo(cx + 45, cy + 10);  // Right wing
                ctx.lineTo(cx + 35, cy + 25);
                ctx.lineTo(cx + 20, cy + 30);
                ctx.lineTo(cx, cy + 25);
                ctx.lineTo(cx - 20, cy + 30);
                ctx.lineTo(cx - 35, cy + 25);
                ctx.lineTo(cx - 45, cy + 10);  // Left wing
                ctx.lineTo(cx - 35, cy - 10);
                ctx.lineTo(cx - 20, cy - 25);
                ctx.closePath();
                ctx.stroke();

                // Command tower
                ctx.beginPath();
                ctx.rect(cx - 10, cy - 20, 20, 15);
                ctx.stroke();

                // Weapon batteries
                ctx.beginPath();
                ctx.arc(cx + 25, cy, 5, 0, Math.PI * 2);
                ctx.arc(cx - 25, cy, 5, 0, Math.PI * 2);
                ctx.stroke();

                // Engine array
                ctx.beginPath();
                ctx.rect(cx - 15, cy + 15, 30, 8);
                ctx.stroke();
            }
        }

        // Draw side view of ship wireframe
        function drawShipSide(ctx, shipType, cx, cy) {
            ctx.beginPath();

            if (shipType === 'fighter') {
                // Fighter side view
                ctx.moveTo(cx - 30, cy);  // Nose
                ctx.lineTo(cx - 15, cy - 8);
                ctx.lineTo(cx + 5, cy - 10);  // Cockpit top
                ctx.lineTo(cx + 20, cy - 5);
                ctx.lineTo(cx + 25, cy);  // Tail
                ctx.lineTo(cx + 30, cy + 5);  // Engine
                ctx.lineTo(cx + 20, cy + 8);
                ctx.lineTo(cx - 5, cy + 8);
                ctx.lineTo(cx - 20, cy + 3);
                ctx.closePath();
                ctx.stroke();

                // Cockpit canopy
                ctx.beginPath();
                ctx.ellipse(cx - 5, cy - 3, 10, 5, 0, Math.PI, 0);
                ctx.stroke();

                // Engine glow
                ctx.beginPath();
                ctx.moveTo(cx + 28, cy - 3);
                ctx.lineTo(cx + 35, cy);
                ctx.lineTo(cx + 28, cy + 3);
                ctx.stroke();

            } else if (shipType === 'heavy') {
                // Heavy side view
                ctx.moveTo(cx - 35, cy);  // Nose
                ctx.lineTo(cx - 25, cy - 12);
                ctx.lineTo(cx - 10, cy - 15);
                ctx.lineTo(cx + 10, cy - 18);  // Bridge
                ctx.lineTo(cx + 20, cy - 12);
                ctx.lineTo(cx + 30, cy - 8);
                ctx.lineTo(cx + 35, cy);  // Tail
                ctx.lineTo(cx + 30, cy + 10);
                ctx.lineTo(cx + 10, cy + 12);
                ctx.lineTo(cx - 20, cy + 10);
                ctx.lineTo(cx - 30, cy + 5);
                ctx.closePath();
                ctx.stroke();

                // Bridge structure
                ctx.beginPath();
                ctx.rect(cx - 5, cy - 18, 15, 8);
                ctx.stroke();

                // Engine pods
                ctx.beginPath();
                ctx.moveTo(cx + 33, cy - 5);
                ctx.lineTo(cx + 40, cy);
                ctx.lineTo(cx + 33, cy + 5);
                ctx.stroke();

            } else {
                // Boss side view
                ctx.moveTo(cx - 45, cy);  // Nose
                ctx.lineTo(cx - 35, cy - 15);
                ctx.lineTo(cx - 15, cy - 20);
                ctx.lineTo(cx + 5, cy - 25);  // Bridge tower
                ctx.lineTo(cx + 15, cy - 20);
                ctx.lineTo(cx + 30, cy - 15);
                ctx.lineTo(cx + 40, cy - 8);
                ctx.lineTo(cx + 45, cy);  // Tail
                ctx.lineTo(cx + 40, cy + 12);
                ctx.lineTo(cx + 20, cy + 18);
                ctx.lineTo(cx - 10, cy + 15);
                ctx.lineTo(cx - 35, cy + 10);
                ctx.closePath();
                ctx.stroke();

                // Command tower
                ctx.beginPath();
                ctx.rect(cx - 5, cy - 25, 12, 10);
                ctx.stroke();

                // Weapon turrets
                ctx.beginPath();
                ctx.arc(cx - 20, cy - 12, 4, 0, Math.PI * 2);
                ctx.arc(cx + 25, cy - 10, 4, 0, Math.PI * 2);
                ctx.stroke();

                // Multiple engines
                ctx.beginPath();
                ctx.moveTo(cx + 43, cy - 5);
                ctx.lineTo(cx + 50, cy);
                ctx.lineTo(cx + 43, cy + 5);
                ctx.moveTo(cx + 38, cy + 8);
                ctx.lineTo(cx + 45, cy + 10);
                ctx.lineTo(cx + 38, cy + 12);
                ctx.stroke();
            }
        }

        // Draw wireframe portrait for comm panel
        function drawCommPortrait(ctx, factionId) {
            const w = ctx.canvas.width;
            const h = ctx.canvas.height;
            const cx = w / 2;
            const cy = h / 2;

            // Clear with dark green
            ctx.fillStyle = '#000800';
            ctx.fillRect(0, 0, w, h);

            // Scan lines
            ctx.strokeStyle = '#001800';
            ctx.lineWidth = 1;
            for (let y = 0; y < h; y += 3) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(w, y);
                ctx.stroke();
            }

            // Get faction color or default green
            const faction = FACTIONS[factionId];
            const color = faction ? faction.color : '#00ff00';

            ctx.strokeStyle = '#00ff00';
            ctx.lineWidth = 1.5;
            ctx.shadowColor = '#00ff00';
            ctx.shadowBlur = 4;

            // Draw a stylized faction emblem/face
            // Outer frame
            ctx.beginPath();
            ctx.arc(cx, cy, 35, 0, Math.PI * 2);
            ctx.stroke();

            // Inner details vary by faction type
            if (factionId === 'pirates' || factionId === 'renegades') {
                // Skull-like emblem
                ctx.beginPath();
                ctx.arc(cx - 10, cy - 8, 8, 0, Math.PI * 2);
                ctx.arc(cx + 10, cy - 8, 8, 0, Math.PI * 2);
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(cx - 5, cy + 5);
                ctx.lineTo(cx, cy + 15);
                ctx.lineTo(cx + 5, cy + 5);
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(cx - 15, cy + 20);
                ctx.lineTo(cx + 15, cy + 20);
                ctx.stroke();
            } else if (factionId === 'katuri' || factionId === 'voinian') {
                // Alien emblem - angular
                ctx.beginPath();
                ctx.moveTo(cx, cy - 25);
                ctx.lineTo(cx + 20, cy);
                ctx.lineTo(cx + 10, cy + 20);
                ctx.lineTo(cx - 10, cy + 20);
                ctx.lineTo(cx - 20, cy);
                ctx.closePath();
                ctx.stroke();

                ctx.beginPath();
                ctx.arc(cx - 8, cy - 5, 5, 0, Math.PI * 2);
                ctx.arc(cx + 8, cy - 5, 5, 0, Math.PI * 2);
                ctx.stroke();
            } else {
                // Human faction - helmet/visor style
                ctx.beginPath();
                ctx.ellipse(cx, cy - 5, 20, 25, 0, 0, Math.PI * 2);
                ctx.stroke();

                // Visor
                ctx.beginPath();
                ctx.rect(cx - 18, cy - 10, 36, 12);
                ctx.stroke();

                // Chin piece
                ctx.beginPath();
                ctx.moveTo(cx - 12, cy + 10);
                ctx.lineTo(cx, cy + 20);
                ctx.lineTo(cx + 12, cy + 10);
                ctx.stroke();
            }

            // Corner brackets
            ctx.strokeStyle = '#006600';
            ctx.shadowBlur = 0;
            const cs = 10;
            ctx.beginPath();
            ctx.moveTo(5, cs + 5);
            ctx.lineTo(5, 5);
            ctx.lineTo(cs + 5, 5);
            ctx.moveTo(w - cs - 5, 5);
            ctx.lineTo(w - 5, 5);
            ctx.lineTo(w - 5, cs + 5);
            ctx.moveTo(5, h - cs - 5);
            ctx.lineTo(5, h - 5);
            ctx.lineTo(cs + 5, h - 5);
            ctx.moveTo(w - cs - 5, h - 5);
            ctx.lineTo(w - 5, h - 5);
            ctx.lineTo(w - 5, h - cs - 5);
            ctx.stroke();
        }

        // Set target and update panel
        function setEVTarget(enemy) {
            if (!enemy || enemy.health <= 0) {
                currentTarget = null;
                document.getElementById('evTargetPanel').style.display = 'none';
                return;
            }

            currentTarget = enemy;
            document.getElementById('evTargetPanel').style.display = 'block';

            // Update wireframe views
            if (targetFrontCtx) drawWireframeShip(targetFrontCtx, enemy.type, 'front');
            if (targetSideCtx) drawWireframeShip(targetSideCtx, enemy.type, 'side');

            // Update target info
            updateEVTargetInfo();
        }

        // Update target information display
        function updateEVTargetInfo() {
            if (!currentTarget || currentTarget.destroyed || (currentTarget.health <= 0 && !currentTarget.disabled)) {
                document.getElementById('evTargetPanel').style.display = 'none';
                currentTarget = null;
                return;
            }

            const typeNames = {
                'fighter': 'Light Fighter',
                'heavy': 'Heavy Cruiser',
                'boss': 'Capital Ship',
                'freighter': 'Freighter',
                'courier': 'Courier'
            };

            // Show disabled status
            let targetName = typeNames[currentTarget.type] || 'Unknown Vessel';
            if (currentTarget.disabled) {
                targetName += ' [DISABLED]';
            }
            document.getElementById('targetName').textContent = targetName;

            const faction = currentTarget.faction ? FACTIONS[currentTarget.faction] : null;
            document.getElementById('targetFaction').textContent = faction ? faction.name : 'Unknown Faction';
            document.getElementById('targetFaction').style.color = faction ? faction.color : '#008800';

            // EV-style shield and armor display
            const shieldPercent = currentTarget.maxShield > 0
                ? Math.ceil((currentTarget.shield / currentTarget.maxShield) * 100) : 0;
            const armorPercent = currentTarget.maxArmor > 0
                ? Math.ceil((currentTarget.armor / currentTarget.maxArmor) * 100) : 0;

            document.getElementById('targetHullVal').textContent = armorPercent + '%';
            document.getElementById('targetShieldVal').textContent = shieldPercent + '%';
            document.getElementById('targetHullBar').style.width = armorPercent + '%';
            document.getElementById('targetShieldBar').style.width = shieldPercent + '%';

            // Calculate distance
            const dx = currentTarget.x - playerState.x;
            const dy = currentTarget.y - playerState.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            document.getElementById('targetDistance').textContent = Math.round(distance) + 'm';
        }

        // Show EV-style comm panel
        function showEVCommPanel(factionId, dialogueType = 'hail') {
            const faction = FACTIONS[factionId];
            if (!faction) return;

            const dialogues = FACTION_DIALOGUE[factionId];
            if (!dialogues) return;

            const lines = dialogues[dialogueType] || dialogues.hail;
            const line = lines[Math.floor(Math.random() * lines.length)];

            // Hide old dialogue panel, show new one
            document.getElementById('dialoguePanel').style.display = 'none';
            const panel = document.getElementById('evCommPanel');

            // Random frequency
            document.getElementById('commFreq').textContent = (100 + Math.random() * 50).toFixed(1);
            document.getElementById('commSpeaker').innerHTML = `<span style="color:${faction.color}">${faction.name}</span>`;
            document.getElementById('commText').textContent = line;

            // Draw portrait
            if (commPortraitCtx) drawCommPortrait(commPortraitCtx, factionId);

            // Generate options
            const options = document.getElementById('commOptions');
            options.innerHTML = '';

            const attitude = getFactionAttitude(factionId);

            const closeBtn = document.createElement('button');
            closeBtn.className = 'comm-btn';
            closeBtn.textContent = 'CLOSE CHANNEL';
            closeBtn.onclick = () => { panel.style.display = 'none'; };
            options.appendChild(closeBtn);

            if (attitude !== 'hostile' && dialogueType === 'hail') {
                const missionBtn = document.createElement('button');
                missionBtn.className = 'comm-btn';
                missionBtn.textContent = 'REQUEST MISSION';
                missionBtn.onclick = () => {
                    panel.style.display = 'none';
                    toggleMissionPanel();
                };
                options.appendChild(missionBtn);
            }

            panel.style.display = 'block';
        }

        // Find nearest enemy for targeting
        function findNearestEnemy() {
            let nearest = null;
            let nearestDist = Infinity;

            enemies.forEach(e => {
                if (e.health <= 0) return;
                const dx = e.x - playerState.x;
                const dy = e.y - playerState.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < nearestDist && dist < 800) {  // Max targeting range
                    nearestDist = dist;
                    nearest = e;
                }
            });

            return nearest;
        }

        // Cycle to next target
        function cycleTarget() {
            const aliveEnemies = enemies.filter(e => e.health > 0);
            if (aliveEnemies.length === 0) {
                setEVTarget(null);
                return;
            }

            const currentIndex = currentTarget ? aliveEnemies.indexOf(currentTarget) : -1;
            const nextIndex = (currentIndex + 1) % aliveEnemies.length;
            setEVTarget(aliveEnemies[nextIndex]);
        }

        // ============================================================
        // EV:O STYLE TEXTURE GENERATION SYSTEM
        // ============================================================

        // Cache for generated textures to avoid recreation
        const generatedTextureCache = {};

        // UE/Human Military Hull Texture - Industrial, gunmetal with panel lines
        function createUEHullTexture() {
            if (generatedTextureCache.ueHull) return generatedTextureCache.ueHull;

            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');

            // Base gunmetal gray
            const baseGradient = ctx.createLinearGradient(0, 0, 512, 512);
            baseGradient.addColorStop(0, '#4a5568');
            baseGradient.addColorStop(0.5, '#3d4654');
            baseGradient.addColorStop(1, '#2d3748');
            ctx.fillStyle = baseGradient;
            ctx.fillRect(0, 0, 512, 512);

            // Major panel lines (darker recessed lines)
            ctx.strokeStyle = '#1a202c';
            ctx.lineWidth = 3;
            // Horizontal major panels
            [64, 192, 320, 448].forEach(y => {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(512, y);
                ctx.stroke();
            });
            // Vertical major panels
            [128, 256, 384].forEach(x => {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, 512);
                ctx.stroke();
            });

            // Minor panel lines (subtle)
            ctx.strokeStyle = '#2d3748';
            ctx.lineWidth = 1;
            for (let i = 32; i < 512; i += 32) {
                if (i % 64 !== 0) {
                    ctx.beginPath();
                    ctx.moveTo(0, i);
                    ctx.lineTo(512, i);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(i, 0);
                    ctx.lineTo(i, 512);
                    ctx.stroke();
                }
            }

            // Panel edge highlights (lighter edge on one side)
            ctx.strokeStyle = '#5a6577';
            ctx.lineWidth = 1;
            [65, 193, 321, 449].forEach(y => {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(512, y);
                ctx.stroke();
            });

            // Rivets at panel intersections
            ctx.fillStyle = '#5a6577';
            for (let x = 64; x < 512; x += 64) {
                for (let y = 64; y < 512; y += 64) {
                    // Rivet cluster
                    ctx.beginPath();
                    ctx.arc(x - 8, y - 8, 2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(x + 8, y - 8, 2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(x - 8, y + 8, 2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(x + 8, y + 8, 2, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Blue accent stripes (UE signature)
            ctx.fillStyle = '#3b82f6';
            ctx.fillRect(0, 180, 512, 4);
            ctx.fillRect(0, 328, 512, 4);

            // Wear marks and battle damage
            ctx.fillStyle = 'rgba(0,0,0,0.15)';
            for (let i = 0; i < 30; i++) {
                const x = Math.random() * 512;
                const y = Math.random() * 512;
                const w = 10 + Math.random() * 30;
                const h = 2 + Math.random() * 8;
                ctx.fillRect(x, y, w, h);
            }

            // Scorch marks
            ctx.fillStyle = 'rgba(40,30,20,0.2)';
            for (let i = 0; i < 8; i++) {
                const x = Math.random() * 512;
                const y = Math.random() * 512;
                ctx.beginPath();
                ctx.arc(x, y, 15 + Math.random() * 25, 0, Math.PI * 2);
                ctx.fill();
            }

            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            generatedTextureCache.ueHull = texture;
            return texture;
        }

        // Crescent/Gadzair Crystal Texture - Organic, gemstone-like
        function createCrescentTexture() {
            if (generatedTextureCache.crescent) return generatedTextureCache.crescent;

            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');

            // Deep purple base with gradient
            const baseGradient = ctx.createRadialGradient(256, 256, 0, 256, 256, 400);
            baseGradient.addColorStop(0, '#6b21a8');
            baseGradient.addColorStop(0.5, '#4c1d95');
            baseGradient.addColorStop(1, '#2e1065');
            ctx.fillStyle = baseGradient;
            ctx.fillRect(0, 0, 512, 512);

            // Crystal facet patterns
            ctx.strokeStyle = '#7c3aed';
            ctx.lineWidth = 2;
            // Organic curved lines
            for (let i = 0; i < 12; i++) {
                const startX = Math.random() * 512;
                const startY = Math.random() * 512;
                ctx.beginPath();
                ctx.moveTo(startX, startY);
                ctx.bezierCurveTo(
                    startX + 100 - Math.random() * 200, startY + 50,
                    startX + 50 - Math.random() * 100, startY + 150,
                    startX + 80 - Math.random() * 160, startY + 200
                );
                ctx.stroke();
            }

            // Crystal highlight spots
            for (let i = 0; i < 20; i++) {
                const x = Math.random() * 512;
                const y = Math.random() * 512;
                const size = 10 + Math.random() * 30;
                const gradient = ctx.createRadialGradient(x, y, 0, x, y, size);
                gradient.addColorStop(0, 'rgba(167, 139, 250, 0.6)');
                gradient.addColorStop(0.5, 'rgba(139, 92, 246, 0.3)');
                gradient.addColorStop(1, 'rgba(109, 40, 217, 0)');
                ctx.fillStyle = gradient;
                ctx.fillRect(x - size, y - size, size * 2, size * 2);
            }

            // Teal accent crystals
            ctx.fillStyle = 'rgba(20, 184, 166, 0.4)';
            for (let i = 0; i < 15; i++) {
                const x = Math.random() * 512;
                const y = Math.random() * 512;
                ctx.beginPath();
                ctx.moveTo(x, y - 15);
                ctx.lineTo(x + 10, y);
                ctx.lineTo(x, y + 15);
                ctx.lineTo(x - 10, y);
                ctx.closePath();
                ctx.fill();
            }

            // Inner glow effect
            const innerGlow = ctx.createRadialGradient(256, 256, 50, 256, 256, 256);
            innerGlow.addColorStop(0, 'rgba(196, 181, 253, 0.2)');
            innerGlow.addColorStop(1, 'rgba(0, 0, 0, 0)');
            ctx.fillStyle = innerGlow;
            ctx.fillRect(0, 0, 512, 512);

            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            generatedTextureCache.crescent = texture;
            return texture;
        }

        // Voinian Heavy Armor Texture - Brown/rust, heavy plating
        function createVoinianTexture() {
            if (generatedTextureCache.voinian) return generatedTextureCache.voinian;

            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');

            // Rust brown base
            const baseGradient = ctx.createLinearGradient(0, 0, 512, 512);
            baseGradient.addColorStop(0, '#78350f');
            baseGradient.addColorStop(0.3, '#92400e');
            baseGradient.addColorStop(0.7, '#713f12');
            baseGradient.addColorStop(1, '#451a03');
            ctx.fillStyle = baseGradient;
            ctx.fillRect(0, 0, 512, 512);

            // Heavy armor plate segments (thick lines)
            ctx.strokeStyle = '#1c1917';
            ctx.lineWidth = 6;
            // Horizontal heavy plates
            [85, 170, 255, 340, 425].forEach(y => {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(512, y);
                ctx.stroke();
            });
            // Vertical heavy plates (offset pattern)
            for (let row = 0; row < 6; row++) {
                const offset = (row % 2) * 64;
                for (let x = offset; x < 512; x += 128) {
                    ctx.beginPath();
                    ctx.moveTo(x, row * 85);
                    ctx.lineTo(x, (row + 1) * 85);
                    ctx.stroke();
                }
            }

            // Plate edge highlights
            ctx.strokeStyle = '#a16207';
            ctx.lineWidth = 2;
            [87, 172, 257, 342, 427].forEach(y => {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(512, y);
                ctx.stroke();
            });

            // Heavy bolt patterns
            ctx.fillStyle = '#44403c';
            for (let x = 32; x < 512; x += 64) {
                for (let y = 42; y < 512; y += 85) {
                    // Large hexagonal bolts
                    ctx.beginPath();
                    for (let i = 0; i < 6; i++) {
                        const angle = (i / 6) * Math.PI * 2;
                        const bx = x + Math.cos(angle) * 6;
                        const by = y + Math.sin(angle) * 6;
                        if (i === 0) ctx.moveTo(bx, by);
                        else ctx.lineTo(bx, by);
                    }
                    ctx.closePath();
                    ctx.fill();
                }
            }

            // Rust and corrosion effects
            ctx.fillStyle = 'rgba(180, 83, 9, 0.3)';
            for (let i = 0; i < 40; i++) {
                const x = Math.random() * 512;
                const y = Math.random() * 512;
                const w = 20 + Math.random() * 60;
                const h = 10 + Math.random() * 40;
                ctx.fillRect(x, y, w, h);
            }

            // Dark corrosion spots
            ctx.fillStyle = 'rgba(28, 25, 23, 0.4)';
            for (let i = 0; i < 20; i++) {
                const x = Math.random() * 512;
                const y = Math.random() * 512;
                ctx.beginPath();
                ctx.arc(x, y, 8 + Math.random() * 20, 0, Math.PI * 2);
                ctx.fill();
            }

            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            generatedTextureCache.voinian = texture;
            return texture;
        }

        // Katuri Texture - Angular, aggressive, red/black
        function createKaturiTexture() {
            if (generatedTextureCache.katuri) return generatedTextureCache.katuri;

            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');

            // Dark red-black base
            const baseGradient = ctx.createLinearGradient(0, 0, 512, 512);
            baseGradient.addColorStop(0, '#450a0a');
            baseGradient.addColorStop(0.5, '#7f1d1d');
            baseGradient.addColorStop(1, '#1c1917');
            ctx.fillStyle = baseGradient;
            ctx.fillRect(0, 0, 512, 512);

            // Angular slash patterns
            ctx.strokeStyle = '#991b1b';
            ctx.lineWidth = 3;
            for (let i = 0; i < 8; i++) {
                const x1 = i * 64;
                ctx.beginPath();
                ctx.moveTo(x1, 0);
                ctx.lineTo(x1 + 256, 512);
                ctx.stroke();
            }

            // Reverse diagonal
            ctx.strokeStyle = '#dc2626';
            ctx.lineWidth = 2;
            for (let i = 0; i < 8; i++) {
                const x1 = 512 - i * 64;
                ctx.beginPath();
                ctx.moveTo(x1, 0);
                ctx.lineTo(x1 - 256, 512);
                ctx.stroke();
            }

            // Red energy veins
            ctx.strokeStyle = '#ef4444';
            ctx.lineWidth = 1;
            ctx.shadowColor = '#ef4444';
            ctx.shadowBlur = 5;
            for (let i = 0; i < 15; i++) {
                const startX = Math.random() * 512;
                const startY = Math.random() * 512;
                ctx.beginPath();
                ctx.moveTo(startX, startY);
                let x = startX, y = startY;
                for (let j = 0; j < 5; j++) {
                    x += (Math.random() - 0.5) * 80;
                    y += Math.random() * 60;
                    ctx.lineTo(x, y);
                }
                ctx.stroke();
            }
            ctx.shadowBlur = 0;

            // Hot spots/vents
            for (let i = 0; i < 10; i++) {
                const x = Math.random() * 512;
                const y = Math.random() * 512;
                const gradient = ctx.createRadialGradient(x, y, 0, x, y, 25);
                gradient.addColorStop(0, 'rgba(239, 68, 68, 0.8)');
                gradient.addColorStop(0.5, 'rgba(153, 27, 27, 0.4)');
                gradient.addColorStop(1, 'rgba(69, 10, 10, 0)');
                ctx.fillStyle = gradient;
                ctx.fillRect(x - 25, y - 25, 50, 50);
            }

            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            generatedTextureCache.katuri = texture;
            return texture;
        }

        // Pirate Texture - Mismatched, cobbled together
        function createPirateTexture() {
            if (generatedTextureCache.pirate) return generatedTextureCache.pirate;

            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');

            // Patchy multi-colored base
            const colors = ['#374151', '#4b5563', '#6b7280', '#1f2937', '#52525b'];
            for (let x = 0; x < 8; x++) {
                for (let y = 0; y < 8; y++) {
                    ctx.fillStyle = colors[Math.floor(Math.random() * colors.length)];
                    ctx.fillRect(x * 64, y * 64, 64, 64);
                }
            }

            // Welded seams (irregular)
            ctx.strokeStyle = '#f59e0b';
            ctx.lineWidth = 4;
            for (let i = 0; i < 15; i++) {
                const x1 = Math.random() * 512;
                const y1 = Math.random() * 512;
                const x2 = x1 + (Math.random() - 0.5) * 150;
                const y2 = y1 + (Math.random() - 0.5) * 150;
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();
            }

            // Weld splatter
            ctx.fillStyle = '#fbbf24';
            for (let i = 0; i < 50; i++) {
                const x = Math.random() * 512;
                const y = Math.random() * 512;
                ctx.beginPath();
                ctx.arc(x, y, 1 + Math.random() * 3, 0, Math.PI * 2);
                ctx.fill();
            }

            // Patches and repairs
            ctx.strokeStyle = '#9ca3af';
            ctx.lineWidth = 2;
            for (let i = 0; i < 8; i++) {
                const x = Math.random() * 400 + 50;
                const y = Math.random() * 400 + 50;
                const w = 30 + Math.random() * 50;
                const h = 20 + Math.random() * 40;
                ctx.strokeRect(x, y, w, h);
                // Cross rivets
                ctx.fillStyle = '#6b7280';
                ctx.beginPath();
                ctx.arc(x + 5, y + 5, 3, 0, Math.PI * 2);
                ctx.arc(x + w - 5, y + 5, 3, 0, Math.PI * 2);
                ctx.arc(x + 5, y + h - 5, 3, 0, Math.PI * 2);
                ctx.arc(x + w - 5, y + h - 5, 3, 0, Math.PI * 2);
                ctx.fill();
            }

            // Heavy damage and burns
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            for (let i = 0; i < 25; i++) {
                const x = Math.random() * 512;
                const y = Math.random() * 512;
                ctx.beginPath();
                ctx.arc(x, y, 5 + Math.random() * 20, 0, Math.PI * 2);
                ctx.fill();
            }

            // Orange warning stripes
            ctx.fillStyle = '#ea580c';
            ctx.fillRect(0, 100, 512, 8);
            ctx.fillRect(0, 400, 512, 8);

            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            generatedTextureCache.pirate = texture;
            return texture;
        }

        // Miranu Texture - Peaceful trader, gold/bronze
        function createMiranuTexture() {
            if (generatedTextureCache.miranu) return generatedTextureCache.miranu;

            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');

            // Warm golden base
            const baseGradient = ctx.createRadialGradient(256, 256, 0, 256, 256, 400);
            baseGradient.addColorStop(0, '#fcd34d');
            baseGradient.addColorStop(0.5, '#d97706');
            baseGradient.addColorStop(1, '#92400e');
            ctx.fillStyle = baseGradient;
            ctx.fillRect(0, 0, 512, 512);

            // Smooth curved panel lines
            ctx.strokeStyle = '#78350f';
            ctx.lineWidth = 2;
            for (let i = 0; i < 6; i++) {
                const y = i * 85 + 42;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.quadraticCurveTo(256, y + 20 * Math.sin(i), 512, y);
                ctx.stroke();
            }

            // Decorative circular patterns
            ctx.strokeStyle = '#b45309';
            ctx.lineWidth = 1;
            for (let i = 0; i < 8; i++) {
                const x = 64 + i * 56;
                const y = 256 + Math.sin(i * 0.8) * 100;
                ctx.beginPath();
                ctx.arc(x, y, 20, 0, Math.PI * 2);
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(x, y, 12, 0, Math.PI * 2);
                ctx.stroke();
            }

            // Polished highlights
            for (let i = 0; i < 15; i++) {
                const x = Math.random() * 512;
                const y = Math.random() * 512;
                const gradient = ctx.createRadialGradient(x, y, 0, x, y, 40);
                gradient.addColorStop(0, 'rgba(254, 243, 199, 0.5)');
                gradient.addColorStop(1, 'rgba(253, 230, 138, 0)');
                ctx.fillStyle = gradient;
                ctx.fillRect(x - 40, y - 40, 80, 80);
            }

            // Cargo bay hatches
            ctx.fillStyle = '#78350f';
            for (let i = 0; i < 4; i++) {
                const x = 80 + i * 100;
                ctx.fillRect(x, 400, 60, 40);
                ctx.fillStyle = '#92400e';
                ctx.fillRect(x + 5, 405, 50, 30);
                ctx.fillStyle = '#78350f';
            }

            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            generatedTextureCache.miranu = texture;
            return texture;
        }

        // Alien/Mystery Texture - Otherworldly green
        function createAlienTexture() {
            if (generatedTextureCache.alien) return generatedTextureCache.alien;

            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');

            // Deep space green-black
            const baseGradient = ctx.createRadialGradient(256, 256, 0, 256, 256, 400);
            baseGradient.addColorStop(0, '#065f46');
            baseGradient.addColorStop(0.5, '#064e3b');
            baseGradient.addColorStop(1, '#022c22');
            ctx.fillStyle = baseGradient;
            ctx.fillRect(0, 0, 512, 512);

            // Bioluminescent patterns
            ctx.strokeStyle = '#10b981';
            ctx.lineWidth = 2;
            ctx.shadowColor = '#10b981';
            ctx.shadowBlur = 10;
            for (let i = 0; i < 8; i++) {
                ctx.beginPath();
                ctx.arc(256, 256, 50 + i * 30, 0, Math.PI * 2);
                ctx.stroke();
            }
            ctx.shadowBlur = 0;

            // Organic vein network
            ctx.strokeStyle = '#34d399';
            ctx.lineWidth = 1;
            for (let i = 0; i < 20; i++) {
                const startAngle = Math.random() * Math.PI * 2;
                const startR = 50 + Math.random() * 150;
                const startX = 256 + Math.cos(startAngle) * startR;
                const startY = 256 + Math.sin(startAngle) * startR;
                ctx.beginPath();
                ctx.moveTo(startX, startY);
                let x = startX, y = startY;
                for (let j = 0; j < 8; j++) {
                    x += (Math.random() - 0.5) * 60;
                    y += (Math.random() - 0.5) * 60;
                    ctx.lineTo(x, y);
                }
                ctx.stroke();
            }

            // Glowing nodes
            for (let i = 0; i < 25; i++) {
                const x = Math.random() * 512;
                const y = Math.random() * 512;
                const gradient = ctx.createRadialGradient(x, y, 0, x, y, 15);
                gradient.addColorStop(0, '#6ee7b7');
                gradient.addColorStop(0.5, '#10b981');
                gradient.addColorStop(1, 'rgba(6, 95, 70, 0)');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(x, y, 15, 0, Math.PI * 2);
                ctx.fill();
            }

            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            generatedTextureCache.alien = texture;
            return texture;
        }

        // Engine glow texture with customizable color
        function createEngineGlowTexture(color1 = '#ffffff', color2 = '#00ffff', color3 = '#0088ff') {
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 128;
            const ctx = canvas.getContext('2d');

            const gradient = ctx.createRadialGradient(64, 64, 0, 64, 64, 64);
            gradient.addColorStop(0, color1);
            gradient.addColorStop(0.2, color2);
            gradient.addColorStop(0.5, color3);
            gradient.addColorStop(1, 'rgba(0,0,0,0)');

            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 128, 128);

            return new THREE.CanvasTexture(canvas);
        }

        // Cockpit glass texture
        function createCockpitTexture() {
            if (generatedTextureCache.cockpit) return generatedTextureCache.cockpit;

            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 256;
            const ctx = canvas.getContext('2d');

            // Dark tinted glass
            const gradient = ctx.createRadialGradient(128, 128, 0, 128, 128, 150);
            gradient.addColorStop(0, 'rgba(100, 200, 255, 0.3)');
            gradient.addColorStop(0.5, 'rgba(50, 100, 150, 0.5)');
            gradient.addColorStop(1, 'rgba(20, 40, 60, 0.7)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 256, 256);

            // Reflection highlights
            ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.beginPath();
            ctx.ellipse(90, 90, 40, 20, -0.5, 0, Math.PI * 2);
            ctx.fill();

            // Frame lines
            ctx.strokeStyle = 'rgba(100, 150, 200, 0.5)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, 128);
            ctx.lineTo(256, 128);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(128, 0);
            ctx.lineTo(128, 256);
            ctx.stroke();

            const texture = new THREE.CanvasTexture(canvas);
            generatedTextureCache.cockpit = texture;
            return texture;
        }

        // Legacy function for backwards compatibility
        function createHullTexture() {
            return createUEHullTexture();
        }

        // ============================================================
        // EV:O STYLE PLAYER SHIP - Uses GLB models from Blender
        // Falls back to procedural generation if model not loaded
        // ============================================================
        function createPlayerShip() {
            const group = new THREE.Group();

            // Try to use GLB model first
            const modelName = SHIP_MODELS.player;
            const glbModel = cloneModel(modelName);

            if (glbModel) {
                // Use the hand-made GLB model
                glbModel.rotation.x = -Math.PI / 2; // Rotate to face forward (nose = -Z)
                glbModel.rotation.z = Math.PI; // Flip to match expected orientation

                // Add engine glow effect
                const engineGlowGeom = new THREE.SphereGeometry(3, 8, 8);
                const engineMat = new THREE.MeshBasicMaterial({
                    color: 0x00ffff,
                    transparent: true,
                    opacity: 0.8
                });
                const engineGlow = new THREE.Mesh(engineGlowGeom, engineMat);
                engineGlow.position.set(0, 0, 25); // Behind the ship
                engineGlow.name = 'engineGlow';

                // Add direction indicator
                const beamMat = new THREE.MeshBasicMaterial({
                    color: 0x00ffff,
                    transparent: true,
                    opacity: 0.6
                });
                const beamGeom = new THREE.CylinderGeometry(0.5, 1, 30, 6);
                const beam = new THREE.Mesh(beamGeom, beamMat);
                beam.position.set(0, 0, -50);
                beam.rotation.x = Math.PI / 2;
                beam.name = 'directionLine';

                const arrowGeom = new THREE.ConeGeometry(3, 8, 6);
                const arrowMat = new THREE.MeshBasicMaterial({
                    color: 0x00ffff,
                    transparent: true,
                    opacity: 0.8
                });
                const arrow = new THREE.Mesh(arrowGeom, arrowMat);
                arrow.position.set(0, 0, -67);
                arrow.rotation.x = -Math.PI / 2;
                arrow.name = 'directionArrow';

                group.add(glbModel);
                group.add(engineGlow);
                group.add(beam);
                group.add(arrow);

                // Scale for game
                group.scale.set(SHIP_SCALE, SHIP_SCALE, SHIP_SCALE);

                // Set high render order so player renders above stations
                group.renderOrder = 100;
                group.traverse(child => {
                    if (child.isMesh) {
                        child.renderOrder = 100;
                        child.material.depthTest = true;
                    }
                });

                console.log('Using GLB model for player ship');
                return group;
            }

            // Fallback to procedural generation if model not loaded
            console.log('Falling back to procedural player ship');
            const hullTexture = createUEHullTexture();
            const cockpitTexture = createCockpitTexture();

            // Color palette - UE gunmetal with blue accents
            const hullColor = 0x4a5568;      // Gunmetal gray
            const accentColor = 0x3b82f6;    // Blue highlights
            const darkMetal = 0x2d3748;      // Dark sections
            const lightMetal = 0x64748b;     // Lighter panels

            // === MAIN FUSELAGE ===
            // Central body - tapered front, wider rear
            const fuselageShape = new THREE.Shape();
            fuselageShape.moveTo(0, -30);    // Nose point
            fuselageShape.lineTo(8, -25);
            fuselageShape.lineTo(12, -15);
            fuselageShape.lineTo(14, 0);
            fuselageShape.lineTo(14, 15);
            fuselageShape.lineTo(12, 25);
            fuselageShape.lineTo(8, 30);
            fuselageShape.lineTo(-8, 30);
            fuselageShape.lineTo(-12, 25);
            fuselageShape.lineTo(-14, 15);
            fuselageShape.lineTo(-14, 0);
            fuselageShape.lineTo(-12, -15);
            fuselageShape.lineTo(-8, -25);
            fuselageShape.closePath();

            const fuselageGeom = new THREE.ExtrudeGeometry(fuselageShape, {
                steps: 2,
                depth: 10,
                bevelEnabled: true,
                bevelThickness: 2,
                bevelSize: 1.5,
                bevelSegments: 2
            });
            const fuselageMat = new THREE.MeshStandardMaterial({
                map: hullTexture,
                color: hullColor,
                metalness: 0.75,
                roughness: 0.35
            });
            const fuselage = new THREE.Mesh(fuselageGeom, fuselageMat);
            fuselage.rotation.x = -Math.PI / 2;
            fuselage.position.y = 3;
            group.add(fuselage);

            // Upper hull ridge (dorsal spine)
            const ridgeGeom = new THREE.BoxGeometry(4, 4, 50);
            const ridgeMat = new THREE.MeshStandardMaterial({
                map: hullTexture,
                color: darkMetal,
                metalness: 0.8,
                roughness: 0.3
            });
            const ridge = new THREE.Mesh(ridgeGeom, ridgeMat);
            ridge.position.set(0, 9, 0);
            group.add(ridge);

            // === NOSE SECTION ===
            // Sensor array / nose cone
            const noseGeom = new THREE.ConeGeometry(6, 18, 8);
            const noseMat = new THREE.MeshStandardMaterial({
                color: lightMetal,
                metalness: 0.85,
                roughness: 0.2
            });
            const nose = new THREE.Mesh(noseGeom, noseMat);
            nose.position.set(0, 5, -38);
            nose.rotation.x = -Math.PI / 2;
            group.add(nose);

            // Nose tip sensor (bright blue - shows direction)
            const sensorTipGeom = new THREE.SphereGeometry(2, 12, 12);
            const sensorTipMat = new THREE.MeshStandardMaterial({
                color: accentColor,
                metalness: 0.9,
                roughness: 0.1,
                emissive: accentColor,
                emissiveIntensity: 0.8
            });
            const sensorTip = new THREE.Mesh(sensorTipGeom, sensorTipMat);
            sensorTip.position.set(0, 5, -47);
            group.add(sensorTip);

            // Direction indicator beam (extends from nose)
            const beamMat = new THREE.MeshBasicMaterial({
                color: 0x00ffff,
                transparent: true,
                opacity: 0.6
            });
            const beamGeom = new THREE.CylinderGeometry(0.5, 1, 30, 6);
            const beam = new THREE.Mesh(beamGeom, beamMat);
            beam.position.set(0, 5, -65);
            beam.rotation.x = Math.PI / 2;
            beam.name = 'directionLine';
            group.add(beam);

            // Arrow indicator
            const arrowGeom = new THREE.ConeGeometry(3, 8, 6);
            const arrowMat = new THREE.MeshBasicMaterial({
                color: 0x00ffff,
                transparent: true,
                opacity: 0.8
            });
            const arrow = new THREE.Mesh(arrowGeom, arrowMat);
            arrow.position.set(0, 5, -82);
            arrow.rotation.x = -Math.PI / 2;
            arrow.name = 'directionArrow';
            group.add(arrow);

            // === COCKPIT ASSEMBLY ===
            // Cockpit frame
            const cockpitFrameGeom = new THREE.BoxGeometry(10, 3, 16);
            const cockpitFrameMat = new THREE.MeshStandardMaterial({
                color: darkMetal,
                metalness: 0.8,
                roughness: 0.3
            });
            const cockpitFrame = new THREE.Mesh(cockpitFrameGeom, cockpitFrameMat);
            cockpitFrame.position.set(0, 10, -18);
            group.add(cockpitFrame);

            // Glass canopy (elongated dome)
            const canopyGeom = new THREE.SphereGeometry(5, 16, 12, 0, Math.PI * 2, 0, Math.PI / 2);
            const canopyMat = new THREE.MeshStandardMaterial({
                map: cockpitTexture,
                color: 0x88ddff,
                metalness: 0.95,
                roughness: 0.05,
                transparent: true,
                opacity: 0.75,
                envMapIntensity: 1.2
            });
            const canopy = new THREE.Mesh(canopyGeom, canopyMat);
            canopy.position.set(0, 11.5, -18);
            canopy.scale.set(1.0, 0.6, 1.6);
            group.add(canopy);

            // Cockpit interior glow
            const interiorGlowGeom = new THREE.SphereGeometry(3, 8, 8);
            const interiorGlowMat = new THREE.MeshBasicMaterial({
                color: 0x00ff88,
                transparent: true,
                opacity: 0.4
            });
            const interiorGlow = new THREE.Mesh(interiorGlowGeom, interiorGlowMat);
            interiorGlow.position.set(0, 11, -18);
            group.add(interiorGlow);

            // Cockpit frame struts
            const strutMat = new THREE.MeshStandardMaterial({
                color: 0x1a202c,
                metalness: 0.9,
                roughness: 0.2
            });
            [-3, 0, 3].forEach(offset => {
                const strutGeom = new THREE.BoxGeometry(0.5, 4, 0.5);
                const strut = new THREE.Mesh(strutGeom, strutMat);
                strut.position.set(offset, 13, -18);
                strut.rotation.x = 0.3;
                group.add(strut);
            });

            // === MAIN WINGS ===
            // Swept-back wing shape
            const wingShape = new THREE.Shape();
            wingShape.moveTo(0, 0);
            wingShape.lineTo(35, 10);
            wingShape.lineTo(42, 8);
            wingShape.lineTo(45, 5);
            wingShape.lineTo(40, -5);
            wingShape.lineTo(10, -8);
            wingShape.closePath();

            const wingExtrudeSettings = {
                steps: 1,
                depth: 2,
                bevelEnabled: true,
                bevelThickness: 0.5,
                bevelSize: 0.3,
                bevelSegments: 1
            };

            const wingMat = new THREE.MeshStandardMaterial({
                map: hullTexture,
                color: hullColor,
                metalness: 0.7,
                roughness: 0.4
            });

            // Left wing
            const leftWingGeom = new THREE.ExtrudeGeometry(wingShape, wingExtrudeSettings);
            const leftWing = new THREE.Mesh(leftWingGeom, wingMat);
            leftWing.position.set(-12, 4, 5);
            leftWing.rotation.x = -Math.PI / 2;
            leftWing.rotation.z = Math.PI;
            group.add(leftWing);

            // Right wing (mirrored)
            const rightWing = new THREE.Mesh(leftWingGeom, wingMat);
            rightWing.position.set(12, 4, 5);
            rightWing.rotation.x = -Math.PI / 2;
            rightWing.rotation.z = 0;
            rightWing.scale.x = -1;
            group.add(rightWing);

            // Wing surface panels (detail strips)
            const wingPanelGeom = new THREE.BoxGeometry(30, 0.5, 1);
            const wingPanelMat = new THREE.MeshStandardMaterial({
                color: accentColor,
                metalness: 0.8,
                roughness: 0.2,
                emissive: accentColor,
                emissiveIntensity: 0.2
            });
            [[-30, 3], [30, 3]].forEach(([x, z]) => {
                const panel = new THREE.Mesh(wingPanelGeom, wingPanelMat);
                panel.position.set(x, 5, z);
                group.add(panel);
            });

            // === WING-MOUNTED WEAPONS (Blaze Cannons) ===
            // Gun housings
            const gunHousingGeom = new THREE.BoxGeometry(4, 3, 8);
            const gunHousingMat = new THREE.MeshStandardMaterial({
                color: darkMetal,
                metalness: 0.85,
                roughness: 0.25
            });

            // Wing gun barrels
            const gunBarrelGeom = new THREE.CylinderGeometry(1.2, 1.5, 18, 8);
            const gunBarrelMat = new THREE.MeshStandardMaterial({
                color: 0x1a1a1a,
                metalness: 0.95,
                roughness: 0.15
            });

            // Left wing guns (twin barrels)
            const leftGunHousing = new THREE.Mesh(gunHousingGeom, gunHousingMat);
            leftGunHousing.position.set(-25, 4, 0);
            group.add(leftGunHousing);

            const leftGunUpper = new THREE.Mesh(gunBarrelGeom, gunBarrelMat);
            leftGunUpper.position.set(-24, 5.5, -10);
            leftGunUpper.rotation.x = Math.PI / 2;
            group.add(leftGunUpper);

            const leftGunLower = new THREE.Mesh(gunBarrelGeom, gunBarrelMat);
            leftGunLower.position.set(-26, 3, -10);
            leftGunLower.rotation.x = Math.PI / 2;
            group.add(leftGunLower);

            // Right wing guns (twin barrels)
            const rightGunHousing = new THREE.Mesh(gunHousingGeom, gunHousingMat);
            rightGunHousing.position.set(25, 4, 0);
            group.add(rightGunHousing);

            const rightGunUpper = new THREE.Mesh(gunBarrelGeom, gunBarrelMat);
            rightGunUpper.position.set(24, 5.5, -10);
            rightGunUpper.rotation.x = Math.PI / 2;
            group.add(rightGunUpper);

            const rightGunLower = new THREE.Mesh(gunBarrelGeom, gunBarrelMat);
            rightGunLower.position.set(26, 3, -10);
            rightGunLower.rotation.x = Math.PI / 2;
            group.add(rightGunLower);

            // Gun muzzle flash points
            const muzzleGeom = new THREE.CircleGeometry(1.5, 8);
            const muzzleMat = new THREE.MeshBasicMaterial({
                color: 0x00ffff,
                transparent: true,
                opacity: 0.5,
                side: THREE.DoubleSide
            });
            [[-24, 5.5], [-26, 3], [24, 5.5], [26, 3]].forEach(([x, y]) => {
                const muzzle = new THREE.Mesh(muzzleGeom, muzzleMat);
                muzzle.position.set(x, y, -19);
                group.add(muzzle);
            });

            // === ENGINE NACELLES ===
            // Main engine housings (twin engines, UE signature)
            const engineHousingGeom = new THREE.CylinderGeometry(6, 8, 30, 12);
            const engineHousingMat = new THREE.MeshStandardMaterial({
                map: hullTexture,
                color: darkMetal,
                metalness: 0.8,
                roughness: 0.3
            });

            // Engine intake cowling
            const intakeGeom = new THREE.CylinderGeometry(8, 6, 5, 12);
            const intakeMat = new THREE.MeshStandardMaterial({
                color: 0x1a1a1a,
                metalness: 0.9,
                roughness: 0.2
            });

            // Left engine assembly
            const leftEngineHousing = new THREE.Mesh(engineHousingGeom, engineHousingMat);
            leftEngineHousing.position.set(-16, 3, 18);
            leftEngineHousing.rotation.x = Math.PI / 2;
            group.add(leftEngineHousing);

            const leftIntake = new THREE.Mesh(intakeGeom, intakeMat);
            leftIntake.position.set(-16, 3, 2);
            leftIntake.rotation.x = Math.PI / 2;
            group.add(leftIntake);

            // Engine detail rings
            const ringGeom = new THREE.TorusGeometry(7, 0.8, 8, 16);
            const ringMat = new THREE.MeshStandardMaterial({
                color: lightMetal,
                metalness: 0.85,
                roughness: 0.2
            });
            [8, 18, 28].forEach(z => {
                const leftRing = new THREE.Mesh(ringGeom, ringMat);
                leftRing.position.set(-16, 3, z);
                leftRing.rotation.x = Math.PI / 2;
                group.add(leftRing);
            });

            // Right engine assembly
            const rightEngineHousing = new THREE.Mesh(engineHousingGeom, engineHousingMat);
            rightEngineHousing.position.set(16, 3, 18);
            rightEngineHousing.rotation.x = Math.PI / 2;
            group.add(rightEngineHousing);

            const rightIntake = new THREE.Mesh(intakeGeom, intakeMat);
            rightIntake.position.set(16, 3, 2);
            rightIntake.rotation.x = Math.PI / 2;
            group.add(rightIntake);

            [8, 18, 28].forEach(z => {
                const rightRing = new THREE.Mesh(ringGeom, ringMat);
                rightRing.position.set(16, 3, z);
                rightRing.rotation.x = Math.PI / 2;
                group.add(rightRing);
            });

            // === ENGINE EXHAUST / THRUST NOZZLES ===
            const nozzleGeom = new THREE.CylinderGeometry(5, 6, 4, 12);
            const nozzleMat = new THREE.MeshStandardMaterial({
                color: 0x0a0a0a,
                metalness: 0.95,
                roughness: 0.1
            });

            const leftNozzle = new THREE.Mesh(nozzleGeom, nozzleMat);
            leftNozzle.position.set(-16, 3, 34);
            leftNozzle.rotation.x = Math.PI / 2;
            group.add(leftNozzle);

            const rightNozzle = new THREE.Mesh(nozzleGeom, nozzleMat);
            rightNozzle.position.set(16, 3, 34);
            rightNozzle.rotation.x = Math.PI / 2;
            group.add(rightNozzle);

            // Engine glow sprites
            const engineGlowTexture = createEngineGlowTexture('#ffffff', '#00ffff', '#0066ff');
            const engineGlowMat = new THREE.SpriteMaterial({
                map: engineGlowTexture,
                color: 0x00ffff,
                transparent: true,
                blending: THREE.AdditiveBlending
            });

            const leftGlow = new THREE.Sprite(engineGlowMat.clone());
            leftGlow.position.set(-16, 3, 38);
            leftGlow.scale.set(18, 18, 1);
            leftGlow.name = 'engineGlow';
            group.add(leftGlow);

            const rightGlow = new THREE.Sprite(engineGlowMat.clone());
            rightGlow.position.set(16, 3, 38);
            rightGlow.scale.set(18, 18, 1);
            rightGlow.name = 'engineGlow';
            group.add(rightGlow);

            // Engine thrust cones (visible when accelerating)
            const thrustGeom = new THREE.ConeGeometry(5, 40, 8);
            const thrustMat = new THREE.MeshBasicMaterial({
                color: 0x00aaff,
                transparent: true,
                opacity: 0.5
            });

            const leftThrust = new THREE.Mesh(thrustGeom, thrustMat.clone());
            leftThrust.position.set(-16, 3, 60);
            leftThrust.rotation.x = -Math.PI / 2;
            leftThrust.name = 'engineTrail';
            leftThrust.visible = false;
            group.add(leftThrust);

            const rightThrust = new THREE.Mesh(thrustGeom, thrustMat.clone());
            rightThrust.position.set(16, 3, 60);
            rightThrust.rotation.x = -Math.PI / 2;
            rightThrust.name = 'engineTrail';
            rightThrust.visible = false;
            group.add(rightThrust);

            // === DORSAL TURRET ASSEMBLY ===
            const turretBaseGeom = new THREE.CylinderGeometry(5, 6, 4, 12);
            const turretBaseMat = new THREE.MeshStandardMaterial({
                color: darkMetal,
                metalness: 0.85,
                roughness: 0.25
            });
            const turretBase = new THREE.Mesh(turretBaseGeom, turretBaseMat);
            turretBase.position.set(0, 11, 0);
            group.add(turretBase);

            // Turret dome
            const turretDomeGeom = new THREE.SphereGeometry(4, 12, 8, 0, Math.PI * 2, 0, Math.PI / 2);
            const turretDome = new THREE.Mesh(turretDomeGeom, turretBaseMat);
            turretDome.position.set(0, 13, 0);
            group.add(turretDome);

            // Turret gun barrel
            const turretBarrelGeom = new THREE.CylinderGeometry(1, 1.2, 14, 8);
            const turretBarrel = new THREE.Mesh(turretBarrelGeom, gunBarrelMat);
            turretBarrel.position.set(0, 13, -8);
            turretBarrel.rotation.x = Math.PI / 2;
            turretBarrel.name = 'turret';
            group.add(turretBarrel);

            // Turret tracking light
            const turretLightGeom = new THREE.SphereGeometry(0.8, 8, 8);
            const turretLightMat = new THREE.MeshBasicMaterial({
                color: 0xffaa00,
                emissive: 0xffaa00,
                emissiveIntensity: 1
            });
            const turretLight = new THREE.Mesh(turretLightGeom, turretLightMat);
            turretLight.position.set(0, 15, -2);
            group.add(turretLight);

            // === MISSILE PODS (underwing) ===
            const podGeom = new THREE.BoxGeometry(5, 3, 12);
            const podMat = new THREE.MeshStandardMaterial({
                color: darkMetal,
                metalness: 0.75,
                roughness: 0.35
            });

            // Missile tube details
            const missileGeom = new THREE.CylinderGeometry(0.8, 0.8, 10, 6);
            const missileMat = new THREE.MeshStandardMaterial({
                color: 0x2a2a2a,
                metalness: 0.9,
                roughness: 0.2
            });

            // Left missile pod
            const leftPod = new THREE.Mesh(podGeom, podMat);
            leftPod.position.set(-32, 2, 8);
            group.add(leftPod);

            // Missile tubes in left pod
            [[-31, 3], [-33, 3], [-31, 1], [-33, 1]].forEach(([x, y]) => {
                const tube = new THREE.Mesh(missileGeom, missileMat);
                tube.position.set(x, y, 8);
                tube.rotation.x = Math.PI / 2;
                group.add(tube);
            });

            // Right missile pod
            const rightPod = new THREE.Mesh(podGeom, podMat);
            rightPod.position.set(32, 2, 8);
            group.add(rightPod);

            // Missile tubes in right pod
            [[31, 3], [33, 3], [31, 1], [33, 1]].forEach(([x, y]) => {
                const tube = new THREE.Mesh(missileGeom, missileMat);
                tube.position.set(x, y, 8);
                tube.rotation.x = Math.PI / 2;
                group.add(tube);
            });

            // === SOLAR PANEL ARRAYS (UE signature) ===
            const solarGeom = new THREE.BoxGeometry(8, 0.3, 14);
            const solarMat = new THREE.MeshStandardMaterial({
                color: 0x1e3a5f,
                metalness: 0.4,
                roughness: 0.6,
                emissive: 0x0a1929,
                emissiveIntensity: 0.3
            });

            // Solar cell pattern overlay
            const leftSolar = new THREE.Mesh(solarGeom, solarMat);
            leftSolar.position.set(-45, 5, 5);
            leftSolar.rotation.z = 0.15;
            group.add(leftSolar);

            const rightSolar = new THREE.Mesh(solarGeom, solarMat);
            rightSolar.position.set(45, 5, 5);
            rightSolar.rotation.z = -0.15;
            group.add(rightSolar);

            // Solar panel frames
            const solarFrameGeom = new THREE.BoxGeometry(9, 0.5, 15);
            const solarFrameMat = new THREE.MeshStandardMaterial({
                color: lightMetal,
                metalness: 0.8,
                roughness: 0.3
            });

            const leftSolarFrame = new THREE.Mesh(solarFrameGeom, solarFrameMat);
            leftSolarFrame.position.set(-45, 5.2, 5);
            leftSolarFrame.rotation.z = 0.15;
            group.add(leftSolarFrame);

            const rightSolarFrame = new THREE.Mesh(solarFrameGeom, solarFrameMat);
            rightSolarFrame.position.set(45, 5.2, 5);
            rightSolarFrame.rotation.z = -0.15;
            group.add(rightSolarFrame);

            // === NAVIGATION LIGHTS ===
            const navLightGeom = new THREE.SphereGeometry(1.2, 8, 8);

            // Port (left) - red
            const portLightMat = new THREE.MeshBasicMaterial({
                color: 0xff0000,
                transparent: true,
                opacity: 0.9
            });
            const portLight = new THREE.Mesh(navLightGeom, portLightMat);
            portLight.position.set(-50, 5.5, 5);
            group.add(portLight);

            // Starboard (right) - green
            const starboardLightMat = new THREE.MeshBasicMaterial({
                color: 0x00ff00,
                transparent: true,
                opacity: 0.9
            });
            const starboardLight = new THREE.Mesh(navLightGeom, starboardLightMat);
            starboardLight.position.set(50, 5.5, 5);
            group.add(starboardLight);

            // Tail strobe - white
            const strobeLightMat = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.9
            });
            const strobeLight = new THREE.Mesh(navLightGeom, strobeLightMat);
            strobeLight.position.set(0, 8, 32);
            group.add(strobeLight);

            // Forward landing lights - bright white
            const landingLightGeom = new THREE.SphereGeometry(0.8, 8, 8);
            const landingLightMat = new THREE.MeshBasicMaterial({
                color: 0xffffee,
                transparent: true,
                opacity: 0.8
            });
            [[-6, -28], [6, -28]].forEach(([x, z]) => {
                const light = new THREE.Mesh(landingLightGeom, landingLightMat);
                light.position.set(x, 3, z);
                group.add(light);
            });

            // === HULL DETAIL ADDITIONS ===
            // Ventral hull plating
            const ventralGeom = new THREE.BoxGeometry(20, 2, 35);
            const ventralMat = new THREE.MeshStandardMaterial({
                map: hullTexture,
                color: darkMetal,
                metalness: 0.75,
                roughness: 0.4
            });
            const ventralPlate = new THREE.Mesh(ventralGeom, ventralMat);
            ventralPlate.position.set(0, 0, 5);
            group.add(ventralPlate);

            // Blue accent stripe on fuselage
            const stripeGeom = new THREE.BoxGeometry(0.5, 8, 60);
            const stripeMat = new THREE.MeshStandardMaterial({
                color: accentColor,
                metalness: 0.7,
                roughness: 0.3,
                emissive: accentColor,
                emissiveIntensity: 0.15
            });
            [[-10, 5], [10, 5]].forEach(([x, y]) => {
                const stripe = new THREE.Mesh(stripeGeom, stripeMat);
                stripe.position.set(x, y, 0);
                group.add(stripe);
            });

            // Sensor domes
            const sensorDomeGeom = new THREE.SphereGeometry(2, 12, 12, 0, Math.PI * 2, 0, Math.PI / 2);
            const sensorDomeMat = new THREE.MeshStandardMaterial({
                color: 0x222222,
                metalness: 0.95,
                roughness: 0.1
            });
            [[-8, 1, -25], [8, 1, -25], [0, 1, 25]].forEach(([x, y, z]) => {
                const dome = new THREE.Mesh(sensorDomeGeom, sensorDomeMat);
                dome.position.set(x, y, z);
                dome.rotation.x = Math.PI;
                group.add(dome);
            });

            // SCALE DOWN THE PLAYER SHIP
            group.scale.set(SHIP_SCALE, SHIP_SCALE, SHIP_SCALE);

            // Set high render order so player renders above stations
            group.renderOrder = 100;
            group.traverse(child => {
                if (child.isMesh) {
                    child.renderOrder = 100;
                }
            });

            return group;
        }

        // ============================================================
        // EV:O STYLE ENEMY SHIPS - FACTION-SPECIFIC DESIGNS
        // ============================================================

        // Get visual style based on faction
        function getFactionStyle(faction) {
            const styles = {
                // Human Industrial (UE-style) - Blue/Gray
                terranConfederacy: { texture: createUEHullTexture, primary: 0x4a5568, accent: 0x3b82f6, engine: 0x00ffff, emissive: 0x1e3a8a },
                unitedEarth: { texture: createUEHullTexture, primary: 0x4a5568, accent: 0x0ea5e9, engine: 0x00ddff, emissive: 0x1e3a8a },
                bhu: { texture: createUEHullTexture, primary: 0x78716c, accent: 0xfbbf24, engine: 0xffaa00, emissive: 0x854d0e },
                galacticPolice: { texture: createUEHullTexture, primary: 0xf8fafc, accent: 0x3b82f6, engine: 0x60a5fa, emissive: 0x1e40af },
                freeCompanies: { texture: createUEHullTexture, primary: 0x52525b, accent: 0x22c55e, engine: 0x4ade80, emissive: 0x166534 },

                // Katuri - Aggressive Red/Black
                katuri: { texture: createKaturiTexture, primary: 0x7f1d1d, accent: 0xef4444, engine: 0xff4444, emissive: 0xdc2626 },

                // Crescent/Gadzair - Crystal Purple/Teal
                gadzair: { texture: createCrescentTexture, primary: 0x6b21a8, accent: 0x14b8a6, engine: 0xa855f7, emissive: 0x7c3aed },
                simnuvia: { texture: createCrescentTexture, primary: 0x0d9488, accent: 0x06b6d4, engine: 0x22d3ee, emissive: 0x0891b2 },

                // Voinian - Heavy Brown/Rust
                voinian: { texture: createVoinianTexture, primary: 0x78350f, accent: 0xd97706, engine: 0xf59e0b, emissive: 0xb45309 },
                emalgha: { texture: createVoinianTexture, primary: 0x365314, accent: 0x84cc16, engine: 0xa3e635, emissive: 0x4d7c0f },

                // Pirates - Cobbled Gray/Orange
                pirates: { texture: createPirateTexture, primary: 0x374151, accent: 0xf97316, engine: 0xfb923c, emissive: 0xea580c },
                renegades: { texture: createPirateTexture, primary: 0x1f2937, accent: 0xef4444, engine: 0xf87171, emissive: 0xb91c1c },

                // Miranu - Golden Traders
                miranu: { texture: createMiranuTexture, primary: 0xd97706, accent: 0xfcd34d, engine: 0xfde68a, emissive: 0xb45309 },

                // Rebels - Red/White
                secondRebellion: { texture: createUEHullTexture, primary: 0x991b1b, accent: 0xffffff, engine: 0xfca5a5, emissive: 0xdc2626 },
                cau: { texture: createUEHullTexture, primary: 0x166534, accent: 0x86efac, engine: 0x4ade80, emissive: 0x22c55e },

                // Alien/Mystery - Green Bioluminescent
                theAliens: { texture: createAlienTexture, primary: 0x064e3b, accent: 0x10b981, engine: 0x34d399, emissive: 0x059669 },
                seti: { texture: createAlienTexture, primary: 0x0c4a6e, accent: 0x0ea5e9, engine: 0x38bdf8, emissive: 0x0284c7 },

                // Other factions
                helionova: { texture: createCrescentTexture, primary: 0x581c87, accent: 0xc084fc, engine: 0xd8b4fe, emissive: 0x7e22ce },
                kliaphin: { texture: createCrescentTexture, primary: 0x4c1d95, accent: 0xa78bfa, engine: 0xc4b5fd, emissive: 0x6d28d9 },
                talramuv: { texture: createMiranuTexture, primary: 0x854d0e, accent: 0xfde047, engine: 0xfef08a, emissive: 0xca8a04 },
                hinwar: { texture: createUEHullTexture, primary: 0x155e75, accent: 0x67e8f9, engine: 0xa5f3fc, emissive: 0x0891b2 }
            };
            return styles[faction] || styles.pirates;
        }

        function createEnemyShip(type = 'fighter', faction = 'pirates') {
            const group = new THREE.Group();
            const style = getFactionStyle(faction);

            // Try to use GLB model first
            const modelName = getModelForFaction(faction, type);
            const glbModel = cloneModel(modelName);

            if (glbModel) {
                // Use the hand-made GLB model
                glbModel.rotation.x = -Math.PI / 2; // Rotate to face forward (nose = -Z)
                glbModel.rotation.z = Math.PI; // Flip to match expected orientation

                // Apply faction colors to the model
                glbModel.traverse((child) => {
                    if (child.isMesh && child.material) {
                        // Tint the material with faction color
                        if (child.material.color) {
                            child.material.color.lerp(new THREE.Color(style.primary), 0.3);
                        }
                        child.material.metalness = 0.7;
                        child.material.roughness = 0.4;
                    }
                });

                // Add engine glow effect with faction color
                const engineGlowGeom = new THREE.SphereGeometry(2.5, 6, 6);
                const engineMat = new THREE.MeshBasicMaterial({
                    color: style.engine,
                    transparent: true,
                    opacity: 0.8
                });
                const engineGlow = new THREE.Mesh(engineGlowGeom, engineMat);
                engineGlow.position.set(0, 0, 20);
                engineGlow.name = 'engineGlow';

                group.add(glbModel);
                group.add(engineGlow);

                // Scale based on ship type
                let scale = SHIP_SCALE;
                if (type === 'heavy') scale *= 1.5;
                if (type === 'boss') scale *= 2.5;
                group.scale.set(scale, scale, scale);

                return group;
            }

            // Fallback to procedural generation if model not loaded
            const hullTexture = style.texture();

            // Material setup based on faction
            const hullMat = new THREE.MeshStandardMaterial({
                map: hullTexture,
                color: style.primary,
                metalness: 0.75,
                roughness: 0.35
            });

            const accentMat = new THREE.MeshStandardMaterial({
                color: style.accent,
                metalness: 0.8,
                roughness: 0.25,
                emissive: style.emissive,
                emissiveIntensity: 0.3
            });

            const engineMat = new THREE.MeshBasicMaterial({
                color: style.engine,
                transparent: true,
                opacity: 0.9
            });

            const darkMat = new THREE.MeshStandardMaterial({
                color: 0x1a1a1a,
                metalness: 0.9,
                roughness: 0.2
            });

            // Determine ship design based on faction category
            const isHuman = ['terranConfederacy', 'unitedEarth', 'secondRebellion', 'cau', 'bhu', 'galacticPolice', 'freeCompanies', 'helionova', 'seti'].includes(faction);
            const isCrescent = ['gadzair', 'simnuvia', 'kliaphin'].includes(faction);
            const isVoinian = ['voinian', 'emalgha'].includes(faction);
            const isAlien = ['theAliens'].includes(faction);
            const isMiranu = ['miranu', 'talramuv', 'hinwar'].includes(faction);
            const isPirate = ['pirates', 'renegades'].includes(faction);
            const isKaturi = ['katuri'].includes(faction);

            if (type === 'fighter') {
                if (isHuman) {
                    // Human Fighter - Industrial military interceptor
                    createHumanFighter(group, hullMat, accentMat, engineMat, darkMat, style);
                } else if (isKaturi) {
                    // Katuri Fighter - Angular aggressive interceptor
                    createKaturiFighter(group, hullMat, accentMat, engineMat, darkMat, style);
                } else if (isCrescent) {
                    // Crescent Fighter - Organic crystal design
                    createCrescentFighter(group, hullMat, accentMat, engineMat, darkMat, style);
                } else if (isVoinian) {
                    // Voinian Fighter - Heavy armored
                    createVoinianFighter(group, hullMat, accentMat, engineMat, darkMat, style);
                } else if (isMiranu) {
                    // Miranu Fighter - Rounded trader escort
                    createMiranuFighter(group, hullMat, accentMat, engineMat, darkMat, style);
                } else if (isAlien) {
                    // Alien Scout - Otherworldly organic
                    createAlienFighter(group, hullMat, accentMat, engineMat, darkMat, style);
                } else {
                    // Pirate Fighter - Cobbled together
                    createPirateFighter(group, hullMat, accentMat, engineMat, darkMat, style);
                }
            } else if (type === 'heavy') {
                if (isHuman) {
                    createHumanHeavy(group, hullMat, accentMat, engineMat, darkMat, style);
                } else if (isKaturi) {
                    createKaturiHeavy(group, hullMat, accentMat, engineMat, darkMat, style);
                } else if (isCrescent) {
                    createCrescentHeavy(group, hullMat, accentMat, engineMat, darkMat, style);
                } else if (isVoinian) {
                    createVoinianHeavy(group, hullMat, accentMat, engineMat, darkMat, style);
                } else if (isMiranu) {
                    createMiranuHeavy(group, hullMat, accentMat, engineMat, darkMat, style);
                } else if (isAlien) {
                    createAlienHeavy(group, hullMat, accentMat, engineMat, darkMat, style);
                } else {
                    createPirateHeavy(group, hullMat, accentMat, engineMat, darkMat, style);
                }
            } else if (type === 'boss') {
                if (isHuman) {
                    createHumanCapital(group, hullMat, accentMat, engineMat, darkMat, style);
                } else if (isKaturi) {
                    createKaturiCapital(group, hullMat, accentMat, engineMat, darkMat, style);
                } else if (isCrescent) {
                    createCrescentCapital(group, hullMat, accentMat, engineMat, darkMat, style);
                } else if (isVoinian) {
                    createVoinianCapital(group, hullMat, accentMat, engineMat, darkMat, style);
                } else if (isAlien) {
                    createAlienCapital(group, hullMat, accentMat, engineMat, darkMat, style);
                } else {
                    createPirateCapital(group, hullMat, accentMat, engineMat, darkMat, style);
                }
            }

            // SCALE DOWN ALL ENEMY SHIPS
            group.scale.set(SHIP_SCALE, SHIP_SCALE, SHIP_SCALE);

            return group;
        }

        // ============================================================
        // HUMAN SHIPS - Industrial/Military Design (UE-style)
        // ============================================================
        function createHumanFighter(group, hullMat, accentMat, engineMat, darkMat, style) {
            // Fuselage - elongated body
            const fuselageGeom = new THREE.BoxGeometry(10, 6, 28);
            const fuselage = new THREE.Mesh(fuselageGeom, hullMat);
            group.add(fuselage);

            // Nose cone
            const noseGeom = new THREE.ConeGeometry(5, 12, 8);
            const nose = new THREE.Mesh(noseGeom, hullMat);
            nose.position.set(0, 0, -18);
            nose.rotation.x = -Math.PI / 2;
            group.add(nose);

            // Nose tip indicator
            const noseTipGeom = new THREE.SphereGeometry(1.5, 8, 8);
            const noseTip = new THREE.Mesh(noseTipGeom, accentMat);
            noseTip.position.set(0, 0, -24);
            group.add(noseTip);

            // Cockpit canopy
            const cockpitGeom = new THREE.SphereGeometry(3, 12, 8, 0, Math.PI * 2, 0, Math.PI / 2);
            const cockpitMat = new THREE.MeshStandardMaterial({
                color: 0x88ddff,
                metalness: 0.9,
                roughness: 0.1,
                transparent: true,
                opacity: 0.7
            });
            const cockpit = new THREE.Mesh(cockpitGeom, cockpitMat);
            cockpit.position.set(0, 4, -8);
            cockpit.scale.set(1, 0.6, 1.4);
            group.add(cockpit);

            // Swept wings
            const wingGeom = new THREE.BoxGeometry(32, 1.5, 12);
            const wings = new THREE.Mesh(wingGeom, hullMat);
            wings.position.set(0, 0, 2);
            group.add(wings);

            // Wing tips
            const wingTipGeom = new THREE.BoxGeometry(4, 1, 6);
            [[-18, 0, -2], [18, 0, -2]].forEach(([x, y, z]) => {
                const tip = new THREE.Mesh(wingTipGeom, accentMat);
                tip.position.set(x, y, z);
                group.add(tip);
            });

            // Gun barrels
            const gunGeom = new THREE.CylinderGeometry(0.8, 1, 12, 6);
            [[-6, 0, -14], [6, 0, -14]].forEach(([x, y, z]) => {
                const gun = new THREE.Mesh(gunGeom, darkMat);
                gun.position.set(x, y, z);
                gun.rotation.x = Math.PI / 2;
                group.add(gun);
            });

            // Engine nacelles
            const engineGeom = new THREE.CylinderGeometry(3, 4, 14, 8);
            [[-8, 0, 12], [8, 0, 12]].forEach(([x, y, z]) => {
                const engine = new THREE.Mesh(engineGeom, hullMat);
                engine.position.set(x, y, z);
                engine.rotation.x = Math.PI / 2;
                group.add(engine);
            });

            // Engine glows
            const glowGeom = new THREE.SphereGeometry(3, 8, 8);
            [[-8, 0, 20], [8, 0, 20]].forEach(([x, y, z]) => {
                const glow = new THREE.Mesh(glowGeom, engineMat);
                glow.position.set(x, y, z);
                group.add(glow);
            });

            // Navigation lights
            const navGeom = new THREE.SphereGeometry(0.6, 6, 6);
            const redMat = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            const greenMat = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
            const redNav = new THREE.Mesh(navGeom, redMat);
            redNav.position.set(-17, 1, 2);
            group.add(redNav);
            const greenNav = new THREE.Mesh(navGeom, greenMat);
            greenNav.position.set(17, 1, 2);
            group.add(greenNav);
        }

        function createHumanHeavy(group, hullMat, accentMat, engineMat, darkMat, style) {
            // Main hull - boxier, heavier
            const hullGeom = new THREE.BoxGeometry(22, 10, 45);
            const hull = new THREE.Mesh(hullGeom, hullMat);
            group.add(hull);

            // Forward section
            const foreGeom = new THREE.BoxGeometry(16, 8, 20);
            const fore = new THREE.Mesh(foreGeom, hullMat);
            fore.position.set(0, 0, -28);
            group.add(fore);

            // Bridge tower
            const bridgeGeom = new THREE.BoxGeometry(10, 8, 12);
            const bridge = new THREE.Mesh(bridgeGeom, hullMat);
            bridge.position.set(0, 9, -10);
            group.add(bridge);

            // Bridge windows
            const windowMat = new THREE.MeshStandardMaterial({
                color: 0x88ddff,
                metalness: 0.9,
                roughness: 0.1,
                transparent: true,
                opacity: 0.6,
                emissive: 0x0088ff,
                emissiveIntensity: 0.3
            });
            const windowGeom = new THREE.BoxGeometry(8, 3, 0.5);
            const windows = new THREE.Mesh(windowGeom, windowMat);
            windows.position.set(0, 12, -16);
            group.add(windows);

            // Wing pylons
            const pylonGeom = new THREE.BoxGeometry(35, 4, 18);
            const pylons = new THREE.Mesh(pylonGeom, hullMat);
            pylons.position.set(0, -3, 5);
            group.add(pylons);

            // Accent stripes
            const stripeGeom = new THREE.BoxGeometry(0.5, 10, 50);
            [[-10, 0, 0], [10, 0, 0]].forEach(([x, y, z]) => {
                const stripe = new THREE.Mesh(stripeGeom, accentMat);
                stripe.position.set(x, y, z);
                group.add(stripe);
            });

            // Turrets
            const turretBaseGeom = new THREE.CylinderGeometry(3, 4, 3, 8);
            const turretGunGeom = new THREE.CylinderGeometry(1, 1.2, 10, 6);
            [[-8, 9, 5], [8, 9, 5], [0, 7, -35]].forEach(([x, y, z]) => {
                const base = new THREE.Mesh(turretBaseGeom, darkMat);
                base.position.set(x, y, z);
                group.add(base);
                const gun = new THREE.Mesh(turretGunGeom, darkMat);
                gun.position.set(x, y + 2, z - 6);
                gun.rotation.x = Math.PI / 2;
                group.add(gun);
            });

            // Engines (quad)
            const engineGeom = new THREE.CylinderGeometry(4, 5, 18, 10);
            [[-12, 0, 30], [12, 0, 30], [-6, -5, 30], [6, -5, 30]].forEach(([x, y, z]) => {
                const engine = new THREE.Mesh(engineGeom, hullMat);
                engine.position.set(x, y, z);
                engine.rotation.x = Math.PI / 2;
                group.add(engine);
                const glow = new THREE.Mesh(new THREE.SphereGeometry(4, 8, 8), engineMat);
                glow.position.set(x, y, z + 10);
                group.add(glow);
            });
        }

        function createHumanCapital(group, hullMat, accentMat, engineMat, darkMat, style) {
            // Main hull - large carrier/cruiser
            const hullGeom = new THREE.BoxGeometry(50, 18, 90);
            const hull = new THREE.Mesh(hullGeom, hullMat);
            group.add(hull);

            // Forward prow
            const prowGeom = new THREE.BoxGeometry(30, 14, 30);
            const prow = new THREE.Mesh(prowGeom, hullMat);
            prow.position.set(0, 0, -55);
            group.add(prow);

            // Command tower
            const towerGeom = new THREE.BoxGeometry(20, 20, 25);
            const tower = new THREE.Mesh(towerGeom, hullMat);
            tower.position.set(0, 18, -20);
            group.add(tower);

            // Tower bridge
            const bridgeWindowGeom = new THREE.BoxGeometry(18, 6, 1);
            const windowMat = new THREE.MeshStandardMaterial({
                color: 0x88ddff,
                metalness: 0.9,
                roughness: 0.1,
                transparent: true,
                opacity: 0.6,
                emissive: 0x0088ff,
                emissiveIntensity: 0.4
            });
            const bridgeWindow = new THREE.Mesh(bridgeWindowGeom, windowMat);
            bridgeWindow.position.set(0, 25, -32);
            group.add(bridgeWindow);

            // Wing/hangar sections
            const wingGeom = new THREE.BoxGeometry(40, 10, 50);
            [[-45, -4, 10], [45, -4, 10]].forEach(([x, y, z]) => {
                const wing = new THREE.Mesh(wingGeom, hullMat);
                wing.position.set(x, y, z);
                group.add(wing);
            });

            // Accent stripes
            const stripeGeom = new THREE.BoxGeometry(1, 18, 100);
            [[-24, 0, 0], [24, 0, 0]].forEach(([x, y, z]) => {
                const stripe = new THREE.Mesh(stripeGeom, accentMat);
                stripe.position.set(x, y, z);
                group.add(stripe);
            });

            // Heavy weapon batteries
            const batteryGeom = new THREE.CylinderGeometry(4, 5, 18, 8);
            [[-35, 8, -30], [35, 8, -30], [-35, 8, 20], [35, 8, 20], [0, 15, -60]].forEach(([x, y, z]) => {
                const battery = new THREE.Mesh(batteryGeom, darkMat);
                battery.position.set(x, y, z);
                group.add(battery);
            });

            // Main engines (6)
            const engineGeom = new THREE.CylinderGeometry(7, 9, 25, 12);
            [[-20, 0, 55], [0, 0, 55], [20, 0, 55], [-45, -4, 45], [45, -4, 45], [0, -8, 55]].forEach(([x, y, z]) => {
                const engine = new THREE.Mesh(engineGeom, hullMat);
                engine.position.set(x, y, z);
                engine.rotation.x = Math.PI / 2;
                group.add(engine);
                const glow = new THREE.Mesh(new THREE.SphereGeometry(7, 10, 10), engineMat);
                glow.position.set(x, y, z + 14);
                group.add(glow);
            });
        }

        // ============================================================
        // KATURI SHIPS - Angular, Aggressive (Red/Black)
        // ============================================================
        function createKaturiFighter(group, hullMat, accentMat, engineMat, darkMat, style) {
            // Angular main body - diamond/dart shape
            const bodyShape = new THREE.Shape();
            bodyShape.moveTo(0, -20);
            bodyShape.lineTo(8, 0);
            bodyShape.lineTo(5, 15);
            bodyShape.lineTo(-5, 15);
            bodyShape.lineTo(-8, 0);
            bodyShape.closePath();

            const bodyGeom = new THREE.ExtrudeGeometry(bodyShape, {
                steps: 1, depth: 8, bevelEnabled: true, bevelThickness: 2, bevelSize: 1
            });
            const body = new THREE.Mesh(bodyGeom, hullMat);
            body.rotation.x = -Math.PI / 2;
            body.position.y = 4;
            group.add(body);

            // Sharp nose spike
            const spikeGeom = new THREE.ConeGeometry(2, 15, 4);
            const spike = new THREE.Mesh(spikeGeom, accentMat);
            spike.position.set(0, 4, -28);
            spike.rotation.x = -Math.PI / 2;
            group.add(spike);

            // Angular swept wings
            const wingShape = new THREE.Shape();
            wingShape.moveTo(0, 0);
            wingShape.lineTo(25, -8);
            wingShape.lineTo(30, -5);
            wingShape.lineTo(28, 5);
            wingShape.lineTo(5, 8);
            wingShape.closePath();

            const wingGeom = new THREE.ExtrudeGeometry(wingShape, {
                steps: 1, depth: 1.5, bevelEnabled: false
            });

            const leftWing = new THREE.Mesh(wingGeom, hullMat);
            leftWing.position.set(-5, 4, 5);
            leftWing.rotation.x = -Math.PI / 2;
            leftWing.rotation.z = Math.PI;
            group.add(leftWing);

            const rightWing = new THREE.Mesh(wingGeom, hullMat);
            rightWing.position.set(5, 4, 5);
            rightWing.rotation.x = -Math.PI / 2;
            rightWing.scale.x = -1;
            group.add(rightWing);

            // Energy cannons on wing tips
            const cannonGeom = new THREE.CylinderGeometry(1.5, 2, 14, 6);
            [[-28, 4, -2], [28, 4, -2]].forEach(([x, y, z]) => {
                const cannon = new THREE.Mesh(cannonGeom, accentMat);
                cannon.position.set(x, y, z);
                cannon.rotation.x = Math.PI / 2;
                group.add(cannon);
            });

            // Central engine
            const engineGeom = new THREE.ConeGeometry(4, 10, 6);
            const engine = new THREE.Mesh(engineGeom, darkMat);
            engine.position.set(0, 4, 18);
            engine.rotation.x = Math.PI / 2;
            group.add(engine);

            // Engine glow
            const glow = new THREE.Mesh(new THREE.SphereGeometry(4, 8, 8), engineMat);
            glow.position.set(0, 4, 22);
            group.add(glow);

            // Aggressive cockpit
            const cockpitGeom = new THREE.BoxGeometry(4, 3, 8);
            const cockpitMat = new THREE.MeshStandardMaterial({
                color: 0xff4444,
                metalness: 0.8,
                roughness: 0.2,
                transparent: true,
                opacity: 0.7
            });
            const cockpit = new THREE.Mesh(cockpitGeom, cockpitMat);
            cockpit.position.set(0, 7, -10);
            group.add(cockpit);
        }

        function createKaturiHeavy(group, hullMat, accentMat, engineMat, darkMat, style) {
            // Aggressive angular hull
            const hullGeom = new THREE.BoxGeometry(25, 12, 50);
            const hull = new THREE.Mesh(hullGeom, hullMat);
            group.add(hull);

            // Forward spike prow
            const prowGeom = new THREE.ConeGeometry(10, 25, 4);
            const prow = new THREE.Mesh(prowGeom, hullMat);
            prow.position.set(0, 0, -35);
            prow.rotation.x = -Math.PI / 2;
            group.add(prow);

            // Blade wings
            const bladeGeom = new THREE.BoxGeometry(45, 3, 30);
            const blades = new THREE.Mesh(bladeGeom, hullMat);
            blades.position.set(0, 0, 5);
            blades.rotation.z = 0.1;
            group.add(blades);

            // Wing blades (sharp edges)
            const edgeGeom = new THREE.BoxGeometry(50, 1, 5);
            const edges = new THREE.Mesh(edgeGeom, accentMat);
            edges.position.set(0, 2, -8);
            group.add(edges);

            // Heavy weapon pods
            const podGeom = new THREE.BoxGeometry(8, 6, 20);
            [[-18, 5, -15], [18, 5, -15]].forEach(([x, y, z]) => {
                const pod = new THREE.Mesh(podGeom, darkMat);
                pod.position.set(x, y, z);
                group.add(pod);
                // Cannon
                const cannon = new THREE.Mesh(new THREE.CylinderGeometry(2, 2.5, 18, 6), darkMat);
                cannon.position.set(x, y, z - 15);
                cannon.rotation.x = Math.PI / 2;
                group.add(cannon);
            });

            // Triple engines
            const engineGeom = new THREE.CylinderGeometry(5, 6, 15, 8);
            [[-10, 0, 32], [0, 0, 35], [10, 0, 32]].forEach(([x, y, z]) => {
                const engine = new THREE.Mesh(engineGeom, darkMat);
                engine.position.set(x, y, z);
                engine.rotation.x = Math.PI / 2;
                group.add(engine);
                const glow = new THREE.Mesh(new THREE.SphereGeometry(5, 8, 8), engineMat);
                glow.position.set(x, y, z + 8);
                group.add(glow);
            });
        }

        function createKaturiCapital(group, hullMat, accentMat, engineMat, darkMat, style) {
            // Massive angular dreadnought
            const hullGeom = new THREE.BoxGeometry(60, 20, 100);
            const hull = new THREE.Mesh(hullGeom, hullMat);
            group.add(hull);

            // Aggressive prow
            const prowGeom = new THREE.ConeGeometry(25, 50, 4);
            const prow = new THREE.Mesh(prowGeom, hullMat);
            prow.position.set(0, 0, -70);
            prow.rotation.x = -Math.PI / 2;
            group.add(prow);

            // Blade wing extensions
            const wingGeom = new THREE.BoxGeometry(80, 5, 60);
            const wings = new THREE.Mesh(wingGeom, hullMat);
            wings.position.set(0, 0, 10);
            group.add(wings);

            // Weapon spines
            const spineGeom = new THREE.CylinderGeometry(3, 4, 30, 6);
            [[-30, 10, -40], [30, 10, -40], [-30, 10, 10], [30, 10, 10], [0, 12, -80]].forEach(([x, y, z]) => {
                const spine = new THREE.Mesh(spineGeom, accentMat);
                spine.position.set(x, y, z);
                group.add(spine);
            });

            // Massive engines
            const engineGeom = new THREE.CylinderGeometry(10, 12, 30, 10);
            [[-25, 0, 60], [0, 0, 65], [25, 0, 60], [-40, -5, 55], [40, -5, 55]].forEach(([x, y, z]) => {
                const engine = new THREE.Mesh(engineGeom, darkMat);
                engine.position.set(x, y, z);
                engine.rotation.x = Math.PI / 2;
                group.add(engine);
                const glow = new THREE.Mesh(new THREE.SphereGeometry(10, 10, 10), engineMat);
                glow.position.set(x, y, z + 16);
                group.add(glow);
            });
        }

        // ============================================================
        // CRESCENT SHIPS - Organic Crystal Design (Purple/Teal)
        // ============================================================
        function createCrescentFighter(group, hullMat, accentMat, engineMat, darkMat, style) {
            // Organic curved body
            const bodyGeom = new THREE.SphereGeometry(8, 12, 8);
            const body = new THREE.Mesh(bodyGeom, hullMat);
            body.scale.set(1, 0.6, 2);
            group.add(body);

            // Crystal nose
            const noseGeom = new THREE.OctahedronGeometry(5, 0);
            const nose = new THREE.Mesh(noseGeom, accentMat);
            nose.position.set(0, 0, -18);
            nose.scale.set(0.6, 0.6, 1.5);
            group.add(nose);

            // Flowing wing curves (using torus segments)
            const wingGeom = new THREE.TorusGeometry(18, 2, 8, 16, Math.PI * 0.6);
            const wingMat = hullMat.clone();

            const leftWing = new THREE.Mesh(wingGeom, wingMat);
            leftWing.position.set(-5, 0, 3);
            leftWing.rotation.x = Math.PI / 2;
            leftWing.rotation.z = -0.3;
            group.add(leftWing);

            const rightWing = new THREE.Mesh(wingGeom, wingMat);
            rightWing.position.set(5, 0, 3);
            rightWing.rotation.x = Math.PI / 2;
            rightWing.rotation.z = Math.PI + 0.3;
            group.add(rightWing);

            // Crystal weapon pods
            const crystalGeom = new THREE.OctahedronGeometry(3, 0);
            [[-20, 0, 0], [20, 0, 0]].forEach(([x, y, z]) => {
                const crystal = new THREE.Mesh(crystalGeom, accentMat);
                crystal.position.set(x, y, z);
                group.add(crystal);
            });

            // Organic engine nacelle
            const engineGeom = new THREE.SphereGeometry(4, 10, 10);
            const engine = new THREE.Mesh(engineGeom, hullMat);
            engine.position.set(0, 0, 14);
            engine.scale.set(1, 1, 1.5);
            group.add(engine);

            // Engine glow (purple/teal)
            const glow = new THREE.Mesh(new THREE.SphereGeometry(3, 8, 8), engineMat);
            glow.position.set(0, 0, 20);
            group.add(glow);
        }

        function createCrescentHeavy(group, hullMat, accentMat, engineMat, darkMat, style) {
            // Flowing organic hull
            const hullGeom = new THREE.SphereGeometry(15, 16, 12);
            const hull = new THREE.Mesh(hullGeom, hullMat);
            hull.scale.set(1.2, 0.7, 2.5);
            group.add(hull);

            // Crystal spires
            const spireGeom = new THREE.ConeGeometry(3, 20, 6);
            [[0, 8, -20], [-12, 6, -10], [12, 6, -10]].forEach(([x, y, z]) => {
                const spire = new THREE.Mesh(spireGeom, accentMat);
                spire.position.set(x, y, z);
                spire.rotation.x = -0.3;
                group.add(spire);
            });

            // Sweeping wing arcs
            const arcGeom = new THREE.TorusGeometry(25, 3, 8, 20, Math.PI * 0.7);
            [1, -1].forEach(side => {
                const arc = new THREE.Mesh(arcGeom, hullMat);
                arc.position.set(side * 8, 0, 5);
                arc.rotation.x = Math.PI / 2;
                arc.rotation.z = side > 0 ? -0.4 : Math.PI + 0.4;
                group.add(arc);
            });

            // Crystal nodes
            const nodeGeom = new THREE.IcosahedronGeometry(5, 0);
            [[-22, 0, 8], [22, 0, 8], [0, 10, 0]].forEach(([x, y, z]) => {
                const node = new THREE.Mesh(nodeGeom, accentMat);
                node.position.set(x, y, z);
                group.add(node);
            });

            // Twin organic engines
            const engineGeom = new THREE.SphereGeometry(6, 10, 10);
            [[-10, 0, 30], [10, 0, 30]].forEach(([x, y, z]) => {
                const engine = new THREE.Mesh(engineGeom, hullMat);
                engine.position.set(x, y, z);
                engine.scale.set(1, 1, 1.5);
                group.add(engine);
                const glow = new THREE.Mesh(new THREE.SphereGeometry(5, 8, 8), engineMat);
                glow.position.set(x, y, z + 8);
                group.add(glow);
            });
        }

        function createCrescentCapital(group, hullMat, accentMat, engineMat, darkMat, style) {
            // Massive organic form
            const hullGeom = new THREE.SphereGeometry(35, 20, 16);
            const hull = new THREE.Mesh(hullGeom, hullMat);
            hull.scale.set(1.3, 0.6, 2.5);
            group.add(hull);

            // Grand crystal spire (command)
            const spireGeom = new THREE.ConeGeometry(8, 40, 8);
            const spire = new THREE.Mesh(spireGeom, accentMat);
            spire.position.set(0, 25, -30);
            group.add(spire);

            // Sweeping organic wing extensions
            const wingGeom = new THREE.TorusGeometry(50, 6, 10, 24, Math.PI * 0.6);
            [1, -1].forEach(side => {
                const wing = new THREE.Mesh(wingGeom, hullMat);
                wing.position.set(side * 15, 0, 10);
                wing.rotation.x = Math.PI / 2;
                wing.rotation.z = side > 0 ? -0.3 : Math.PI + 0.3;
                group.add(wing);
            });

            // Major crystal formations
            const crystalGeom = new THREE.OctahedronGeometry(12, 0);
            [[-40, 5, 15], [40, 5, 15], [0, 15, -50], [-30, 10, -30], [30, 10, -30]].forEach(([x, y, z]) => {
                const crystal = new THREE.Mesh(crystalGeom, accentMat);
                crystal.position.set(x, y, z);
                group.add(crystal);
            });

            // Multiple organic engines
            const engineGeom = new THREE.SphereGeometry(10, 12, 12);
            [[-25, 0, 70], [0, 0, 75], [25, 0, 70], [-40, -5, 60], [40, -5, 60]].forEach(([x, y, z]) => {
                const engine = new THREE.Mesh(engineGeom, hullMat);
                engine.position.set(x, y, z);
                engine.scale.set(1, 1, 1.5);
                group.add(engine);
                const glow = new THREE.Mesh(new THREE.SphereGeometry(9, 10, 10), engineMat);
                glow.position.set(x, y, z + 12);
                group.add(glow);
            });
        }

        // ============================================================
        // VOINIAN SHIPS - Heavy Armored (Brown/Rust)
        // ============================================================
        function createVoinianFighter(group, hullMat, accentMat, engineMat, darkMat, style) {
            // Blocky armored body
            const bodyGeom = new THREE.BoxGeometry(12, 8, 25);
            const body = new THREE.Mesh(bodyGeom, hullMat);
            group.add(body);

            // Armor plates (layered)
            const plateGeom = new THREE.BoxGeometry(14, 2, 20);
            [4, -4].forEach(y => {
                const plate = new THREE.Mesh(plateGeom, hullMat);
                plate.position.set(0, y, 0);
                group.add(plate);
            });

            // Blunt nose
            const noseGeom = new THREE.BoxGeometry(10, 6, 8);
            const nose = new THREE.Mesh(noseGeom, hullMat);
            nose.position.set(0, 0, -15);
            group.add(nose);

            // Heavy weapon mount
            const gunGeom = new THREE.CylinderGeometry(2, 2.5, 15, 8);
            const gun = new THREE.Mesh(gunGeom, darkMat);
            gun.position.set(0, 0, -22);
            gun.rotation.x = Math.PI / 2;
            group.add(gun);

            // Stubby wings with armor
            const wingGeom = new THREE.BoxGeometry(20, 4, 15);
            const wings = new THREE.Mesh(wingGeom, hullMat);
            wings.position.set(0, 0, 0);
            group.add(wings);

            // Wing armor bolts (visual detail)
            const boltGeom = new THREE.CylinderGeometry(0.8, 0.8, 1, 6);
            [[-8, 2.5, -5], [-8, 2.5, 5], [8, 2.5, -5], [8, 2.5, 5]].forEach(([x, y, z]) => {
                const bolt = new THREE.Mesh(boltGeom, accentMat);
                bolt.position.set(x, y, z);
                group.add(bolt);
            });

            // Single heavy engine
            const engineGeom = new THREE.BoxGeometry(8, 6, 10);
            const engine = new THREE.Mesh(engineGeom, darkMat);
            engine.position.set(0, 0, 16);
            group.add(engine);

            const glow = new THREE.Mesh(new THREE.BoxGeometry(6, 4, 2), engineMat);
            glow.position.set(0, 0, 22);
            group.add(glow);
        }

        function createVoinianHeavy(group, hullMat, accentMat, engineMat, darkMat, style) {
            // Massive armored hull
            const hullGeom = new THREE.BoxGeometry(30, 15, 55);
            const hull = new THREE.Mesh(hullGeom, hullMat);
            group.add(hull);

            // Layered armor plating
            for (let i = 0; i < 3; i++) {
                const plateGeom = new THREE.BoxGeometry(32 - i * 2, 3, 50 - i * 5);
                const plate = new THREE.Mesh(plateGeom, hullMat);
                plate.position.set(0, 8 + i * 3, i * 2);
                group.add(plate);
            }

            // Heavy forward ram
            const ramGeom = new THREE.BoxGeometry(20, 12, 25);
            const ram = new THREE.Mesh(ramGeom, hullMat);
            ram.position.set(0, 0, -35);
            group.add(ram);

            // Turret hardpoints
            const turretGeom = new THREE.BoxGeometry(6, 6, 8);
            [[-12, 12, -10], [12, 12, -10], [-12, 12, 15], [12, 12, 15]].forEach(([x, y, z]) => {
                const turret = new THREE.Mesh(turretGeom, darkMat);
                turret.position.set(x, y, z);
                group.add(turret);
                const gun = new THREE.Mesh(new THREE.CylinderGeometry(1.5, 2, 12, 6), darkMat);
                gun.position.set(x, y + 3, z - 8);
                gun.rotation.x = Math.PI / 2;
                group.add(gun);
            });

            // Dual heavy engines
            const engineGeom = new THREE.BoxGeometry(10, 10, 15);
            [[-12, 0, 32], [12, 0, 32]].forEach(([x, y, z]) => {
                const engine = new THREE.Mesh(engineGeom, darkMat);
                engine.position.set(x, y, z);
                group.add(engine);
                const glow = new THREE.Mesh(new THREE.BoxGeometry(8, 8, 3), engineMat);
                glow.position.set(x, y, z + 10);
                group.add(glow);
            });
        }

        function createVoinianCapital(group, hullMat, accentMat, engineMat, darkMat, style) {
            // Massive armored dreadnought
            const hullGeom = new THREE.BoxGeometry(70, 25, 110);
            const hull = new THREE.Mesh(hullGeom, hullMat);
            group.add(hull);

            // Multiple armor layers
            for (let i = 0; i < 4; i++) {
                const plateGeom = new THREE.BoxGeometry(72 - i * 3, 4, 100 - i * 8);
                const plate = new THREE.Mesh(plateGeom, hullMat);
                plate.position.set(0, 13 + i * 4, i * 3);
                group.add(plate);
            }

            // Armored command citadel
            const citadelGeom = new THREE.BoxGeometry(30, 20, 35);
            const citadel = new THREE.Mesh(citadelGeom, hullMat);
            citadel.position.set(0, 22, -20);
            group.add(citadel);

            // Heavy weapon batteries
            const batteryGeom = new THREE.BoxGeometry(10, 10, 15);
            [[-30, 15, -40], [30, 15, -40], [-30, 15, 10], [30, 15, 10], [0, 22, -50]].forEach(([x, y, z]) => {
                const battery = new THREE.Mesh(batteryGeom, darkMat);
                battery.position.set(x, y, z);
                group.add(battery);
                const gun = new THREE.Mesh(new THREE.CylinderGeometry(3, 4, 20, 8), darkMat);
                gun.position.set(x, y + 5, z - 15);
                gun.rotation.x = Math.PI / 2;
                group.add(gun);
            });

            // Massive engines
            const engineGeom = new THREE.BoxGeometry(15, 15, 20);
            [[-25, 0, 60], [0, 0, 65], [25, 0, 60], [-35, -8, 55], [35, -8, 55]].forEach(([x, y, z]) => {
                const engine = new THREE.Mesh(engineGeom, darkMat);
                engine.position.set(x, y, z);
                group.add(engine);
                const glow = new THREE.Mesh(new THREE.BoxGeometry(12, 12, 4), engineMat);
                glow.position.set(x, y, z + 12);
                group.add(glow);
            });
        }

        // ============================================================
        // PIRATE SHIPS - Cobbled Together (Gray/Orange)
        // ============================================================
        function createPirateFighter(group, hullMat, accentMat, engineMat, darkMat, style) {
            // Asymmetric cobbled body
            const bodyGeom = new THREE.BoxGeometry(10, 7, 22);
            const body = new THREE.Mesh(bodyGeom, hullMat);
            body.rotation.z = 0.1; // Slightly crooked
            group.add(body);

            // Mismatched nose
            const noseGeom = new THREE.ConeGeometry(4, 12, 6);
            const nose = new THREE.Mesh(noseGeom, hullMat);
            nose.position.set(0.5, 0, -15);
            nose.rotation.x = -Math.PI / 2;
            nose.rotation.z = 0.15;
            group.add(nose);

            // Salvaged wings (different sizes)
            const leftWingGeom = new THREE.BoxGeometry(18, 2, 10);
            const leftWing = new THREE.Mesh(leftWingGeom, hullMat);
            leftWing.position.set(-12, 0, 2);
            leftWing.rotation.z = -0.15;
            group.add(leftWing);

            const rightWingGeom = new THREE.BoxGeometry(15, 2, 8);
            const rightWing = new THREE.Mesh(rightWingGeom, hullMat);
            rightWing.position.set(10, 1, 0);
            rightWing.rotation.z = 0.1;
            group.add(rightWing);

            // Bolted-on weapons
            const gunGeom = new THREE.CylinderGeometry(1, 1.5, 10, 6);
            [[-8, 1, -8], [7, 2, -6]].forEach(([x, y, z]) => {
                const gun = new THREE.Mesh(gunGeom, darkMat);
                gun.position.set(x, y, z);
                gun.rotation.x = Math.PI / 2;
                gun.rotation.z = (Math.random() - 0.5) * 0.2;
                group.add(gun);
            });

            // Weld marks (accent stripes)
            const weldGeom = new THREE.BoxGeometry(12, 0.5, 0.5);
            [[0, 4, 0], [0, -4, 5]].forEach(([x, y, z]) => {
                const weld = new THREE.Mesh(weldGeom, accentMat);
                weld.position.set(x, y, z);
                weld.rotation.z = Math.random() * 0.3;
                group.add(weld);
            });

            // Mismatched engines
            const engine1Geom = new THREE.CylinderGeometry(3, 3.5, 8, 6);
            const engine1 = new THREE.Mesh(engine1Geom, darkMat);
            engine1.position.set(-4, 0, 14);
            engine1.rotation.x = Math.PI / 2;
            group.add(engine1);

            const engine2Geom = new THREE.BoxGeometry(5, 4, 6);
            const engine2 = new THREE.Mesh(engine2Geom, darkMat);
            engine2.position.set(4, 1, 13);
            group.add(engine2);

            // Engine glows
            [[-4, 0, 19], [4, 1, 17]].forEach(([x, y, z]) => {
                const glow = new THREE.Mesh(new THREE.SphereGeometry(2.5, 6, 6), engineMat);
                glow.position.set(x, y, z);
                group.add(glow);
            });
        }

        function createPirateHeavy(group, hullMat, accentMat, engineMat, darkMat, style) {
            // Frankenstein hull from multiple ships
            const mainGeom = new THREE.BoxGeometry(25, 12, 40);
            const main = new THREE.Mesh(mainGeom, hullMat);
            main.rotation.z = 0.05;
            group.add(main);

            // Bolted-on sections
            const section1Geom = new THREE.BoxGeometry(15, 10, 18);
            const section1 = new THREE.Mesh(section1Geom, hullMat);
            section1.position.set(-8, 3, -25);
            section1.rotation.y = 0.1;
            group.add(section1);

            const section2Geom = new THREE.BoxGeometry(12, 8, 15);
            const section2 = new THREE.Mesh(section2Geom, hullMat);
            section2.position.set(10, -2, -20);
            group.add(section2);

            // Salvaged weapons everywhere
            const gunGeom = new THREE.CylinderGeometry(1.5, 2, 12, 6);
            [[-15, 8, -10], [12, 6, -15], [-10, -4, -20], [8, 8, 5], [-12, 8, 10]].forEach(([x, y, z]) => {
                const gun = new THREE.Mesh(gunGeom, darkMat);
                gun.position.set(x, y, z);
                gun.rotation.x = Math.PI / 2 + (Math.random() - 0.5) * 0.2;
                gun.rotation.z = (Math.random() - 0.5) * 0.2;
                group.add(gun);
            });

            // Weld seams
            const weldGeom = new THREE.BoxGeometry(30, 0.8, 0.8);
            [[0, 6, -5], [0, -6, 10], [-5, 0, -15]].forEach(([x, y, z]) => {
                const weld = new THREE.Mesh(weldGeom, accentMat);
                weld.position.set(x, y, z);
                weld.rotation.y = Math.random() * 0.5;
                weld.rotation.z = Math.random() * 0.3;
                group.add(weld);
            });

            // Multiple salvaged engines
            [[-10, -3, 25], [10, 0, 23], [0, 5, 28]].forEach(([x, y, z], i) => {
                const engineGeom = i % 2 === 0 ?
                    new THREE.CylinderGeometry(4, 5, 12, 8) :
                    new THREE.BoxGeometry(8, 7, 10);
                const engine = new THREE.Mesh(engineGeom, darkMat);
                engine.position.set(x, y, z);
                if (i % 2 === 0) engine.rotation.x = Math.PI / 2;
                group.add(engine);

                const glow = new THREE.Mesh(new THREE.SphereGeometry(3.5, 6, 6), engineMat);
                glow.position.set(x, y, z + 8);
                group.add(glow);
            });
        }

        function createPirateCapital(group, hullMat, accentMat, engineMat, darkMat, style) {
            // Massive cobbled dreadnought
            const mainGeom = new THREE.BoxGeometry(55, 20, 85);
            const main = new THREE.Mesh(mainGeom, hullMat);
            main.rotation.z = 0.03;
            group.add(main);

            // Multiple welded-on sections
            const sectGeom1 = new THREE.BoxGeometry(30, 15, 30);
            const sect1 = new THREE.Mesh(sectGeom1, hullMat);
            sect1.position.set(-20, 5, -45);
            sect1.rotation.y = 0.1;
            group.add(sect1);

            const sectGeom2 = new THREE.BoxGeometry(25, 18, 25);
            const sect2 = new THREE.Mesh(sectGeom2, hullMat);
            sect2.position.set(22, -3, -40);
            sect2.rotation.y = -0.08;
            group.add(sect2);

            // Scavenged command tower
            const towerGeom = new THREE.BoxGeometry(20, 15, 20);
            const tower = new THREE.Mesh(towerGeom, hullMat);
            tower.position.set(0, 17, -15);
            tower.rotation.z = 0.05;
            group.add(tower);

            // Lots of welded weapons
            const bigGunGeom = new THREE.CylinderGeometry(3, 4, 20, 8);
            [[-25, 12, -30], [25, 15, -35], [-30, 10, 10], [28, 8, 15], [0, 20, -50],
            [-35, 5, -20], [35, 2, -25]].forEach(([x, y, z]) => {
                const gun = new THREE.Mesh(bigGunGeom, darkMat);
                gun.position.set(x, y, z);
                gun.rotation.x = Math.PI / 2 + (Math.random() - 0.5) * 0.15;
                gun.rotation.z = (Math.random() - 0.5) * 0.15;
                group.add(gun);
            });

            // Weld seams everywhere
            const weldGeom = new THREE.BoxGeometry(60, 1, 1);
            for (let i = 0; i < 8; i++) {
                const weld = new THREE.Mesh(weldGeom, accentMat);
                weld.position.set(
                    (Math.random() - 0.5) * 20,
                    (Math.random() - 0.5) * 20,
                    (Math.random() - 0.5) * 60
                );
                weld.rotation.y = Math.random() * Math.PI;
                weld.rotation.z = Math.random() * 0.5;
                group.add(weld);
            }

            // Multiple salvaged engines
            [[-22, 0, 50], [22, 0, 48], [0, 5, 55], [-30, -8, 45], [30, -8, 43], [0, -10, 52]].forEach(([x, y, z], i) => {
                const engineGeom = i % 2 === 0 ?
                    new THREE.CylinderGeometry(7, 8, 18, 8) :
                    new THREE.BoxGeometry(12, 12, 15);
                const engine = new THREE.Mesh(engineGeom, darkMat);
                engine.position.set(x, y, z);
                if (i % 2 === 0) engine.rotation.x = Math.PI / 2;
                group.add(engine);

                const glow = new THREE.Mesh(new THREE.SphereGeometry(6, 8, 8), engineMat);
                glow.position.set(x, y, z + 12);
                group.add(glow);
            });
        }

        // ============================================================
        // MIRANU SHIPS - Rounded Traders (Gold)
        // ============================================================
        function createMiranuFighter(group, hullMat, accentMat, engineMat, darkMat, style) {
            // Rounded peaceful design
            const bodyGeom = new THREE.SphereGeometry(8, 12, 10);
            const body = new THREE.Mesh(bodyGeom, hullMat);
            body.scale.set(1, 0.7, 1.5);
            group.add(body);

            // Smooth nose
            const noseGeom = new THREE.SphereGeometry(4, 10, 8);
            const nose = new THREE.Mesh(noseGeom, hullMat);
            nose.position.set(0, 0, -14);
            nose.scale.set(1, 0.8, 1.5);
            group.add(nose);

            // Rounded wings
            const wingGeom = new THREE.SphereGeometry(10, 10, 8);
            [[-10, 0, 0], [10, 0, 0]].forEach(([x, y, z]) => {
                const wing = new THREE.Mesh(wingGeom, hullMat);
                wing.position.set(x, y, z);
                wing.scale.set(1.2, 0.3, 0.8);
                group.add(wing);
            });

            // Decorative gold bands
            const bandGeom = new THREE.TorusGeometry(8, 0.5, 8, 16);
            [[-5, 0], [5, 0]].forEach(([z, _]) => {
                const band = new THREE.Mesh(bandGeom, accentMat);
                band.position.set(0, 0, z);
                band.rotation.y = Math.PI / 2;
                group.add(band);
            });

            // Small defensive weapon
            const gunGeom = new THREE.CylinderGeometry(0.8, 1, 8, 6);
            const gun = new THREE.Mesh(gunGeom, darkMat);
            gun.position.set(0, 2, -12);
            gun.rotation.x = Math.PI / 2;
            group.add(gun);

            // Smooth engine pod
            const engineGeom = new THREE.SphereGeometry(4, 10, 8);
            const engine = new THREE.Mesh(engineGeom, hullMat);
            engine.position.set(0, 0, 12);
            engine.scale.set(1, 1, 1.3);
            group.add(engine);

            const glow = new THREE.Mesh(new THREE.SphereGeometry(3, 8, 8), engineMat);
            glow.position.set(0, 0, 18);
            group.add(glow);
        }

        function createMiranuHeavy(group, hullMat, accentMat, engineMat, darkMat, style) {
            // Large cargo hauler / escort
            const hullGeom = new THREE.SphereGeometry(18, 16, 12);
            const hull = new THREE.Mesh(hullGeom, hullMat);
            hull.scale.set(1, 0.7, 2);
            group.add(hull);

            // Cargo pods
            const cargoGeom = new THREE.SphereGeometry(8, 10, 8);
            [[-15, -5, 0], [15, -5, 0]].forEach(([x, y, z]) => {
                const cargo = new THREE.Mesh(cargoGeom, hullMat);
                cargo.position.set(x, y, z);
                cargo.scale.set(1, 1, 1.5);
                group.add(cargo);
            });

            // Decorative rings
            const ringGeom = new THREE.TorusGeometry(15, 1, 8, 20);
            [[-15, 0], [0, 0], [15, 0]].forEach(([z, _]) => {
                const ring = new THREE.Mesh(ringGeom, accentMat);
                ring.position.set(0, 0, z);
                ring.rotation.y = Math.PI / 2;
                group.add(ring);
            });

            // Bridge dome
            const bridgeGeom = new THREE.SphereGeometry(6, 10, 8, 0, Math.PI * 2, 0, Math.PI / 2);
            const bridge = new THREE.Mesh(bridgeGeom, accentMat);
            bridge.position.set(0, 10, -15);
            group.add(bridge);

            // Engines
            const engineGeom = new THREE.SphereGeometry(5, 10, 8);
            [[-12, 0, 35], [12, 0, 35]].forEach(([x, y, z]) => {
                const engine = new THREE.Mesh(engineGeom, hullMat);
                engine.position.set(x, y, z);
                engine.scale.set(1, 1, 1.5);
                group.add(engine);
                const glow = new THREE.Mesh(new THREE.SphereGeometry(4, 8, 8), engineMat);
                glow.position.set(x, y, z + 8);
                group.add(glow);
            });
        }

        // ============================================================
        // ALIEN SHIPS - Otherworldly Organic (Green)
        // ============================================================
        function createAlienFighter(group, hullMat, accentMat, engineMat, darkMat, style) {
            // Organic bulbous body
            const bodyGeom = new THREE.SphereGeometry(7, 12, 10);
            const body = new THREE.Mesh(bodyGeom, hullMat);
            body.scale.set(1, 0.8, 1.8);
            group.add(body);

            // Sensory tendrils (front)
            const tendrilGeom = new THREE.CylinderGeometry(0.5, 1, 15, 6);
            [[-3, 0, -15], [3, 0, -15], [0, 2, -14]].forEach(([x, y, z]) => {
                const tendril = new THREE.Mesh(tendrilGeom, accentMat);
                tendril.position.set(x, y, z);
                tendril.rotation.x = -Math.PI / 2 + (Math.random() - 0.5) * 0.3;
                group.add(tendril);
            });

            // Bio-luminescent nodes
            const nodeGeom = new THREE.SphereGeometry(1.5, 8, 8);
            [[-5, 2, 0], [5, 2, 0], [0, 3, -8], [-4, -2, 5], [4, -2, 5]].forEach(([x, y, z]) => {
                const node = new THREE.Mesh(nodeGeom, accentMat);
                node.position.set(x, y, z);
                group.add(node);
            });

            // Wing membranes
            const membraneGeom = new THREE.PlaneGeometry(15, 8);
            const membraneMat = new THREE.MeshStandardMaterial({
                color: style.primary,
                metalness: 0.3,
                roughness: 0.7,
                transparent: true,
                opacity: 0.7,
                side: THREE.DoubleSide
            });
            [1, -1].forEach(side => {
                const membrane = new THREE.Mesh(membraneGeom, membraneMat);
                membrane.position.set(side * 10, 0, 2);
                membrane.rotation.y = side * 0.3;
                membrane.rotation.z = side * 0.2;
                group.add(membrane);
            });

            // Organic propulsion
            const engineGeom = new THREE.SphereGeometry(4, 10, 8);
            const engine = new THREE.Mesh(engineGeom, hullMat);
            engine.position.set(0, 0, 12);
            engine.scale.set(1, 1, 1.5);
            group.add(engine);

            const glow = new THREE.Mesh(new THREE.SphereGeometry(3, 8, 8), engineMat);
            glow.position.set(0, 0, 18);
            group.add(glow);
        }

        function createAlienHeavy(group, hullMat, accentMat, engineMat, darkMat, style) {
            // Large organic form
            const bodyGeom = new THREE.SphereGeometry(15, 14, 12);
            const body = new THREE.Mesh(bodyGeom, hullMat);
            body.scale.set(1.2, 0.7, 2);
            group.add(body);

            // Multiple sensory clusters
            const clusterGeom = new THREE.IcosahedronGeometry(5, 0);
            [[-12, 5, -15], [12, 5, -15], [0, 8, -20], [-8, -5, 10], [8, -5, 10]].forEach(([x, y, z]) => {
                const cluster = new THREE.Mesh(clusterGeom, accentMat);
                cluster.position.set(x, y, z);
                group.add(cluster);
            });

            // Extended tendrils
            const tendrilGeom = new THREE.CylinderGeometry(1, 2, 25, 6);
            [[-8, 0, -30], [8, 0, -30], [0, 5, -28]].forEach(([x, y, z]) => {
                const tendril = new THREE.Mesh(tendrilGeom, hullMat);
                tendril.position.set(x, y, z);
                tendril.rotation.x = -Math.PI / 2;
                group.add(tendril);
            });

            // Glowing weak points
            const weakGeom = new THREE.SphereGeometry(3, 8, 8);
            [[0, 10, 0], [-15, 0, 10], [15, 0, 10]].forEach(([x, y, z]) => {
                const weak = new THREE.Mesh(weakGeom, engineMat);
                weak.position.set(x, y, z);
                group.add(weak);
            });

            // Organic engines
            [[-10, 0, 28], [10, 0, 28]].forEach(([x, y, z]) => {
                const engineGeom = new THREE.SphereGeometry(6, 10, 8);
                const engine = new THREE.Mesh(engineGeom, hullMat);
                engine.position.set(x, y, z);
                engine.scale.set(1, 1, 1.5);
                group.add(engine);
                const glow = new THREE.Mesh(new THREE.SphereGeometry(5, 8, 8), engineMat);
                glow.position.set(x, y, z + 10);
                group.add(glow);
            });
        }

        function createAlienCapital(group, hullMat, accentMat, engineMat, darkMat, style) {
            // Massive alien mothership
            const bodyGeom = new THREE.SphereGeometry(40, 20, 16);
            const body = new THREE.Mesh(bodyGeom, hullMat);
            body.scale.set(1.3, 0.6, 2);
            group.add(body);

            // Central eye/command node
            const eyeGeom = new THREE.SphereGeometry(15, 16, 12);
            const eye = new THREE.Mesh(eyeGeom, accentMat);
            eye.position.set(0, 15, -30);
            group.add(eye);

            // Bio-luminescent veins
            const veinGeom = new THREE.CylinderGeometry(2, 3, 80, 6);
            [[0, 10, 0], [-30, 5, 10], [30, 5, 10]].forEach(([x, y, z]) => {
                const vein = new THREE.Mesh(veinGeom, accentMat);
                vein.position.set(x, y, z);
                vein.rotation.x = Math.PI / 2;
                group.add(vein);
            });

            // Tentacle extensions
            const tentGeom = new THREE.CylinderGeometry(3, 5, 50, 8);
            [[-40, 0, -20], [40, 0, -20], [-35, -10, 20], [35, -10, 20], [0, -15, -40]].forEach(([x, y, z]) => {
                const tent = new THREE.Mesh(tentGeom, hullMat);
                tent.position.set(x, y, z);
                tent.rotation.x = -Math.PI / 2 + (Math.random() - 0.5) * 0.4;
                tent.rotation.z = (Math.random() - 0.5) * 0.3;
                group.add(tent);
            });

            // Multiple organic engines
            [[-30, 0, 70], [0, 0, 80], [30, 0, 70], [-40, -10, 60], [40, -10, 60]].forEach(([x, y, z]) => {
                const engineGeom = new THREE.SphereGeometry(12, 12, 10);
                const engine = new THREE.Mesh(engineGeom, hullMat);
                engine.position.set(x, y, z);
                engine.scale.set(1, 1, 1.5);
                group.add(engine);
                const glow = new THREE.Mesh(new THREE.SphereGeometry(10, 10, 10), engineMat);
                glow.position.set(x, y, z + 15);
                group.add(glow);
            });
        }

        function createStation() {
            const group = new THREE.Group();
            const hullTexture = createHullTexture();

            // Main ring
            const ringGeom = new THREE.TorusGeometry(70, 12, 16, 48);
            const ringMat = new THREE.MeshStandardMaterial({
                map: hullTexture,
                color: 0x888899,
                metalness: 0.7,
                roughness: 0.4
            });
            const ring = new THREE.Mesh(ringGeom, ringMat);
            ring.rotation.x = Math.PI / 2;
            group.add(ring);

            // Central hub
            const hubGeom = new THREE.CylinderGeometry(30, 30, 40, 24);
            const hubMat = new THREE.MeshStandardMaterial({
                map: hullTexture,
                color: 0x66aa66,
                metalness: 0.6,
                roughness: 0.4,
                emissive: 0x003300,
                emissiveIntensity: 0.2
            });
            const hub = new THREE.Mesh(hubGeom, hubMat);
            group.add(hub);

            // Spokes
            const spokeGeom = new THREE.BoxGeometry(5, 5, 55);
            for (let i = 0; i < 4; i++) {
                const spoke = new THREE.Mesh(spokeGeom, ringMat);
                const angle = (i / 4) * Math.PI * 2;
                spoke.position.set(Math.cos(angle) * 35, 0, Math.sin(angle) * 35);
                spoke.rotation.y = angle;
                group.add(spoke);
            }

            // Docking lights
            for (let i = 0; i < 12; i++) {
                const lightGeom = new THREE.SphereGeometry(2, 8, 8);
                const lightMat = new THREE.MeshBasicMaterial({
                    color: i % 2 === 0 ? 0x00ff00 : 0xffff00
                });
                const light = new THREE.Mesh(lightGeom, lightMat);
                const angle = (i / 12) * Math.PI * 2;
                light.position.set(Math.cos(angle) * 70, 0, Math.sin(angle) * 70);
                group.add(light);
            }

            // Antenna
            const antennaGeom = new THREE.CylinderGeometry(1, 1, 30, 8);
            const antenna = new THREE.Mesh(antennaGeom, ringMat);
            antenna.position.y = 35;
            group.add(antenna);

            const dishGeom = new THREE.ConeGeometry(10, 5, 16, 1, true);
            const dish = new THREE.Mesh(dishGeom, ringMat);
            dish.position.y = 52;
            dish.rotation.x = Math.PI;
            group.add(dish);

            // Scale down station (but less than ships - stations should feel larger)
            group.scale.set(SHIP_SCALE * 0.8, SHIP_SCALE * 0.8, SHIP_SCALE * 0.8);

            // Set low render order so stations render below player ship
            group.renderOrder = 10;
            group.traverse(child => {
                if (child.isMesh) {
                    child.renderOrder = 10;
                }
            });

            return group;
        }

        function createProjectile(x, y, angle, type = 'primary', damage = 15) {
            const group = new THREE.Group();

            let color, size, speed, lifetime;

            switch (type) {
                case 'primary':
                    color = 0x00ffff;
                    size = { w: 2, h: 15 };
                    speed = 900;
                    lifetime = 1.5;
                    break;
                case 'spread':
                    color = 0xffff00;
                    size = { w: 1.5, h: 10 };
                    speed = 800;
                    lifetime = 1.0;
                    break;
                case 'heavy':
                    color = 0xff8800;
                    size = { w: 4, h: 25 };
                    speed = 600;
                    lifetime = 2.5;
                    break;
                case 'turret':
                    color = 0xffaa00;
                    size = { w: 2, h: 12 };
                    speed = 750;
                    lifetime = 1.2;
                    break;
                case 'missile':
                    color = 0xff00ff;
                    size = { w: 3, h: 20 };
                    speed = 400;
                    lifetime = 4;
                    break;
                case 'enemy':
                    color = 0xff0000;
                    size = { w: 2, h: 10 };
                    speed = 450;
                    lifetime = 2;
                    break;
                default:
                    color = 0x00ffff;
                    size = { w: 2, h: 15 };
                    speed = 900;
                    lifetime = 1.5;
            }

            const geom = new THREE.CylinderGeometry(size.w, size.w, size.h, 6);
            const mat = new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 0.9 });
            const mesh = new THREE.Mesh(geom, mat);
            mesh.rotation.x = Math.PI / 2;
            group.add(mesh);

            // Glow trail
            const glowMat = new THREE.SpriteMaterial({
                color,
                transparent: true,
                opacity: 0.5,
                blending: THREE.AdditiveBlending
            });
            const glow = new THREE.Sprite(glowMat);
            glow.scale.set(size.w * 4, size.w * 4, 1);
            group.add(glow);

            group.position.set(x, 5, y);
            group.rotation.y = -angle + Math.PI / 2;

            return {
                mesh: group,
                x, y,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed,
                type,
                damage,
                lifetime,
                isPlayer: type !== 'enemy',
                target: null // For missiles
            };
        }

        function createMissile(x, y, angle, target, damage) {
            const proj = createProjectile(x, y, angle, 'missile', damage);
            proj.target = target;
            proj.turnRate = 3;
            return proj;
        }

        function createPickup(x, y, type = 'credits') {
            const group = new THREE.Group();

            let color, value, shape;
            switch (type) {
                case 'credits':
                    color = 0xffff00;
                    value = 15 + Math.floor(Math.random() * 25);
                    break;
                case 'health':
                    color = 0x00ff00;
                    value = 30;
                    break;
                case 'energy':
                    color = 0x00ffff;
                    value = 40;
                    break;
                case 'missile':
                    color = 0xff00ff;
                    value = 2;
                    break;
            }

            const geom = new THREE.OctahedronGeometry(8, 0);
            const mat = new THREE.MeshStandardMaterial({
                color,
                metalness: 0.8,
                roughness: 0.2,
                emissive: color,
                emissiveIntensity: 0.4
            });
            const mesh = new THREE.Mesh(geom, mat);
            group.add(mesh);

            // Glow
            const glowMat = new THREE.SpriteMaterial({
                color,
                transparent: true,
                opacity: 0.3,
                blending: THREE.AdditiveBlending
            });
            const glow = new THREE.Sprite(glowMat);
            glow.scale.set(25, 25, 1);
            group.add(glow);

            group.position.set(x, 10, y);

            return {
                mesh: group,
                x, y,
                type,
                value,
                rotation: Math.random() * Math.PI * 2
            };
        }

        function createExplosion(x, y, size = 1) {
            for (let i = 0; i < 25 * size; i++) {
                const pSize = 2 + Math.random() * 4 * size;
                const geom = new THREE.SphereGeometry(pSize, 6, 6);
                const hue = 0.05 + Math.random() * 0.08;
                const mat = new THREE.MeshBasicMaterial({
                    color: new THREE.Color().setHSL(hue, 1, 0.5 + Math.random() * 0.3),
                    transparent: true,
                    opacity: 1
                });
                const particle = new THREE.Mesh(geom, mat);
                particle.position.set(x, 3 + Math.random() * 6, y);

                const angle = Math.random() * Math.PI * 2;
                const speed = 80 + Math.random() * 200 * size;

                particles.push({
                    mesh: particle,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    life: 0.4 + Math.random() * 0.6
                });

                scene.add(particle);
            }
        }

        // Determine sector faction based on location
        function getSectorFaction() {
            const sx = playerState.currentSector.x;
            const sy = playerState.currentSector.y;
            const dist = Math.abs(sx) + Math.abs(sy);

            // Core sectors (near origin) - Confederacy space
            if (dist <= 1) {
                return Math.random() > 0.3 ? 'terranConfederacy' : 'pirates';
            }

            // Determine quadrant-based faction territories
            const quadrant = (sx >= 0 ? 'E' : 'W') + (sy >= 0 ? 'S' : 'N');

            // Northeast quadrant - Katuri space
            if (quadrant === 'EN' || (quadrant === 'WN' && sx > -3)) {
                const factions = ['katuri', 'katuri', 'pirates', 'renegades'];
                if (dist > 4) factions.push('theAliens');
                return factions[Math.floor(Math.random() * factions.length)];
            }

            // Southeast quadrant - Rebel/CAU space
            if (quadrant === 'ES') {
                const factions = ['secondRebellion', 'cau', 'pirates', 'bhu'];
                return factions[Math.floor(Math.random() * factions.length)];
            }

            // Southwest quadrant - Alien races
            if (quadrant === 'WS') {
                const factions = ['miranu', 'gadzair', 'simnuvia', 'kliaphin'];
                if (dist > 5) factions.push('voinian', 'emalgha');
                return factions[Math.floor(Math.random() * factions.length)];
            }

            // Northwest quadrant - Mixed/mysterious
            if (quadrant === 'WN') {
                const factions = ['freeCompanies', 'helionova', 'unitedEarth', 'pirates'];
                if (dist > 6) factions.push('talramuv', 'seti');
                if (dist > 8) factions.push('theAliens');
                return factions[Math.floor(Math.random() * factions.length)];
            }

            // Frontier sectors - more dangerous
            if (dist > 6) {
                const factions = ['renegades', 'pirates', 'theAliens', 'voinian'];
                return factions[Math.floor(Math.random() * factions.length)];
            }

            return 'pirates';  // Default
        }

        // ============================================================
        // CONTINUOUS INFINITE WORLD - Procedural spawning
        // ============================================================

        // Get difficulty based on distance from origin
        function getDifficulty() {
            const dist = Math.sqrt(playerState.x * playerState.x + playerState.y * playerState.y);
            return Math.floor(dist / 500); // Difficulty increases every 500 units
        }

        // Get faction based on player location (continuous)
        function getLocationFaction() {
            const x = playerState.x;
            const y = playerState.y;
            const dist = Math.sqrt(x * x + y * y);

            // Near origin - Confederacy space
            if (dist < 800) {
                return Math.random() > 0.7 ? 'pirates' : 'terranConfederacy';
            }

            // Determine quadrant
            const angle = Math.atan2(y, x);

            // Different factions in different directions
            if (angle >= -Math.PI / 4 && angle < Math.PI / 4) {
                // East - Katuri space
                const factions = ['katuri', 'pirates', 'renegades'];
                if (dist > 2000) factions.push('theAliens');
                return factions[Math.floor(Math.random() * factions.length)];
            } else if (angle >= Math.PI / 4 && angle < 3 * Math.PI / 4) {
                // North - Rebel/CAU space
                const factions = ['secondRebellion', 'cau', 'pirates'];
                if (dist > 1500) factions.push('renegades');
                return factions[Math.floor(Math.random() * factions.length)];
            } else if (angle >= -3 * Math.PI / 4 && angle < -Math.PI / 4) {
                // South - Miranu/Gadzair space
                const factions = ['miranu', 'gadzair', 'simnuvia'];
                if (dist > 2000) factions.push('voinian');
                return factions[Math.floor(Math.random() * factions.length)];
            } else {
                // West - Mixed/frontier
                const factions = ['freeCompanies', 'bhu', 'pirates', 'helionova'];
                if (dist > 2500) factions.push('talramuv', 'theAliens');
                return factions[Math.floor(Math.random() * factions.length)];
            }
        }

        // Spawn a single enemy at edge of spawn radius
        function spawnEnemy() {
            if (enemies.filter(e => e.health > 0).length >= MAX_ENEMIES) return;

            const difficulty = getDifficulty();

            // Determine enemy type based on difficulty
            let type = 'fighter';
            const roll = Math.random();
            if (difficulty >= 2 && roll > 0.8) {
                type = 'heavy';
            } else if (difficulty >= 5 && roll > 0.92) {
                type = 'boss';
            }

            // Spawn at edge of spawn radius
            const angle = Math.random() * Math.PI * 2;
            const dist = SPAWN_RADIUS + Math.random() * 200;
            const x = playerState.x + Math.cos(angle) * dist;
            const y = playerState.y + Math.sin(angle) * dist;

            const enemyFaction = getLocationFaction();

            // Get EV-style stats for this ship type
            const baseStats = EV_SHIP_STATS[type] || EV_SHIP_STATS.fighter;
            const aiBehavior = AI_BEHAVIORS[baseStats.aiType] || AI_BEHAVIORS.interceptor;

            const enemy = {
                mesh: createEnemyShip(type, enemyFaction),
                type,
                faction: enemyFaction,
                x, y,
                vx: 0, vy: 0,
                rotation: Math.random() * Math.PI * 2,
                // EV Nova style dual-health system
                shield: baseStats.shield,
                maxShield: baseStats.maxShield,
                armor: baseStats.armor,
                maxArmor: baseStats.maxArmor,
                shieldRecharge: baseStats.shieldRecharge,
                armorRecharge: baseStats.armorRecharge,
                disableThreshold: baseStats.disableThreshold,
                // Legacy health for compatibility
                health: baseStats.shield + baseStats.armor,
                maxHealth: baseStats.maxShield + baseStats.maxArmor,
                // Movement stats
                accel: baseStats.accel,
                speed: baseStats.speed,
                turnRate: baseStats.turnRate,
                mass: baseStats.mass,
                // Combat stats
                crew: baseStats.crew,
                strength: baseStats.strength,
                // AI behavior
                aiType: baseStats.aiType,
                aiBehavior: aiBehavior,
                // State
                fireTimer: 2 + Math.random() * 2,
                credits: type === 'fighter' ? (20 + difficulty * 5) : type === 'heavy' ? (60 + difficulty * 15) : (250 + difficulty * 50),
                state: 'patrol',
                disabled: false,
                destroyed: false
            };

            enemy.mesh.position.set(x, 0, y);
            scene.add(enemy.mesh);
            enemies.push(enemy);
        }

        // Spawn a station near current location
        function spawnStation() {
            if (stations.length >= MAX_STATIONS) return;

            // Check if there's already a station nearby
            for (const station of stations) {
                const dist = Math.sqrt(
                    Math.pow(station.x - playerState.x, 2) +
                    Math.pow(station.y - playerState.y, 2)
                );
                if (dist < 600) return; // Too close to existing station
            }

            const angle = Math.random() * Math.PI * 2;
            const dist = 300 + Math.random() * 400;
            const x = playerState.x + Math.cos(angle) * dist;
            const y = playerState.y + Math.sin(angle) * dist;

            const station = {
                mesh: createStation(),
                x, y
            };
            station.mesh.position.set(x, 0, y);
            scene.add(station.mesh);
            stations.push(station);
        }

        // Despawn entities that are too far from player
        function despawnFarEntities() {
            // Despawn far enemies
            enemies = enemies.filter(enemy => {
                const dist = Math.sqrt(
                    Math.pow(enemy.x - playerState.x, 2) +
                    Math.pow(enemy.y - playerState.y, 2)
                );
                if (dist > DESPAWN_RADIUS) {
                    scene.remove(enemy.mesh);
                    return false;
                }
                return true;
            });

            // Despawn far stations
            stations = stations.filter(station => {
                const dist = Math.sqrt(
                    Math.pow(station.x - playerState.x, 2) +
                    Math.pow(station.y - playerState.y, 2)
                );
                if (dist > DESPAWN_RADIUS * 1.5) {
                    scene.remove(station.mesh);
                    return false;
                }
                return true;
            });

            // Despawn far pickups
            pickups = pickups.filter(pickup => {
                const dist = Math.sqrt(
                    Math.pow(pickup.x - playerState.x, 2) +
                    Math.pow(pickup.y - playerState.y, 2)
                );
                if (dist > DESPAWN_RADIUS) {
                    scene.remove(pickup.mesh);
                    return false;
                }
                return true;
            });
        }

        // Main procedural update - called every frame
        let lastSpawnTime = 0;
        let lastStationCheckTime = 0;

        function updateProceduralWorld() {
            const now = performance.now() / 1000;

            // Spawn enemies periodically
            const spawnInterval = Math.max(1.5, 4 - getDifficulty() * 0.3); // Spawn faster at higher difficulty
            if (now - lastSpawnTime > spawnInterval) {
                lastSpawnTime = now;
                if (Math.random() > 0.3) { // 70% chance to spawn
                    spawnEnemy();
                }
            }

            // Check for station spawning less frequently
            if (now - lastStationCheckTime > 5) {
                lastStationCheckTime = now;
                if (Math.random() > 0.7) { // 30% chance
                    spawnStation();
                }
            }

            // Despawn far entities
            despawnFarEntities();

            // Update distance traveled stat
            const distFromOrigin = Math.floor(Math.sqrt(playerState.x * playerState.x + playerState.y * playerState.y));
            playerState.distanceTraveled = distFromOrigin;
        }

        // Initial spawn for game start
        function initialSpawn() {
            // Clear any existing entities
            enemies.forEach(e => scene.remove(e.mesh));
            enemies = [];
            stations.forEach(s => scene.remove(s.mesh));
            stations = [];
            pickups.forEach(p => scene.remove(p.mesh));
            pickups = [];

            // Spawn initial enemies around player with EV-style stats
            for (let i = 0; i < 3; i++) {
                const angle = Math.random() * Math.PI * 2;
                const dist = SAFE_SPAWN_RADIUS + Math.random() * 300;
                const x = playerState.x + Math.cos(angle) * dist;
                const y = playerState.y + Math.sin(angle) * dist;

                // Use EV-style stats
                const type = 'fighter';
                const baseStats = EV_SHIP_STATS[type];
                const aiBehavior = AI_BEHAVIORS[baseStats.aiType];

                const enemy = {
                    mesh: createEnemyShip(type, 'pirates'),
                    type: type,
                    faction: 'pirates',
                    x, y,
                    vx: 0, vy: 0,
                    rotation: Math.random() * Math.PI * 2,
                    // EV Nova style dual-health system
                    shield: baseStats.shield,
                    maxShield: baseStats.maxShield,
                    armor: baseStats.armor,
                    maxArmor: baseStats.maxArmor,
                    shieldRecharge: baseStats.shieldRecharge,
                    armorRecharge: baseStats.armorRecharge,
                    disableThreshold: baseStats.disableThreshold,
                    health: baseStats.shield + baseStats.armor,
                    maxHealth: baseStats.maxShield + baseStats.maxArmor,
                    // Movement stats
                    accel: baseStats.accel,
                    speed: baseStats.speed,
                    turnRate: baseStats.turnRate,
                    mass: baseStats.mass,
                    crew: baseStats.crew,
                    strength: baseStats.strength,
                    // AI behavior
                    aiType: baseStats.aiType,
                    aiBehavior: aiBehavior,
                    // State
                    fireTimer: 3 + Math.random() * 2,
                    credits: 20,
                    state: 'patrol',
                    disabled: false,
                    destroyed: false
                };
                enemy.mesh.position.set(x, 0, y);
                scene.add(enemy.mesh);
                enemies.push(enemy);
            }

            // Spawn initial station
            const station = {
                mesh: createStation(),
                x: 200,
                y: -150
            };
            station.mesh.position.set(station.x, 0, station.y);
            scene.add(station.mesh);
            stations.push(station);
        }

        // Legacy function kept for compatibility - now does nothing
        function spawnEnemies() {
            // Now handled by updateProceduralWorld
        }

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000005);

            // Add fog for depth
            scene.fog = new THREE.FogExp2(0x000010, 0.0003);

            // Orthographic camera for top-down view
            const aspect = window.innerWidth / window.innerHeight;
            const viewSize = 450;
            camera = new THREE.OrthographicCamera(
                -viewSize * aspect, viewSize * aspect,
                viewSize, -viewSize,
                1, 2000
            );
            camera.position.set(0, 800, 0);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.body.appendChild(renderer.domElement);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404050, 0.6);
            scene.add(ambientLight);

            const mainLight = new THREE.DirectionalLight(0xffffff, 1);
            mainLight.position.set(100, 500, 100);
            scene.add(mainLight);

            const fillLight = new THREE.DirectionalLight(0x4488ff, 0.3);
            fillLight.position.set(-100, 300, -100);
            scene.add(fillLight);

            // Starfield
            createStarfield();

            // GLTF loader
            gltfLoader = new GLTFLoader();

            // Preload GLB ship models in background
            preloadModels().then(() => {
                console.log('All ship models loaded - using hand-made Blender assets');
            }).catch(err => {
                console.warn('Some models failed to load, using procedural fallbacks:', err);
            });

            // Minimap (smaller size)
            const minimapCanvas = document.getElementById('minimapCanvas');
            minimapCanvas.width = 140;
            minimapCanvas.height = 140;
            minimapCtx = minimapCanvas.getContext('2d');

            // Event listeners
            document.addEventListener('keydown', e => {
                keys[e.code] = true;

                // ESC to close station menu
                if (e.code === 'Escape' && stationMenuOpen) {
                    e.preventDefault();
                    closeStationMenu();
                    return;
                }

                if (e.code === 'Tab' && gameRunning) {
                    e.preventDefault();
                    toggleUpgradePanel();
                }
                if (e.code === 'KeyF' && gameRunning) {
                    fireMissile();
                }
                if (e.code === 'KeyM' && gameRunning) {
                    e.preventDefault();
                    toggleMissionPanel();
                }
                if (e.code === 'KeyH' && gameRunning) {
                    // Hail nearest faction ship - use EV-style comm panel
                    if (factionState.currentEncounter) {
                        const attitude = getFactionAttitude(factionState.currentEncounter);
                        showEVCommPanel(factionState.currentEncounter, attitude === 'hostile' ? 'hostile' : 'hail');
                    }
                }
                if (e.code === 'KeyT' && gameRunning) {
                    // Target nearest/cycle targets - EV-style targeting
                    if (!currentTarget) {
                        const nearest = findNearestEnemy();
                        if (nearest) {
                            setEVTarget(nearest);
                            showMessage('TARGET LOCKED');
                        } else {
                            showMessage('NO TARGET IN RANGE');
                        }
                    } else {
                        cycleTarget();
                        if (currentTarget) {
                            showMessage('TARGET CYCLED');
                        }
                    }
                }
                // Weapon switching with number keys 1-4
                if (e.code === 'Digit1' && gameRunning) {
                    playerState.currentWeapon = 0;
                    updateWeaponInfo();
                    showMessage('WEAPON: PULSE CANNON');
                }
                if (e.code === 'Digit2' && gameRunning && playerState.upgrades.spreadShot > 0) {
                    playerState.currentWeapon = 1;
                    updateWeaponInfo();
                    showMessage('WEAPON: SPREAD SHOT');
                }
                if (e.code === 'Digit3' && gameRunning && playerState.upgrades.beamWeapon > 0) {
                    playerState.currentWeapon = 2;
                    updateWeaponInfo();
                    showMessage('WEAPON: BEAM LASER');
                }
                if (e.code === 'Digit4' && gameRunning && playerState.upgrades.heavyCannon > 0) {
                    playerState.currentWeapon = 3;
                    updateWeaponInfo();
                    showMessage('WEAPON: HEAVY CANNON');
                }
            });
            document.addEventListener('keyup', e => keys[e.code] = false);

            document.addEventListener('mousemove', e => {
                mouseX = e.clientX;
                mouseY = e.clientY;

                // Update crosshair
                const crosshair = document.getElementById('crosshair');
                crosshair.style.left = mouseX + 'px';
                crosshair.style.top = mouseY + 'px';

                // Convert to world coordinates
                updateMouseWorldPosition();
            });

            document.addEventListener('mousedown', e => {
                if (gameRunning && e.button === 0) {
                    fireTurret();
                }
            });

            window.addEventListener('resize', onWindowResize);

            animate();
        }

        function createStarfield() {
            // Multiple layers of stars for parallax effect
            for (let layer = 0; layer < 3; layer++) {
                const count = 200 + layer * 100;
                const positions = [];
                const colors = [];
                const sizes = [];

                for (let i = 0; i < count; i++) {
                    positions.push(
                        (Math.random() - 0.5) * SECTOR_SIZE * 4,
                        -20 - layer * 30,
                        (Math.random() - 0.5) * SECTOR_SIZE * 4
                    );

                    const brightness = 0.3 + Math.random() * 0.7;
                    colors.push(brightness, brightness, brightness + Math.random() * 0.2);
                    sizes.push(2 + Math.random() * 3);
                }

                const geom = new THREE.BufferGeometry();
                geom.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                geom.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

                const mat = new THREE.PointsMaterial({
                    size: 3 - layer * 0.5,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.8 - layer * 0.2
                });

                const stars = new THREE.Points(geom, mat);
                stars.userData.layer = layer;
                scene.add(stars);
            }

            // Nebula clouds
            for (let i = 0; i < 5; i++) {
                const nebulaGeom = new THREE.PlaneGeometry(400 + Math.random() * 300, 400 + Math.random() * 300);
                const nebulaMat = new THREE.MeshBasicMaterial({
                    color: new THREE.Color().setHSL(Math.random(), 0.5, 0.15),
                    transparent: true,
                    opacity: 0.1 + Math.random() * 0.1,
                    side: THREE.DoubleSide
                });
                const nebula = new THREE.Mesh(nebulaGeom, nebulaMat);
                nebula.position.set(
                    (Math.random() - 0.5) * SECTOR_SIZE * 2,
                    -50,
                    (Math.random() - 0.5) * SECTOR_SIZE * 2
                );
                nebula.rotation.x = -Math.PI / 2;
                scene.add(nebula);
            }
        }

        function updateMouseWorldPosition() {
            // Convert mouse screen position to world position
            const rect = renderer.domElement.getBoundingClientRect();
            const aspect = window.innerWidth / window.innerHeight;
            const viewSize = 450;

            const ndcX = ((mouseX - rect.left) / rect.width) * 2 - 1;
            const ndcY = -((mouseY - rect.top) / rect.height) * 2 + 1;

            mouseWorldX = playerState.x + ndcX * viewSize * aspect;
            mouseWorldY = playerState.y - ndcY * viewSize;
        }

        let headingCtx;

        function startGame() {
            document.getElementById('startScreen').style.display = 'none';
            document.getElementById('ui').style.display = 'block';
            // sectorInfo, controls, headingIndicator, factionPanel are hidden by CSS
            document.getElementById('minimap').style.display = 'block';
            document.getElementById('weaponInfo').style.display = 'block';
            document.getElementById('crosshair').style.display = 'block';

            // Setup heading indicator canvas (still needed for internal use)
            const headingCanvas = document.getElementById('headingCanvas');
            headingCanvas.width = 100;
            headingCanvas.height = 100;
            headingCtx = headingCanvas.getContext('2d');

            // Initialize EV-style UI canvases
            initEVCanvases();

            // Reset player
            playerState = {
                x: 0, y: 0,
                vx: 0, vy: 0,
                rotation: -Math.PI / 2,
                hull: 100, maxHull: 100,
                shields: 50, maxShields: 50,
                energy: 100, maxEnergy: 100,
                credits: 0,
                kills: 0,
                missiles: 5,
                maxMissiles: 5,
                sectorsCleared: 0, // Now tracks distance traveled / 500
                distanceTraveled: 0,
                currentSector: { x: 0, y: 0 }, // Legacy, kept for compatibility
                shipLevel: 1,
                lockedTarget: null,
                currentWeapon: 0, // 0=pulse, 1=spread, 2=beam, 3=heavy
                currentShip: 'ue_fighter', // Current ship model key
                upgrades: {
                    hull: 0, shields: 0, energy: 0, thrust: 0,
                    primaryDamage: 0, turretDamage: 0, missileDamage: 0, shieldRegen: 0,
                    spreadShot: 0, beamWeapon: 0, heavyCannon: 0, homingStrength: 0
                }
            };

            // Initialize faction system
            initFactionReputation();
            factionState.discoveredFactions = new Set(['terranConfederacy', 'pirates']);
            factionState.activeStorylines = new Set();
            factionState.completedStorylines = new Set();
            factionState.currentMission = null;
            factionState.availableMissions = [];
            factionState.crystallizedPlasma = 0;
            updateFactionPanel();
            updateActiveMissionPanel();

            playerShip = createPlayerShip();
            playerShip.position.set(0, 0, 0);
            scene.add(playerShip);

            // Use initial spawn for continuous world
            initialSpawn();
            gameRunning = true;
            window.enemies = enemies;  // Expose for testing
            window.projectiles = projectiles;  // Expose for testing
            window.gameRunning = gameRunning;  // Expose for testing

            showMessage('LAUNCH SUCCESSFUL - EXPLORE THE UNIVERSE');
        }

        // Beam weapon state
        let activeBeam = null;
        let beamDamageTimer = 0;

        function firePrimary() {
            const now = performance.now() / 1000;
            const stats = getStats();
            const weapon = playerState.currentWeapon || 0;

            // Different weapon behaviors
            switch (weapon) {
                case 0: // Pulse Cannon (default)
                    firePulse(now, stats);
                    break;
                case 1: // Spread Shot
                    fireSpread(now, stats);
                    break;
                case 2: // Beam Laser
                    fireBeam(now, stats);
                    break;
                case 3: // Heavy Cannon
                    fireHeavy(now, stats);
                    break;
                default:
                    firePulse(now, stats);
            }
        }

        function firePulse(now, stats) {
            const rapidBonus = (playerState.upgrades.rapidFire || 0) * 0.03;
            if (now - lastPrimaryFire < stats.primaryFireRate - rapidBonus) return;
            if (playerState.energy < 3) return;

            lastPrimaryFire = now;
            playerState.energy -= 3;

            // Fire from both cannons
            [-8, 8].forEach(offset => {
                const cos = Math.cos(playerState.rotation);
                const sin = Math.sin(playerState.rotation);

                const x = playerState.x + cos * 25 * SHIP_SCALE - sin * offset * SHIP_SCALE;
                const y = playerState.y + sin * 25 * SHIP_SCALE + cos * offset * SHIP_SCALE;

                const proj = createProjectile(x, y, playerState.rotation, 'primary', stats.primaryDamage);
                scene.add(proj.mesh);
                projectiles.push(proj);
            });
        }

        function fireSpread(now, stats) {
            const rapidBonus = (playerState.upgrades.rapidFire || 0) * 0.04;
            const fireRate = 0.25 - rapidBonus; // Slower than pulse
            if (now - lastPrimaryFire < fireRate) return;
            if (playerState.energy < 6) return;

            lastPrimaryFire = now;
            playerState.energy -= 6;

            const spreadLevel = playerState.upgrades.spreadShot || 1;
            const numShots = 3 + Math.min(spreadLevel - 1, 2); // 3-5 shots
            const spreadAngle = 0.15 + spreadLevel * 0.05; // Wider spread at higher levels
            const damage = stats.primaryDamage * 0.7; // Less damage per shot

            const cos = Math.cos(playerState.rotation);
            const sin = Math.sin(playerState.rotation);
            const x = playerState.x + cos * 20 * SHIP_SCALE;
            const y = playerState.y + sin * 20 * SHIP_SCALE;

            for (let i = 0; i < numShots; i++) {
                const angleOffset = (i - (numShots - 1) / 2) * spreadAngle;
                const proj = createProjectile(x, y, playerState.rotation + angleOffset, 'spread', damage);
                scene.add(proj.mesh);
                projectiles.push(proj);
            }
        }

        function fireBeam(now, stats) {
            // Beam is continuous - drain energy while firing
            if (playerState.energy < 0.5) {
                stopBeam();
                return;
            }

            const beamLevel = playerState.upgrades.beamWeapon || 1;
            playerState.energy -= 8 * (1 / 60); // Energy per frame (roughly)

            // Create/update beam visual
            if (!activeBeam) {
                const beamGeom = new THREE.CylinderGeometry(1.5, 1.5, 400, 8);
                const beamMat = new THREE.MeshBasicMaterial({
                    color: 0x00ff00,
                    transparent: true,
                    opacity: 0.7,
                    blending: THREE.AdditiveBlending
                });
                activeBeam = new THREE.Mesh(beamGeom, beamMat);
                activeBeam.name = 'playerBeam';
                scene.add(activeBeam);
            }

            // Position beam
            const beamLength = 300 + beamLevel * 50;
            activeBeam.scale.y = beamLength / 400;
            const cos = Math.cos(playerState.rotation);
            const sin = Math.sin(playerState.rotation);
            activeBeam.position.set(
                playerState.x + cos * beamLength / 2,
                5,
                playerState.y + sin * beamLength / 2
            );
            activeBeam.rotation.x = Math.PI / 2;
            activeBeam.rotation.z = -playerState.rotation + Math.PI / 2;

            // Beam damage (continuous)
            const beamDamage = (stats.primaryDamage * 0.4 + beamLevel * 3) * (1 / 60); // Damage per frame
            enemies.forEach(enemy => {
                if (enemy.health <= 0 || enemy.destroyed) return;
                // Check if enemy is in beam path
                const dx = enemy.x - playerState.x;
                const dy = enemy.y - playerState.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist > beamLength) return;

                // Check angle alignment
                const angleToEnemy = Math.atan2(dy, dx);
                let angleDiff = Math.abs(angleToEnemy - playerState.rotation);
                while (angleDiff > Math.PI) angleDiff = Math.abs(angleDiff - Math.PI * 2);

                const hitWidth = 0.1 + (30 / dist); // Wider hit detection at close range
                if (angleDiff < hitWidth) {
                    // EV-style beam damage: 100% energy (excellent against shields)
                    const wasDestroyed = applyEVDamage(enemy, beamDamage, 0);

                    // Small spark effect
                    if (Math.random() > 0.9) {
                        createExplosion(enemy.x, enemy.y, 0.1);
                    }

                    if (enemy.disabled && !enemy.destroyed) {
                        showMessage('TARGET DISABLED');
                    }

                    if (wasDestroyed) {
                        createExplosion(enemy.x, enemy.y, enemy.type === 'boss' ? 3 : enemy.type === 'heavy' ? 1.5 : 0.8);
                        scene.remove(enemy.mesh);
                        playerState.kills++;
                        playerState.credits += enemy.credits;
                        showMessage(`+${enemy.credits} CREDITS`);
                    }
                }
            });
        }

        function stopBeam() {
            if (activeBeam) {
                scene.remove(activeBeam);
                activeBeam = null;
            }
        }

        function fireHeavy(now, stats) {
            const rapidBonus = (playerState.upgrades.rapidFire || 0) * 0.05;
            const fireRate = 0.8 - rapidBonus; // Much slower
            if (now - lastPrimaryFire < fireRate) return;
            if (playerState.energy < 15) return;

            lastPrimaryFire = now;
            playerState.energy -= 15;

            const heavyLevel = playerState.upgrades.heavyCannon || 1;
            const damage = stats.primaryDamage * 2.5 + heavyLevel * 10; // High damage

            const cos = Math.cos(playerState.rotation);
            const sin = Math.sin(playerState.rotation);
            const x = playerState.x + cos * 30 * SHIP_SCALE;
            const y = playerState.y + sin * 30 * SHIP_SCALE;

            const proj = createProjectile(x, y, playerState.rotation, 'heavy', damage);
            scene.add(proj.mesh);
            projectiles.push(proj);
        }

        function updateWeaponInfo() {
            const weaponNames = ['PULSE CANNON', 'SPREAD SHOT', 'BEAM LASER', 'HEAVY CANNON'];
            const weaponTypes = ['PRIMARY - FORWARD MOUNT', 'SPREAD - FORWARD MOUNT', 'CONTINUOUS BEAM', 'HEAVY - FORWARD MOUNT'];
            const weapon = playerState.currentWeapon || 0;

            document.querySelector('#weaponInfo .weapon-name').textContent = weaponNames[weapon];
            document.querySelector('#weaponInfo .weapon-type').textContent = weaponTypes[weapon];
        }

        function fireTurret() {
            const now = performance.now() / 1000;
            const stats = getStats();

            if (now - lastTurretFire < stats.turretFireRate) return;
            if (playerState.energy < 5) return;

            lastTurretFire = now;
            playerState.energy -= 5;

            // Calculate angle to mouse
            const angle = Math.atan2(
                mouseWorldY - playerState.y,
                mouseWorldX - playerState.x
            );

            const proj = createProjectile(playerState.x, playerState.y, angle, 'turret', stats.turretDamage);
            scene.add(proj.mesh);
            projectiles.push(proj);

            // Update turret visual rotation
            const turret = playerShip.getObjectByName('turret');
            if (turret) {
                turret.parent.rotation.y = -angle + playerState.rotation;
            }
        }

        function fireMissile() {
            if (playerState.missiles <= 0) {
                showMessage('NO MISSILES');
                return;
            }

            // Find closest enemy for lock-on
            let closestEnemy = null;
            let closestDist = 800;

            enemies.forEach(enemy => {
                if (enemy.health <= 0) return;
                const dist = Math.sqrt(
                    Math.pow(enemy.x - playerState.x, 2) +
                    Math.pow(enemy.y - playerState.y, 2)
                );
                if (dist < closestDist) {
                    closestDist = dist;
                    closestEnemy = enemy;
                }
            });

            if (!closestEnemy) {
                showMessage('NO TARGET IN RANGE');
                return;
            }

            playerState.missiles--;
            const stats = getStats();

            const missile = createMissile(
                playerState.x,
                playerState.y,
                playerState.rotation,
                closestEnemy,
                stats.missileDamage
            );
            scene.add(missile.mesh);
            projectiles.push(missile);

            showMessage('MISSILE LAUNCHED');
        }

        function updatePlayer(dt) {
            if (!gameRunning) return;

            // Don't update player movement when station menu is open
            if (stationMenuOpen) {
                // Keep camera centered on player
                camera.position.x = playerState.x;
                camera.position.z = playerState.y;
                return;
            }

            const stats = getStats();

            // NEW INTUITIVE CONTROLS: WASD moves in screen-space directions
            // Ship automatically rotates to face the mouse cursor
            let thrusting = false;
            const thrustPower = (keys['ShiftLeft'] || keys['ShiftRight']) && playerState.energy > 0 ? 2 : 1;

            // Calculate movement direction from WASD (screen-space: W=up, S=down, A=left, D=right)
            let moveX = 0, moveY = 0;
            if (keys['KeyW'] || keys['ArrowUp']) {
                moveY = -1; // Up on screen = negative Z in world
                thrusting = true;
            }
            if (keys['KeyS'] || keys['ArrowDown']) {
                moveY = 1; // Down on screen = positive Z in world
                thrusting = true;
            }
            if (keys['KeyA'] || keys['ArrowLeft']) {
                moveX = -1; // Left on screen = negative X in world
                thrusting = true;
            }
            if (keys['KeyD'] || keys['ArrowRight']) {
                moveX = 1; // Right on screen = positive X in world
                thrusting = true;
            }

            // Normalize diagonal movement
            if (moveX !== 0 && moveY !== 0) {
                const len = Math.sqrt(moveX * moveX + moveY * moveY);
                moveX /= len;
                moveY /= len;
            }

            // Apply thrust in movement direction
            if (thrusting) {
                playerState.vx += moveX * stats.thrust * thrustPower * dt;
                playerState.vy += moveY * stats.thrust * thrustPower * dt;
            }

            // Boost energy cost
            if (thrustPower > 1 && thrusting) {
                playerState.energy -= 25 * dt;
            }

            // Speed limit
            const speed = Math.sqrt(playerState.vx * playerState.vx + playerState.vy * playerState.vy);
            const maxSpd = stats.maxSpeed * (thrustPower > 1 ? 1.5 : 1);
            if (speed > maxSpd) {
                playerState.vx = (playerState.vx / speed) * maxSpd;
                playerState.vy = (playerState.vy / speed) * maxSpd;
            }

            // Apply velocity
            playerState.x += playerState.vx * dt;
            playerState.y += playerState.vy * dt;

            // Space drag
            playerState.vx *= 0.992;
            playerState.vy *= 0.992;

            // SHIP ROTATION: Automatically face the mouse cursor
            const targetAngle = Math.atan2(
                mouseWorldY - playerState.y,
                mouseWorldX - playerState.x
            );

            // Smooth rotation towards target angle
            let angleDiff = targetAngle - playerState.rotation;
            while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
            while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;

            // Fast rotation to always face mouse
            const rotationSpeed = 8; // Fast rotation
            playerState.rotation += Math.sign(angleDiff) * Math.min(Math.abs(angleDiff), rotationSpeed * dt);

            // Update ship position and rotation
            playerShip.position.set(playerState.x, 0, playerState.y);
            playerShip.rotation.y = -playerState.rotation + Math.PI / 2;

            // Engine glow and thrust trails
            playerShip.traverse(child => {
                if (child.name === 'engineGlow') {
                    const scale = thrusting ? (thrustPower > 1 ? 35 : 25) : 15;
                    child.scale.set(scale, scale, 1);
                }
                if (child.name === 'engineTrail') {
                    child.visible = thrusting;
                    if (thrusting) {
                        const trailScale = thrustPower > 1 ? 1.5 : 1.0;
                        child.scale.y = trailScale;
                        child.material.opacity = thrustPower > 1 ? 0.8 : 0.5;
                    }
                }
            });

            // Primary fire
            if (keys['Space']) {
                firePrimary();
            } else {
                // Stop beam if not firing
                if (playerState.currentWeapon === 2) {
                    stopBeam();
                }
            }

            // Energy regen
            playerState.energy = Math.min(playerState.maxEnergy, playerState.energy + 12 * dt);

            // Shield regen
            if (playerState.shields < playerState.maxShields) {
                playerState.shields = Math.min(playerState.maxShields, playerState.shields + stats.shieldRegen * dt);
            }

            // Camera follow
            camera.position.x = playerState.x;
            camera.position.z = playerState.y;

            // Update mouse world position
            updateMouseWorldPosition();

            // Auto-docking - dock automatically when slow and near station
            if (!stationMenuOpen && !isDocking) {
                const playerSpeed = Math.sqrt(playerState.vx * playerState.vx + playerState.vy * playerState.vy);
                const DOCK_RANGE = 80;  // Distance to trigger docking
                const DOCK_SPEED_THRESHOLD = 50;  // Speed must be below this

                stations.forEach(station => {
                    const dist = Math.sqrt(
                        Math.pow(playerState.x - station.x, 2) +
                        Math.pow(playerState.y - station.y, 2)
                    );

                    if (dist < DOCK_RANGE && playerSpeed < DOCK_SPEED_THRESHOLD) {
                        // Start docking sequence
                        isDocking = true;
                        currentDockingStation = station;
                        document.getElementById('dockingIndicator').style.display = 'block';

                        // Stop the player
                        playerState.vx *= 0.1;
                        playerState.vy *= 0.1;

                        // Open station menu after delay
                        dockingTimer = setTimeout(() => {
                            document.getElementById('dockingIndicator').style.display = 'none';
                            isDocking = false;
                            openStationMenu();
                        }, 1500);
                    }
                });
            }

            // Cancel docking if player moves away or speeds up
            if (isDocking && currentDockingStation) {
                const dist = Math.sqrt(
                    Math.pow(playerState.x - currentDockingStation.x, 2) +
                    Math.pow(playerState.y - currentDockingStation.y, 2)
                );
                const playerSpeed = Math.sqrt(playerState.vx * playerState.vx + playerState.vy * playerState.vy);

                if (dist > 150 || playerSpeed > 100) {
                    // Cancel docking
                    if (dockingTimer) {
                        clearTimeout(dockingTimer);
                        dockingTimer = null;
                    }
                    isDocking = false;
                    currentDockingStation = null;
                    document.getElementById('dockingIndicator').style.display = 'none';
                }
            }

            // Continuous procedural world update (replaces sector system)
            updateProceduralWorld();

            updateUI();
            updateHeadingIndicator();
            updateEVTargetInfo();  // Update EV-style target panel
        }

        function updateEnemies(dt) {
            // Pause enemy behavior when player is docked at station
            if (stationMenuOpen) return;

            enemies.forEach(enemy => {
                if (enemy.health <= 0 || enemy.destroyed) return;

                // EV-style shield/armor regeneration
                updateShipRegeneration(enemy, dt);

                // Disabled ships don't move or attack
                if (enemy.disabled) {
                    enemy.vx *= 0.95;
                    enemy.vy *= 0.95;
                    enemy.x += enemy.vx * dt;
                    enemy.y += enemy.vy * dt;
                    enemy.mesh.position.set(enemy.x, 0, enemy.y);
                    return;
                }

                const dx = playerState.x - enemy.x;
                const dy = playerState.y - enemy.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const targetAngle = Math.atan2(dy, dx);

                // EV-style AI behavior based on AI type
                const aiBehavior = enemy.aiBehavior || AI_BEHAVIORS.interceptor;
                const healthPercent = enemy.health / enemy.maxHealth;

                // Check flee condition
                if (healthPercent < aiBehavior.fleeThreshold) {
                    enemy.state = 'flee';
                } else if (dist > aiBehavior.pursuitRange && aiBehavior.aggression < 0.5) {
                    enemy.state = 'patrol';
                } else if (dist > aiBehavior.preferredRange + 100) {
                    enemy.state = 'chase';
                } else {
                    enemy.state = 'attack';
                }

                // Rotate toward player (or away if fleeing)
                let targetRot = enemy.state === 'flee' ? targetAngle + Math.PI : targetAngle;
                let angleDiff = targetRot - enemy.rotation;
                while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;

                // Use EV stats for turn rate (scaled: 1.0 = base turn speed of 2.0)
                const turnSpeed = (enemy.turnRate || 1.0) * 2.0;
                enemy.rotation += Math.sign(angleDiff) * Math.min(Math.abs(angleDiff), turnSpeed * dt);

                // Movement using EV stats
                const baseSpeed = 150 * (enemy.speed || 1.0);
                const preferredDist = aiBehavior.preferredRange;

                if (enemy.state === 'flee') {
                    // Full speed escape
                    enemy.vx += Math.cos(enemy.rotation) * baseSpeed * 1.2 * dt;
                    enemy.vy += Math.sin(enemy.rotation) * baseSpeed * 1.2 * dt;
                } else if (enemy.state === 'chase' || (enemy.state === 'attack' && dist > preferredDist)) {
                    enemy.vx += Math.cos(enemy.rotation) * baseSpeed * dt;
                    enemy.vy += Math.sin(enemy.rotation) * baseSpeed * dt;
                } else if (enemy.state === 'attack' && dist < preferredDist * 0.6) {
                    enemy.vx -= Math.cos(enemy.rotation) * baseSpeed * 0.5 * dt;
                    enemy.vy -= Math.sin(enemy.rotation) * baseSpeed * 0.5 * dt;
                }

                // Speed limit using EV stats
                const maxSpeed = 200 * (enemy.speed || 1.0);
                const enemySpeed = Math.sqrt(enemy.vx * enemy.vx + enemy.vy * enemy.vy);
                if (enemySpeed > maxSpeed) {
                    enemy.vx = (enemy.vx / enemySpeed) * maxSpeed;
                    enemy.vy = (enemy.vy / enemySpeed) * maxSpeed;
                }

                enemy.x += enemy.vx * dt;
                enemy.y += enemy.vy * dt;
                enemy.vx *= 0.98;
                enemy.vy *= 0.98;

                enemy.mesh.position.set(enemy.x, 0, enemy.y);
                enemy.mesh.rotation.y = -enemy.rotation + Math.PI / 2;

                // Firing (not when fleeing or disabled)
                enemy.fireTimer -= dt;
                if (enemy.fireTimer <= 0 && dist < 500 && enemy.state === 'attack' && !enemy.disabled) {
                    const fireRate = enemy.type === 'fighter' ? 1.2 : enemy.type === 'heavy' ? 0.6 : 0.3;
                    enemy.fireTimer = fireRate + Math.random() * 0.5;

                    const damage = enemy.type === 'fighter' ? 8 : enemy.type === 'heavy' ? 15 : 25;
                    const shotCount = enemy.type === 'boss' ? 3 : 1;

                    for (let i = 0; i < shotCount; i++) {
                        const spread = (i - (shotCount - 1) / 2) * 0.2;
                        const proj = createProjectile(
                            enemy.x + Math.cos(enemy.rotation) * 20,
                            enemy.y + Math.sin(enemy.rotation) * 20,
                            enemy.rotation + spread,
                            'enemy',
                            damage
                        );
                        proj.isPlayer = false;
                        scene.add(proj.mesh);
                        projectiles.push(proj);
                    }
                }
            });
        }

        function updateProjectiles(dt) {
            projectiles = projectiles.filter(proj => {
                // Missile tracking
                if (proj.type === 'missile' && proj.target && proj.target.health > 0) {
                    const dx = proj.target.x - proj.x;
                    const dy = proj.target.y - proj.y;
                    const targetAngle = Math.atan2(dy, dx);

                    let currentAngle = Math.atan2(proj.vy, proj.vx);
                    let angleDiff = targetAngle - currentAngle;
                    while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                    while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;

                    currentAngle += Math.sign(angleDiff) * Math.min(Math.abs(angleDiff), proj.turnRate * dt);

                    const speed = Math.sqrt(proj.vx * proj.vx + proj.vy * proj.vy);
                    proj.vx = Math.cos(currentAngle) * speed;
                    proj.vy = Math.sin(currentAngle) * speed;

                    // Accelerate slightly
                    proj.vx *= 1.01;
                    proj.vy *= 1.01;

                    proj.mesh.rotation.y = -currentAngle + Math.PI / 2;
                }

                proj.x += proj.vx * dt;
                proj.y += proj.vy * dt;
                proj.mesh.position.set(proj.x, 5, proj.y);
                proj.lifetime -= dt;

                // Hit detection
                if (proj.isPlayer) {
                    for (let enemy of enemies) {
                        if (enemy.health <= 0 || enemy.destroyed) continue;
                        const dist = Math.sqrt(
                            Math.pow(proj.x - enemy.x, 2) +
                            Math.pow(proj.y - enemy.y, 2)
                        );
                        const hitRadius = enemy.type === 'fighter' ? 18 : enemy.type === 'heavy' ? 30 : 55;

                        if (dist < hitRadius) {
                            // EV-style damage: split into energy (shields) and mass (armor)
                            // Lasers/blasters = more energy, missiles/cannons = more mass
                            let energyDmg = 0;
                            let massDmg = 0;
                            if (proj.type === 'missile') {
                                // Missiles: 30% energy, 70% mass
                                energyDmg = proj.damage * 0.3;
                                massDmg = proj.damage * 0.7;
                            } else if (proj.type === 'turret') {
                                // Turrets: 50/50 split
                                energyDmg = proj.damage * 0.5;
                                massDmg = proj.damage * 0.5;
                            } else {
                                // Primary weapons (lasers): 80% energy, 20% mass
                                energyDmg = proj.damage * 0.8;
                                massDmg = proj.damage * 0.2;
                            }

                            // Apply EV-style damage
                            const wasDestroyed = applyEVDamage(enemy, energyDmg, massDmg);

                            const expSize = proj.type === 'missile' ? 0.8 : 0.3;
                            createExplosion(proj.x, proj.y, expSize);
                            scene.remove(proj.mesh);

                            // Check for disable state (ship can be boarded/captured)
                            if (enemy.disabled && !enemy.destroyed) {
                                // Disabled ship - could add boarding mechanic here
                                showMessage('TARGET DISABLED');
                            }

                            if (wasDestroyed) {
                                createExplosion(enemy.x, enemy.y, enemy.type === 'boss' ? 3 : enemy.type === 'heavy' ? 1.5 : 0.8);
                                scene.remove(enemy.mesh);
                                playerState.kills++;
                                playerState.credits += enemy.credits;

                                // Modify reputation for killing faction ships
                                if (enemy.faction) {
                                    const repLoss = enemy.type === 'boss' ? -15 : enemy.type === 'heavy' ? -8 : -3;
                                    modifyReputation(enemy.faction, repLoss);

                                    // Update mission progress
                                    updateMissionProgress(enemy.faction);

                                    // Update encounter info
                                    updateEncounterInfo();

                                    // Check storyline triggers
                                    checkStorylineTriggers();
                                }

                                // Drops
                                const dropChance = enemy.type === 'boss' ? 1 : enemy.type === 'heavy' ? 0.7 : 0.4;
                                if (Math.random() < dropChance) {
                                    const types = ['credits', 'credits', 'health', 'energy', 'missile'];
                                    const pickup = createPickup(enemy.x, enemy.y, types[Math.floor(Math.random() * types.length)]);
                                    scene.add(pickup.mesh);
                                    pickups.push(pickup);
                                }

                                showMessage(`+${enemy.credits} CREDITS`);
                            }
                            return false;
                        }
                    }
                } else {
                    // Enemy projectile hitting player
                    const dist = Math.sqrt(
                        Math.pow(proj.x - playerState.x, 2) +
                        Math.pow(proj.y - playerState.y, 2)
                    );
                    if (dist < 30) {
                        let damage = proj.damage;

                        if (playerState.shields > 0) {
                            const absorbed = Math.min(playerState.shields, damage * 0.8);
                            playerState.shields -= absorbed;
                            damage -= absorbed;
                        }

                        playerState.hull -= damage;
                        createExplosion(proj.x, proj.y, 0.2);
                        scene.remove(proj.mesh);

                        if (playerState.hull <= 0) {
                            gameOver();
                        }
                        return false;
                    }
                }

                if (proj.lifetime <= 0) {
                    scene.remove(proj.mesh);
                    return false;
                }
                return true;
            });
        }

        function updatePickups(dt) {
            pickups = pickups.filter(pickup => {
                pickup.rotation += dt * 2;
                pickup.mesh.rotation.y = pickup.rotation;
                pickup.mesh.position.y = 10 + Math.sin(pickup.rotation * 2) * 4;

                const dist = Math.sqrt(
                    Math.pow(pickup.x - playerState.x, 2) +
                    Math.pow(pickup.y - playerState.y, 2)
                );

                if (dist < 50) {
                    switch (pickup.type) {
                        case 'credits':
                            playerState.credits += pickup.value;
                            showMessage(`+${pickup.value} CREDITS`);
                            break;
                        case 'health':
                            playerState.hull = Math.min(playerState.maxHull, playerState.hull + pickup.value);
                            showMessage(`+${pickup.value} HULL`);
                            break;
                        case 'energy':
                            playerState.energy = Math.min(playerState.maxEnergy, playerState.energy + pickup.value);
                            showMessage(`+${pickup.value} ENERGY`);
                            break;
                        case 'missile':
                            playerState.missiles = Math.min(playerState.maxMissiles, playerState.missiles + pickup.value);
                            showMessage(`+${pickup.value} MISSILES`);
                            break;
                    }
                    scene.remove(pickup.mesh);
                    return false;
                }
                return true;
            });
        }

        function updateParticles(dt) {
            particles = particles.filter(p => {
                p.mesh.position.x += p.vx * dt;
                p.mesh.position.z += p.vy * dt;
                p.life -= dt;
                p.mesh.material.opacity = Math.max(0, p.life);
                p.mesh.scale.multiplyScalar(0.96);

                if (p.life <= 0) {
                    scene.remove(p.mesh);
                    return false;
                }
                return true;
            });
        }

        function updateStations(dt) {
            stations.forEach(station => {
                station.mesh.rotation.y += dt * 0.08;
            });
        }

        // Legacy function - no longer used (continuous world has no sector transitions)
        function checkSectorTransition() {
            // Empty - sector system removed, using continuous procedural world
        }

        function dockAtStation() {
            playerState.vx *= 0.1;
            playerState.vy *= 0.1;

            const repairNeeded = playerState.maxHull - playerState.hull;
            const repairCost = Math.floor(repairNeeded * 0.4);
            const missilesCost = (playerState.maxMissiles - playerState.missiles) * 10;

            let repaired = false;
            let reloaded = false;

            if (playerState.credits >= repairCost && repairNeeded > 0) {
                playerState.hull = playerState.maxHull;
                playerState.shields = playerState.maxShields;
                playerState.credits -= repairCost;
                repaired = true;
            }

            if (playerState.credits >= missilesCost && playerState.missiles < playerState.maxMissiles) {
                playerState.missiles = playerState.maxMissiles;
                playerState.credits -= missilesCost;
                reloaded = true;
            }

            if (repaired || reloaded) {
                showMessage(`DOCKED - SERVICED`);
            } else if (repairNeeded === 0 && playerState.missiles === playerState.maxMissiles) {
                showMessage('SHIP FULLY OPERATIONAL');
            } else {
                showMessage('INSUFFICIENT CREDITS');
            }
        }

        // ============================================================
        // SHIPYARD DATA - All 30 purchasable ships
        // ============================================================
        const SHIPYARD_DATA = {
            // FIGHTERS (cheap)
            scoutship: {
                name: 'Scoutship', price: 5000, model: 'Scoutship.glb',
                hull: 60, shields: 30, speed: 400, desc: 'Fast reconnaissance vessel',
                category: 'fighter'
            },
            shuttle: {
                name: 'Shuttle', price: 8000, model: 'Shuttle.glb',
                hull: 80, shields: 40, speed: 300, desc: 'Basic transport shuttle',
                category: 'fighter'
            },
            ue_fighter: {
                name: 'UE Fighter', price: 15000, model: 'UE Fighter.glb',
                hull: 100, shields: 50, speed: 350, desc: 'Standard United Earth fighter',
                category: 'fighter'
            },
            voinian_heavy_fighter: {
                name: 'Voinian Heavy Fighter', price: 18000, model: 'Voinian Heavy Fighter.glb',
                hull: 140, shields: 30, speed: 280, desc: 'Armored Voinian interceptor',
                category: 'fighter'
            },
            crescent_fighter: {
                name: 'Crescent Fighter', price: 20000, model: 'Crescent Fighter.glb',
                hull: 90, shields: 60, speed: 380, desc: 'Agile Crescent design',
                category: 'fighter'
            },
            azdara: {
                name: 'Azdara', price: 25000, model: 'Azdara.glb',
                hull: 70, shields: 80, speed: 450, desc: 'Fastest ship in known space',
                category: 'fighter'
            },
            krait: {
                name: 'Krait', price: 12000, model: 'Krait.glb',
                hull: 75, shields: 35, speed: 360, desc: 'Popular pirate fighter',
                category: 'fighter'
            },
            emalgha_fighter: {
                name: 'Emalgha Fighter', price: 16000, model: 'Emalgha Fighter.glb',
                hull: 110, shields: 25, speed: 320, desc: 'Rugged Emalgha design',
                category: 'fighter'
            },
            miranu_courier: {
                name: 'Miranu Courier', price: 10000, model: 'Miranu Courier.glb',
                hull: 70, shields: 45, speed: 370, desc: 'Swift Miranu messenger ship',
                category: 'fighter'
            },
            escape_pod: {
                name: 'Escape Pod', price: 1000, model: 'Escape Pod.glb',
                hull: 30, shields: 10, speed: 200, desc: 'Emergency escape vehicle',
                category: 'fighter'
            },

            // MEDIUM SHIPS
            arada: {
                name: 'Arada', price: 50000, model: 'Arada.glb',
                hull: 150, shields: 100, speed: 320, desc: 'Versatile medium warship',
                category: 'medium'
            },
            turncoat: {
                name: 'Turncoat', price: 45000, model: 'Turncoat.glb',
                hull: 180, shields: 80, speed: 280, desc: 'Converted pirate vessel',
                category: 'medium'
            },
            azdgari_arada: {
                name: 'Azdgari Arada', price: 55000, model: 'Azdgari Arada.glb',
                hull: 140, shields: 120, speed: 340, desc: 'Azdgari-modified Arada',
                category: 'medium'
            },
            igadzra_arada: {
                name: 'Igadzra Arada', price: 55000, model: 'Igadzra Arada.glb',
                hull: 160, shields: 110, speed: 310, desc: 'Igadzra-modified Arada',
                category: 'medium'
            },
            lazira: {
                name: 'Lazira', price: 60000, model: 'Lazira.glb',
                hull: 200, shields: 90, speed: 260, desc: 'Zidagar warship',
                category: 'medium'
            },
            helian: {
                name: 'Helian', price: 65000, model: 'Helian.glb',
                hull: 220, shields: 100, speed: 240, desc: 'Heavy combat vessel',
                category: 'medium'
            },

            // HEAVY SHIPS
            ue_freighter: {
                name: 'UE Freighter', price: 100000, model: 'UE Freighter.glb',
                hull: 300, shields: 120, speed: 200, desc: 'Large cargo hauler with weapons',
                category: 'heavy'
            },
            voinian_frigate: {
                name: 'Voinian Frigate', price: 120000, model: 'Voinian Frigate.glb',
                hull: 400, shields: 80, speed: 180, desc: 'Heavily armored warship',
                category: 'heavy'
            },
            voinian_cruiser: {
                name: 'Voinian Cruiser', price: 150000, model: 'Voinian Cruiser.glb',
                hull: 500, shields: 100, speed: 160, desc: 'Main Voinian battle cruiser',
                category: 'heavy'
            },
            miranu_freighter: {
                name: 'Miranu Freighter', price: 80000, model: 'Miranu Freighter.glb',
                hull: 250, shields: 100, speed: 220, desc: 'Miranu trading vessel',
                category: 'heavy'
            },
            miranu_freighter_ii: {
                name: 'Miranu Freighter II', price: 90000, model: 'Miranu Freighter II.glb',
                hull: 280, shields: 120, speed: 210, desc: 'Upgraded Miranu freighter',
                category: 'heavy'
            },
            miranu_gunship: {
                name: 'Miranu Gunship', price: 110000, model: 'Miranu Gunship.glb',
                hull: 320, shields: 140, speed: 230, desc: 'Armed Miranu escort ship',
                category: 'heavy'
            },
            emalgha_freighter: {
                name: 'Emalgha Freighter', price: 85000, model: 'Emalgha Freighter.glb',
                hull: 350, shields: 60, speed: 190, desc: 'Rugged Emalgha hauler',
                category: 'heavy'
            },
            cargo_freighter: {
                name: 'Cargo Freighter', price: 70000, model: 'Cargo Freighter.glb',
                hull: 200, shields: 80, speed: 180, desc: 'Standard cargo transport',
                category: 'heavy'
            },
            freight_courier: {
                name: 'Freight Courier', price: 95000, model: 'Freight Courier.glb',
                hull: 240, shields: 110, speed: 250, desc: 'Fast cargo delivery ship',
                category: 'heavy'
            },
            azdgari_warship: {
                name: 'Azdgari Warship', price: 180000, model: 'Azdgari Warship.glb',
                hull: 350, shields: 200, speed: 280, desc: 'Elite Azdgari battleship',
                category: 'heavy'
            },
            crescent_warship: {
                name: 'Crescent Warship', price: 200000, model: 'Crescent Warship.glb',
                hull: 400, shields: 180, speed: 250, desc: 'Powerful Crescent warship',
                category: 'heavy'
            },

            // CAPITAL SHIPS (expensive)
            igazra: {
                name: 'Igazra', price: 500000, model: 'Igazra.glb',
                hull: 600, shields: 300, speed: 200, desc: 'Igadzra flagship',
                category: 'capital'
            },
            ue_carrier: {
                name: 'UE Carrier', price: 750000, model: 'UE Carrier.glb',
                hull: 800, shields: 400, speed: 150, desc: 'United Earth capital ship',
                category: 'capital'
            },
            voinian_dreadnaught: {
                name: 'Voinian Dreadnaught', price: 1000000, model: 'Voinian Dreadnaught.glb',
                hull: 1200, shields: 200, speed: 120, desc: 'Ultimate Voinian warship',
                category: 'capital'
            }
        };

        // Station menu state
        let stationMenuOpen = false;
        let isDocking = false;
        let dockingTimer = null;
        let currentDockingStation = null;

        // Open station menu
        function openStationMenu() {
            stationMenuOpen = true;
            document.getElementById('stationMenu').style.display = 'flex';
            showStationTab('services');
        }
        window.openStationMenu = openStationMenu;

        // Close station menu
        function closeStationMenu() {
            stationMenuOpen = false;
            cleanupShipyardPreview(); // Clean up shipyard preview when undocking
            document.getElementById('stationMenu').style.display = 'none';
        }
        window.closeStationMenu = closeStationMenu;

        // Show station tab content
        function showStationTab(tab) {
            // Clean up shipyard preview if switching away from shipyard
            if (tab !== 'shipyard') {
                cleanupShipyardPreview();
            }

            // Update tab buttons
            document.querySelectorAll('#stationMenu .menu-tab').forEach(btn => {
                btn.classList.remove('active');
                if (btn.textContent.toLowerCase() === tab ||
                    (tab === 'services' && btn.textContent === 'SERVICES') ||
                    (tab === 'shipyard' && btn.textContent === 'SHIPYARD') ||
                    (tab === 'outfitter' && btn.textContent === 'OUTFITTER')) {
                    btn.classList.add('active');
                }
            });

            const content = document.getElementById('stationMenuContent');

            if (tab === 'services') {
                renderServicesTab(content);
            } else if (tab === 'shipyard') {
                renderShipyardTab(content);
            } else if (tab === 'outfitter') {
                renderOutfitterTab(content);
            }
        }
        window.showStationTab = showStationTab;

        // Render services tab
        function renderServicesTab(content) {
            const repairNeeded = playerState.maxHull - playerState.hull;
            const repairCost = Math.floor(repairNeeded * 0.4);
            const missilesCost = (playerState.maxMissiles - playerState.missiles) * 10;
            const shieldRepairNeeded = playerState.maxShields - playerState.shields;

            content.innerHTML = `
                <div style="color:#ff0;font-size:14px;margin-bottom:15px;text-align:center;">
                    Credits: ${playerState.credits.toLocaleString()}
                </div>

                <div class="service-row">
                    <div class="service-info">
                        <div class="service-name">Hull Repair</div>
                        <div class="service-desc">Repair hull damage (${Math.ceil(repairNeeded)} HP needed)</div>
                    </div>
                    <button class="service-btn" onclick="stationRepairHull()" ${repairNeeded <= 0 || playerState.credits < repairCost ? 'disabled' : ''}>
                        ${repairNeeded <= 0 ? 'FULL' : repairCost + ' CR'}
                    </button>
                </div>

                <div class="service-row">
                    <div class="service-info">
                        <div class="service-name">Recharge Shields</div>
                        <div class="service-desc">Restore shields to full (${Math.ceil(shieldRepairNeeded)} needed)</div>
                    </div>
                    <button class="service-btn" onclick="stationRechargeShields()" ${shieldRepairNeeded <= 0 ? 'disabled' : ''}>
                        ${shieldRepairNeeded <= 0 ? 'FULL' : 'FREE'}
                    </button>
                </div>

                <div class="service-row">
                    <div class="service-info">
                        <div class="service-name">Reload Missiles</div>
                        <div class="service-desc">Restock missiles (${playerState.missiles}/${playerState.maxMissiles})</div>
                    </div>
                    <button class="service-btn" onclick="stationReloadMissiles()" ${playerState.missiles >= playerState.maxMissiles || playerState.credits < missilesCost ? 'disabled' : ''}>
                        ${playerState.missiles >= playerState.maxMissiles ? 'FULL' : missilesCost + ' CR'}
                    </button>
                </div>

                <div class="service-row">
                    <div class="service-info">
                        <div class="service-name">Refuel Energy</div>
                        <div class="service-desc">Refill energy reserves</div>
                    </div>
                    <button class="service-btn" onclick="stationRefuelEnergy()" ${playerState.energy >= playerState.maxEnergy ? 'disabled' : ''}>
                        ${playerState.energy >= playerState.maxEnergy ? 'FULL' : 'FREE'}
                    </button>
                </div>

                <div style="margin-top:20px;padding:10px;background:rgba(0,60,80,0.4);border-radius:5px;">
                    <div style="color:#0af;font-size:11px;margin-bottom:5px;">CURRENT SHIP</div>
                    <div style="color:#fff;font-size:13px;">${SHIPYARD_DATA[playerState.currentShip]?.name || 'UE Fighter'}</div>
                    <div style="color:#088;font-size:10px;">Hull: ${playerState.hull}/${playerState.maxHull} | Shields: ${Math.ceil(playerState.shields)}/${playerState.maxShields}</div>
                </div>
            `;
        }

        // Station service functions
        function stationRepairHull() {
            const repairNeeded = playerState.maxHull - playerState.hull;
            const repairCost = Math.floor(repairNeeded * 0.4);
            if (playerState.credits >= repairCost && repairNeeded > 0) {
                playerState.credits -= repairCost;
                playerState.hull = playerState.maxHull;
                showMessage('HULL REPAIRED');
                showStationTab('services');
                updateUI();
            }
        }
        window.stationRepairHull = stationRepairHull;

        function stationRechargeShields() {
            playerState.shields = playerState.maxShields;
            showMessage('SHIELDS RECHARGED');
            showStationTab('services');
            updateUI();
        }
        window.stationRechargeShields = stationRechargeShields;

        function stationReloadMissiles() {
            const missilesCost = (playerState.maxMissiles - playerState.missiles) * 10;
            if (playerState.credits >= missilesCost) {
                playerState.credits -= missilesCost;
                playerState.missiles = playerState.maxMissiles;
                showMessage('MISSILES RELOADED');
                showStationTab('services');
                updateUI();
            }
        }
        window.stationReloadMissiles = stationReloadMissiles;

        function stationRefuelEnergy() {
            playerState.energy = playerState.maxEnergy;
            showMessage('ENERGY REFUELED');
            showStationTab('services');
            updateUI();
        }
        window.stationRefuelEnergy = stationRefuelEnergy;

        // ============================================================
        // SHIPYARD PREVIEW SYSTEM
        // ============================================================

        function initShipyardPreview() {
            // Create dedicated scene for preview
            shipyardPreviewScene = new THREE.Scene();
            shipyardPreviewScene.background = new THREE.Color(0x000510);

            // Create preview camera - top-down angled view like a showroom
            shipyardPreviewCamera = new THREE.PerspectiveCamera(45, 1, 0.1, 1000);
            // Apply persisted zoom level to camera position
            const zoomFactor = 100 / shipyardZoomLevel;
            shipyardPreviewCamera.position.set(0, 80 * zoomFactor, 50 * zoomFactor);
            shipyardPreviewCamera.lookAt(0, 0, 0);

            // Lighting setup for proper texture display
            const ambientLight = new THREE.AmbientLight(0x404060, 0.6);
            shipyardPreviewScene.add(ambientLight);

            const keyLight = new THREE.DirectionalLight(0xffffff, 1.0);
            keyLight.position.set(50, 80, 60);
            shipyardPreviewScene.add(keyLight);

            const fillLight = new THREE.DirectionalLight(0x4488ff, 0.3);
            fillLight.position.set(-50, 30, -50);
            shipyardPreviewScene.add(fillLight);

            const rimLight = new THREE.DirectionalLight(0x00ffff, 0.2);
            rimLight.position.set(0, -30, -80);
            shipyardPreviewScene.add(rimLight);

            // Subtle grid floor for grounding
            const gridHelper = new THREE.GridHelper(80, 8, 0x003344, 0x001122);
            gridHelper.position.y = -35;
            shipyardPreviewScene.add(gridHelper);
        }

        function createShipyardRenderer(canvas) {
            if (shipyardPreviewRenderer) {
                shipyardPreviewRenderer.dispose();
            }

            shipyardPreviewRenderer = new THREE.WebGLRenderer({
                canvas: canvas,
                antialias: true,
                alpha: true
            });
            shipyardPreviewRenderer.setSize(300, 300);
            shipyardPreviewRenderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        }

        // Per-ship scale modifiers for consistent preview sizing
        // Ships marked "too small" get larger multipliers, "too large" get smaller ones
        const SHIP_PREVIEW_SCALE_MODIFIERS = {
            // Too small ships - need to be scaled up
            voinian_heavy_fighter: 2.2,
            crescent_fighter: 2.0,
            krait: 2.0,
            miranu_courier: 2.5,
            arada: 2.4,
            azdgari_arada: 2.8,
            igadzra_arada: 2.2,
            miranu_freighter: 2.0,
            miranu_freighter_ii: 1.5,
            miranu_gunship: 2.4,
            // Too large ships - need to be scaled down
            shuttle: 0.7,
            ue_fighter: 0.6,
            turncoat: 0.55,
            ue_freighter: 0.35,
            cargo_freighter: 0.55,
            freight_courier: 0.7,
            igazra: 0.7,
            ue_carrier: 0.5,
            voinian_dreadnaught: 0.45
        };

        function loadShipForPreview(shipKey) {
            const ship = SHIPYARD_DATA[shipKey];
            if (!ship) return;

            // Remove existing preview model
            if (shipyardPreviewModel) {
                shipyardPreviewScene.remove(shipyardPreviewModel);
                shipyardPreviewModel = null;
            }

            // Clone model from cache
            const modelName = ship.model;
            const glbModel = cloneModel(modelName);

            if (glbModel) {
                // Step 1: Create turntable container FIRST
                const turntable = new THREE.Group();

                // Step 2: Calculate original bounding box
                const box = new THREE.Box3().setFromObject(glbModel);
                const size = box.getSize(new THREE.Vector3());
                const center = box.getCenter(new THREE.Vector3());

                // Step 3: Scale model to fit preview with per-ship adjustments
                const maxDim = Math.max(size.x, size.y, size.z);
                const targetSize = 70;
                const scaleModifier = SHIP_PREVIEW_SCALE_MODIFIERS[shipKey] || 1.0;
                const scale = (targetSize / maxDim) * scaleModifier;
                glbModel.scale.set(scale, scale, scale);

                // Step 4: NO rotation needed - GLB models are already flat in XZ plane
                // for top-down game view. Turntable will rotate around Y-axis only.

                // Step 5: Apply faction-appropriate materials/colors
                applyShipMaterials(glbModel, modelName);

                // Step 6: Center model at origin
                glbModel.position.set(
                    -center.x * scale,
                    -center.y * scale,
                    -center.z * scale
                );

                // Step 7: Add model to turntable
                turntable.add(glbModel);

                shipyardPreviewModel = turntable;
                shipyardPreviewRotation = 0;
                shipyardPreviewScene.add(shipyardPreviewModel);
            }

            selectedShipKey = shipKey;
            updateShipPreviewDetails();
        }

        function updateShipPreviewDetails() {
            const ship = SHIPYARD_DATA[selectedShipKey];
            if (!ship) return;

            const isOwned = playerState.currentShip === selectedShipKey;
            const canAfford = playerState.credits >= ship.price;

            const nameEl = document.getElementById('shipPreviewName');
            const statsEl = document.getElementById('shipPreviewStats');
            const descEl = document.getElementById('shipPreviewDesc');
            const buyBtn = document.getElementById('shipPreviewBuyBtn');

            if (nameEl) nameEl.textContent = ship.name;
            if (statsEl) statsEl.innerHTML = `Hull: ${ship.hull} | Shields: ${ship.shields}<br>Speed: ${ship.speed}`;
            if (descEl) descEl.textContent = ship.desc;

            if (buyBtn) {
                buyBtn.classList.remove('owned');
                if (isOwned) {
                    buyBtn.textContent = 'CURRENT SHIP';
                    buyBtn.disabled = true;
                    buyBtn.classList.add('owned');
                } else {
                    buyBtn.textContent = `BUY - ${ship.price.toLocaleString()} CR`;
                    buyBtn.disabled = !canAfford;
                }
            }
        }

        function animateShipyardPreview() {
            if (!shipyardPreviewRenderer || !document.getElementById('shipPreviewCanvas')) {
                if (shipyardPreviewAnimationId) {
                    cancelAnimationFrame(shipyardPreviewAnimationId);
                    shipyardPreviewAnimationId = null;
                }
                return;
            }

            shipyardPreviewAnimationId = requestAnimationFrame(animateShipyardPreview);

            // Auto-rotate if not dragging
            if (shipyardPreviewModel && !isShipyardDragging) {
                shipyardPreviewRotation += 0.008;
                shipyardPreviewModel.rotation.y = shipyardPreviewRotation;
            }

            shipyardPreviewRenderer.render(shipyardPreviewScene, shipyardPreviewCamera);
        }

        function startShipyardPreview() {
            if (!shipyardPreviewScene) {
                initShipyardPreview();
            }
            animateShipyardPreview();
        }

        function stopShipyardPreview() {
            if (shipyardPreviewAnimationId) {
                cancelAnimationFrame(shipyardPreviewAnimationId);
                shipyardPreviewAnimationId = null;
            }
        }

        function cleanupShipyardPreview() {
            stopShipyardPreview();
            if (shipyardPreviewRenderer) {
                shipyardPreviewRenderer.dispose();
                shipyardPreviewRenderer = null;
            }
            if (shipyardPreviewModel && shipyardPreviewScene) {
                shipyardPreviewScene.remove(shipyardPreviewModel);
                shipyardPreviewModel = null;
            }
        }

        function setupPreviewDragControls(canvas) {
            canvas.addEventListener('mousedown', (e) => {
                isShipyardDragging = true;
                shipyardDragStartX = e.clientX;
            });

            canvas.addEventListener('mousemove', (e) => {
                if (isShipyardDragging && shipyardPreviewModel) {
                    const deltaX = e.clientX - shipyardDragStartX;
                    shipyardPreviewRotation += deltaX * 0.01;
                    shipyardPreviewModel.rotation.y = shipyardPreviewRotation;
                    shipyardDragStartX = e.clientX;
                }
            });

            canvas.addEventListener('mouseup', () => {
                isShipyardDragging = false;
            });

            canvas.addEventListener('mouseleave', () => {
                isShipyardDragging = false;
            });

            // Touch support
            canvas.addEventListener('touchstart', (e) => {
                isShipyardDragging = true;
                shipyardDragStartX = e.touches[0].clientX;
            });

            canvas.addEventListener('touchmove', (e) => {
                if (isShipyardDragging && shipyardPreviewModel) {
                    const deltaX = e.touches[0].clientX - shipyardDragStartX;
                    shipyardPreviewRotation += deltaX * 0.01;
                    shipyardPreviewModel.rotation.y = shipyardPreviewRotation;
                    shipyardDragStartX = e.touches[0].clientX;
                }
            });

            canvas.addEventListener('touchend', () => {
                isShipyardDragging = false;
            });
        }

        // Update shipyard zoom level based on slider
        function updateShipyardZoom(value) {
            shipyardZoomLevel = parseInt(value);

            // Update the display label
            const zoomValueEl = document.getElementById('shipyard-zoom-value');
            if (zoomValueEl) {
                zoomValueEl.textContent = shipyardZoomLevel + '%';
            }

            // Update camera distance based on zoom
            // Base camera position is (0, 80, 50), distance ~94
            // At zoom 100%, use base distance
            // At zoom 50%, camera is further (200% distance = ~188)
            // At zoom 300%, camera is closer (33% distance = ~31)
            if (shipyardPreviewCamera) {
                const baseY = 80;
                const baseZ = 50;
                const zoomFactor = 100 / shipyardZoomLevel; // Inverse: higher zoom = closer
                shipyardPreviewCamera.position.set(0, baseY * zoomFactor, baseZ * zoomFactor);
                shipyardPreviewCamera.lookAt(0, 0, 0);
            }

            // Log the zoom value for debugging/recording
            console.log('ZOOM_VALUE:', shipyardZoomLevel);

            // Persist to localStorage
            try {
                localStorage.setItem('shipyardZoomLevel', shipyardZoomLevel.toString());
            } catch (e) {
                // localStorage may not be available
            }
        }
        window.updateShipyardZoom = updateShipyardZoom;

        function selectShipForPreview(shipKey) {
            // Update selection UI
            document.querySelectorAll('.ship-card-compact').forEach(card => {
                card.classList.remove('selected');
                if (card.dataset.shipKey === shipKey) {
                    card.classList.add('selected');
                }
            });

            // Load model for preview
            loadShipForPreview(shipKey);
        }
        window.selectShipForPreview = selectShipForPreview;

        function purchaseSelectedShip() {
            if (selectedShipKey) {
                purchaseShip(selectedShipKey);
                // Refresh the details after purchase
                updateShipPreviewDetails();
                // Refresh ship list to update owned status
                const content = document.getElementById('stationMenuContent');
                if (content) {
                    renderShipyardTab(content);
                }
            }
        }
        window.purchaseSelectedShip = purchaseSelectedShip;

        // Render shipyard tab with 3D preview
        function renderShipyardTab(content) {
            const categories = {
                fighter: { name: 'FIGHTERS', ships: [] },
                medium: { name: 'MEDIUM SHIPS', ships: [] },
                heavy: { name: 'HEAVY SHIPS', ships: [] },
                capital: { name: 'CAPITAL SHIPS', ships: [] }
            };

            // Sort ships into categories
            Object.entries(SHIPYARD_DATA).forEach(([key, ship]) => {
                categories[ship.category].ships.push({ key, ...ship });
            });

            // Default to current ship or first available
            const defaultShip = selectedShipKey || playerState.currentShip || 'ue_fighter';

            let html = `
                <div style="color:#ff0;font-size:14px;margin-bottom:10px;text-align:center;">
                    Credits: ${playerState.credits.toLocaleString()}
                </div>
                <div class="shipyard-container">
                    <div class="shipyard-list">
            `;

            // Render compact ship cards for each category
            Object.values(categories).forEach(cat => {
                if (cat.ships.length === 0) return;

                html += `<div class="ship-category">${cat.name}</div>`;

                cat.ships.forEach(ship => {
                    const isOwned = playerState.currentShip === ship.key;
                    const canAfford = playerState.credits >= ship.price;
                    const isSelected = ship.key === defaultShip;
                    let cardClass = 'ship-card-compact';
                    if (isSelected) cardClass += ' selected';
                    if (isOwned) cardClass += ' owned';
                    if (!canAfford && !isOwned) cardClass += ' cant-afford';

                    html += `
                        <div class="${cardClass}"
                             data-ship-key="${ship.key}"
                             onclick="selectShipForPreview('${ship.key}')">
                            <span class="ship-name">${ship.name}</span>
                            <span class="ship-price ${isOwned ? 'owned-label' : ''}">
                                ${isOwned ? 'OWNED' : ship.price.toLocaleString() + ' CR'}
                            </span>
                        </div>
                    `;
                });
            });

            html += `
                    </div>
                    <div class="shipyard-preview">
                        <canvas id="shipPreviewCanvas" class="ship-preview-canvas" width="300" height="300"></canvas>
                        <div class="shipyard-zoom-control" style="display:flex;align-items:center;justify-content:center;gap:8px;margin:8px 0;padding:4px 8px;background:rgba(0,40,60,0.6);border-radius:4px;">
                            <label for="shipyard-zoom-slider" style="color:#0af;font-size:11px;">ZOOM:</label>
                            <input type="range" id="shipyard-zoom-slider" min="50" max="1000" value="${shipyardZoomLevel}"
                                   style="width:120px;cursor:pointer;"
                                   oninput="updateShipyardZoom(this.value)">
                            <span id="shipyard-zoom-value" style="color:#fff;font-size:11px;min-width:35px;">${shipyardZoomLevel}%</span>
                        </div>
                        <div class="ship-preview-details">
                            <div id="shipPreviewName" class="ship-preview-name">Select a Ship</div>
                            <div id="shipPreviewStats" class="ship-preview-stats">-</div>
                            <div id="shipPreviewDesc" class="ship-preview-desc">-</div>
                            <button id="shipPreviewBuyBtn" class="ship-preview-buy"
                                    onclick="purchaseSelectedShip()">SELECT SHIP</button>
                        </div>
                    </div>
                </div>
            `;

            content.innerHTML = html;

            // Initialize preview after DOM is updated
            setTimeout(() => {
                const canvas = document.getElementById('shipPreviewCanvas');
                if (canvas) {
                    createShipyardRenderer(canvas);
                    setupPreviewDragControls(canvas);
                    startShipyardPreview();
                    loadShipForPreview(defaultShip);
                }
            }, 0);
        }

        // Purchase a ship
        function purchaseShip(shipKey) {
            const ship = SHIPYARD_DATA[shipKey];
            if (!ship) return;

            // Already own this ship
            if (playerState.currentShip === shipKey) {
                showMessage('ALREADY YOUR SHIP');
                return;
            }

            // Can't afford
            if (playerState.credits < ship.price) {
                showMessage('INSUFFICIENT CREDITS');
                return;
            }

            // Purchase the ship
            playerState.credits -= ship.price;
            playerState.currentShip = shipKey;

            // Update ship stats based on the new ship
            playerState.maxHull = ship.hull;
            playerState.hull = ship.hull;
            playerState.maxShields = ship.shields;
            playerState.shields = ship.shields;

            // Update the player ship model
            updatePlayerShipModel(shipKey);

            showMessage(`PURCHASED: ${ship.name}`);
            showStationTab('shipyard');
            updateUI();
        }
        window.purchaseShip = purchaseShip;

        // Update player ship model when changing ships
        function updatePlayerShipModel(shipKey) {
            const ship = SHIPYARD_DATA[shipKey];
            if (!ship) return;

            // Remove old player ship
            if (playerShip) {
                scene.remove(playerShip);
            }

            // Create new player ship with the new model
            const group = new THREE.Group();
            const modelName = ship.model;
            const glbModel = cloneModel(modelName);

            if (glbModel) {
                glbModel.rotation.x = -Math.PI / 2;
                glbModel.rotation.z = Math.PI;

                // Add engine glow effect
                const engineGlowGeom = new THREE.SphereGeometry(3, 8, 8);
                const engineMat = new THREE.MeshBasicMaterial({
                    color: 0x00ffff,
                    transparent: true,
                    opacity: 0.8
                });
                const engineGlow = new THREE.Mesh(engineGlowGeom, engineMat);
                engineGlow.position.set(0, 0, 25);
                engineGlow.name = 'engineGlow';

                // Add direction indicator
                const beamMat = new THREE.MeshBasicMaterial({
                    color: 0x00ffff,
                    transparent: true,
                    opacity: 0.6
                });
                const beamGeom = new THREE.CylinderGeometry(0.5, 1, 30, 6);
                const beam = new THREE.Mesh(beamGeom, beamMat);
                beam.position.set(0, 0, -50);
                beam.rotation.x = Math.PI / 2;
                beam.name = 'directionLine';

                const arrowGeom = new THREE.ConeGeometry(3, 8, 6);
                const arrowMat = new THREE.MeshBasicMaterial({
                    color: 0x00ffff,
                    transparent: true,
                    opacity: 0.8
                });
                const arrow = new THREE.Mesh(arrowGeom, arrowMat);
                arrow.position.set(0, 0, -67);
                arrow.rotation.x = -Math.PI / 2;
                arrow.name = 'directionArrow';

                group.add(glbModel);
                group.add(engineGlow);
                group.add(beam);
                group.add(arrow);

                group.scale.set(SHIP_SCALE, SHIP_SCALE, SHIP_SCALE);
            } else {
                // Fallback - create a simple ship
                const geom = new THREE.ConeGeometry(10, 30, 6);
                const mat = new THREE.MeshStandardMaterial({ color: 0x4488ff });
                const mesh = new THREE.Mesh(geom, mat);
                mesh.rotation.x = Math.PI / 2;
                group.add(mesh);
            }

            // Set render order high so player renders above stations
            group.renderOrder = 100;
            group.traverse(child => {
                if (child.isMesh) {
                    child.renderOrder = 100;
                }
            });

            playerShip = group;
            playerShip.position.set(playerState.x, 0, playerState.y);
            scene.add(playerShip);
        }

        // Render outfitter tab (upgrades at station)
        function renderOutfitterTab(content) {
            content.innerHTML = `
                <div style="color:#ff0;font-size:14px;margin-bottom:15px;text-align:center;">
                    Credits: ${playerState.credits.toLocaleString()}
                </div>
                <div style="color:#088;text-align:center;padding:20px;">
                    Visit the UPGRADES menu (TAB) to upgrade your ship systems.<br><br>
                    <span style="color:#0af;">Current Ship Level: ${playerState.shipLevel}</span>
                </div>
            `;
        }

        function toggleUpgradePanel() {
            const panel = document.getElementById('upgradePanel');
            if (panel.style.display === 'block') {
                panel.style.display = 'none';
            } else {
                updateUpgradePanel();
                panel.style.display = 'block';
            }
        }

        // Weapon definitions for the upgrade system
        const WEAPON_TYPES = {
            pulse: { name: 'Pulse Cannon', desc: 'Fast-firing energy weapon', color: '#0ff' },
            spread: { name: 'Spread Shot', desc: 'Fires 3-5 projectiles in a cone', color: '#ff0' },
            beam: { name: 'Beam Laser', desc: 'Continuous damage beam', color: '#0f0' },
            heavy: { name: 'Heavy Cannon', desc: 'Slow but devastating shots', color: '#f80' },
            plasma: { name: 'Plasma Launcher', desc: 'Exploding plasma balls', color: '#f0f' },
            rapidfire: { name: 'Rapid Fire', desc: 'Very fast but weak shots', color: '#8ff' }
        };

        function updateUpgradePanel() {
            // Ship upgrades
            const shipUpgrades = [
                { id: 'hull', name: 'Hull Plating', baseCost: 40, desc: '+20 Max Hull', category: 'ship' },
                { id: 'shields', name: 'Shield Capacity', baseCost: 50, desc: '+15 Max Shields', category: 'ship' },
                { id: 'energy', name: 'Energy Core', baseCost: 35, desc: '+20 Max Energy', category: 'ship' },
                { id: 'thrust', name: 'Engine Power', baseCost: 60, desc: '+40 Thrust, +30 Speed', category: 'ship' },
                { id: 'shieldRegen', name: 'Shield Regen', baseCost: 55, desc: '+1.5 Shield/sec', category: 'ship' }
            ];

            // Weapon upgrades - more interesting variety
            const weaponUpgrades = [
                { id: 'primaryDamage', name: 'Pulse Power', baseCost: 50, desc: '+5 Pulse damage', category: 'weapon' },
                { id: 'spreadShot', name: 'Spread Shot', baseCost: 100, desc: 'Unlock: 3-shot spread (key 2)', category: 'weapon', unlock: true, maxLevel: 3 },
                { id: 'beamWeapon', name: 'Beam Laser', baseCost: 150, desc: 'Unlock: Continuous beam (key 3)', category: 'weapon', unlock: true, maxLevel: 3 },
                { id: 'heavyCannon', name: 'Heavy Cannon', baseCost: 120, desc: 'Unlock: Slow but powerful (key 4)', category: 'weapon', unlock: true, maxLevel: 3 },
                { id: 'turretDamage', name: 'Turret Power', baseCost: 65, desc: '+4 Turret damage', category: 'weapon' },
                { id: 'homingStrength', name: 'Homing Missiles', baseCost: 80, desc: 'Better tracking, +20 damage', category: 'weapon' },
                { id: 'missileDamage', name: 'Warhead Upgrade', baseCost: 90, desc: '+25 Missile damage', category: 'weapon' },
                { id: 'rapidFire', name: 'Rapid Fire Mode', baseCost: 75, desc: 'Faster fire rate for all weapons', category: 'weapon' }
            ];

            const list = document.getElementById('upgradeList');
            list.innerHTML = `
                <div style="color:#ff0;margin-bottom:10px;font-size:13px;">Credits: ${playerState.credits}</div>
                <div style="color:#0ff;font-size:11px;margin-bottom:8px;border-bottom:1px solid #044;padding-bottom:5px;">SHIP SYSTEMS</div>
            `;

            // Ship upgrades section
            shipUpgrades.forEach(upg => {
                const level = playerState.upgrades[upg.id] || 0;
                const cost = upg.baseCost + level * 25;
                const canAfford = playerState.credits >= cost;

                const div = document.createElement('div');
                div.className = 'upgrade-item';
                div.style.opacity = canAfford ? '1' : '0.5';
                div.innerHTML = `
                    <div>
                        <span class="name">${upg.name}</span>
                        <span class="level" style="margin-left:10px;color:#0a0;">Lv.${level}</span>
                        <div style="font-size:10px;color:#080;">${upg.desc}</div>
                    </div>
                    <span class="cost">${cost} CR</span>
                `;

                if (canAfford) {
                    div.onclick = () => purchaseUpgrade(upg.id, cost, upg);
                }

                list.appendChild(div);
            });

            // Weapon upgrades section
            const weaponHeader = document.createElement('div');
            weaponHeader.style = 'color:#f80;font-size:11px;margin:12px 0 8px 0;border-bottom:1px solid #440;padding-bottom:5px;';
            weaponHeader.textContent = 'WEAPONS';
            list.appendChild(weaponHeader);

            weaponUpgrades.forEach(upg => {
                const level = playerState.upgrades[upg.id] || 0;
                const maxLevel = upg.maxLevel || 10;
                const atMax = level >= maxLevel;
                const cost = upg.baseCost + level * (upg.unlock ? 50 : 25);
                const canAfford = playerState.credits >= cost && !atMax;

                const div = document.createElement('div');
                div.className = 'upgrade-item';
                div.style.opacity = canAfford ? '1' : (atMax ? '0.7' : '0.5');

                let statusText = atMax ? 'MAX' : `Lv.${level}`;
                let statusColor = atMax ? '#ff0' : (level > 0 && upg.unlock ? '#0f0' : '#0a0');

                div.innerHTML = `
                    <div>
                        <span class="name">${upg.name}</span>
                        <span class="level" style="margin-left:10px;color:${statusColor};">${statusText}</span>
                        <div style="font-size:10px;color:#860;">${upg.desc}</div>
                    </div>
                    <span class="cost">${atMax ? 'MAXED' : cost + ' CR'}</span>
                `;

                if (canAfford) {
                    div.onclick = () => purchaseUpgrade(upg.id, cost, upg);
                }

                list.appendChild(div);
            });

            // Current weapon display
            const weaponInfo = document.createElement('div');
            weaponInfo.style = 'color:#0ff;font-size:10px;margin-top:12px;text-align:center;border-top:1px solid #044;padding-top:8px;';
            const weapons = ['Pulse (1)',
                playerState.upgrades.spreadShot > 0 ? 'Spread (2)' : '-',
                playerState.upgrades.beamWeapon > 0 ? 'Beam (3)' : '-',
                playerState.upgrades.heavyCannon > 0 ? 'Heavy (4)' : '-'];
            weaponInfo.innerHTML = `Weapons: ${weapons.filter(w => w !== '-').join(' | ')}`;
            list.appendChild(weaponInfo);
        }

        function purchaseUpgrade(id, cost, upg) {
            if (playerState.credits >= cost) {
                playerState.credits -= cost;
                playerState.upgrades[id] = (playerState.upgrades[id] || 0) + 1;
                playerState.shipLevel++;

                if (id === 'hull') {
                    playerState.maxHull += 20;
                    playerState.hull += 20;
                } else if (id === 'shields') {
                    playerState.maxShields += 15;
                    playerState.shields += 15;
                } else if (id === 'energy') {
                    playerState.maxEnergy += 20;
                } else if (upg && upg.unlock && playerState.upgrades[id] === 1) {
                    // First level of unlock weapons - show special message
                    showMessage(`WEAPON UNLOCKED: ${upg.name.toUpperCase()}`);
                    updateWeaponInfo();
                    updateUpgradePanel();
                    updateUI();
                    return;
                }

                showMessage(`UPGRADED: ${id.toUpperCase()}`);
                updateUpgradePanel();
                updateUI();
            }
        }

        function showMessage(text) {
            const msg = document.getElementById('message');
            msg.textContent = text;
            msg.classList.add('show');
            setTimeout(() => msg.classList.remove('show'), 2000);
        }

        function updateUI() {
            document.getElementById('hullVal').textContent = `${Math.ceil(playerState.hull)}/${playerState.maxHull}`;
            document.getElementById('shieldVal').textContent = `${Math.ceil(playerState.shields)}/${playerState.maxShields}`;
            document.getElementById('energyVal').textContent = `${Math.ceil(playerState.energy)}/${playerState.maxEnergy}`;
            document.getElementById('credits').textContent = playerState.credits;
            document.getElementById('kills').textContent = playerState.kills;
            document.getElementById('missiles').textContent = playerState.missiles;

            document.getElementById('hullBar').style.width = (playerState.hull / playerState.maxHull * 100) + '%';
            document.getElementById('shieldBar').style.width = (playerState.shields / playerState.maxShields * 100) + '%';
            document.getElementById('energyBar').style.width = (playerState.energy / playerState.maxEnergy * 100) + '%';

            // EV-style combat rating
            const combatRating = getCombatRating(playerState.kills);
            const ratingElement = document.getElementById('combatRating');
            if (ratingElement) {
                ratingElement.textContent = combatRating.name;
                ratingElement.style.color = combatRating.color;
            }
        }

        function updateSectorInfo() {
            document.getElementById('sectorNum').textContent =
                `${playerState.currentSector.x}-${playerState.currentSector.y}`;
            document.getElementById('enemyCount').textContent = enemies.filter(e => e.health > 0).length;

            const difficulty = Math.abs(playerState.currentSector.x) + Math.abs(playerState.currentSector.y);
            let threat = 'LOW';
            let color = '#0f0';
            if (difficulty >= 2) { threat = 'MEDIUM'; color = '#ff0'; }
            if (difficulty >= 4) { threat = 'HIGH'; color = '#f80'; }
            if (difficulty >= 6) { threat = 'EXTREME'; color = '#f00'; }

            document.getElementById('threatLevel').textContent = threat;
            document.getElementById('threatLevel').style.color = color;
        }

        function updateHeadingIndicator() {
            if (!headingCtx || !gameRunning) return;

            const ctx = headingCtx;
            const cx = 50, cy = 50;
            const radius = 40;

            // Clear
            ctx.fillStyle = 'rgba(0, 20, 20, 0.9)';
            ctx.fillRect(0, 0, 100, 100);

            // Outer ring
            ctx.strokeStyle = '#0ff';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(cx, cy, radius, 0, Math.PI * 2);
            ctx.stroke();

            // Cardinal direction marks and labels
            ctx.fillStyle = '#0f0';
            ctx.font = '10px Courier New';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            // N, E, S, W markers
            const directions = [
                { label: 'N', angle: -Math.PI / 2 },
                { label: 'E', angle: 0 },
                { label: 'S', angle: Math.PI / 2 },
                { label: 'W', angle: Math.PI }
            ];

            directions.forEach(dir => {
                const x = cx + Math.cos(dir.angle) * (radius + 8);
                const y = cy + Math.sin(dir.angle) * (radius + 8);
                ctx.fillText(dir.label, x, y);

                // Tick marks
                ctx.beginPath();
                ctx.moveTo(cx + Math.cos(dir.angle) * (radius - 5), cy + Math.sin(dir.angle) * (radius - 5));
                ctx.lineTo(cx + Math.cos(dir.angle) * radius, cy + Math.sin(dir.angle) * radius);
                ctx.stroke();
            });

            // Ship direction indicator (arrow pointing where ship is facing)
            const shipAngle = playerState.rotation;
            ctx.save();
            ctx.translate(cx, cy);
            ctx.rotate(shipAngle + Math.PI / 2);

            // Arrow body
            ctx.fillStyle = '#ff8800';
            ctx.beginPath();
            ctx.moveTo(0, -30);  // Tip
            ctx.lineTo(-8, 10);  // Left base
            ctx.lineTo(0, 2);    // Inner notch
            ctx.lineTo(8, 10);   // Right base
            ctx.closePath();
            ctx.fill();

            // Arrow outline
            ctx.strokeStyle = '#ffcc00';
            ctx.lineWidth = 1;
            ctx.stroke();

            ctx.restore();

            // Center dot
            ctx.fillStyle = '#0ff';
            ctx.beginPath();
            ctx.arc(cx, cy, 3, 0, Math.PI * 2);
            ctx.fill();

            // Heading in degrees (display)
            let headingDeg = Math.round((-playerState.rotation * 180 / Math.PI + 90) % 360);
            if (headingDeg < 0) headingDeg += 360;

            ctx.fillStyle = '#0ff';
            ctx.font = 'bold 12px Courier New';
            ctx.fillText(headingDeg + '\u00B0', cx, cy + radius + 20);
        }

        function updateMinimap() {
            if (!minimapCtx || !gameRunning) return;

            const ctx = minimapCtx;
            const scale = 0.06; // Adjusted for smaller minimap
            const cx = 70, cy = 70; // Center of 140x140 canvas

            // EV-style dark green background
            ctx.fillStyle = '#001100';
            ctx.fillRect(0, 0, 140, 140);

            // Create circular clipping mask for radar look
            ctx.save();
            ctx.beginPath();
            ctx.arc(cx, cy, 68, 0, Math.PI * 2);
            ctx.clip();

            // Inner darker area
            ctx.fillStyle = '#000800';
            ctx.beginPath();
            ctx.arc(cx, cy, 65, 0, Math.PI * 2);
            ctx.fill();

            // EV-style radar range rings
            ctx.strokeStyle = '#003300';
            ctx.lineWidth = 1;
            for (let r = 20; r <= 60; r += 20) {
                ctx.beginPath();
                ctx.arc(cx, cy, r, 0, Math.PI * 2);
                ctx.stroke();
            }

            // Cross-hairs (scanner grid)
            ctx.strokeStyle = '#002200';
            ctx.beginPath();
            ctx.moveTo(cx, cy - 65);
            ctx.lineTo(cx, cy + 65);
            ctx.moveTo(cx - 65, cy);
            ctx.lineTo(cx + 65, cy);
            ctx.stroke();

            // Stations - wireframe squares
            ctx.strokeStyle = '#00ff00';
            ctx.lineWidth = 2;
            stations.forEach(s => {
                const x = cx + (s.x - playerState.x) * scale;
                const y = cy + (s.y - playerState.y) * scale;
                // Check if within radar range
                const dist = Math.sqrt((x - cx) * (x - cx) + (y - cy) * (y - cy));
                if (dist < 65) {
                    ctx.strokeRect(x - 4, y - 4, 8, 8);
                    // Inner diamond
                    ctx.beginPath();
                    ctx.moveTo(x, y - 2);
                    ctx.lineTo(x + 2, y);
                    ctx.lineTo(x, y + 2);
                    ctx.lineTo(x - 2, y);
                    ctx.closePath();
                    ctx.stroke();
                }
            });

            // Enemies - wireframe markers
            enemies.forEach(e => {
                if (e.health <= 0) return;
                const x = cx + (e.x - playerState.x) * scale;
                const y = cy + (e.y - playerState.y) * scale;
                const dist = Math.sqrt((x - cx) * (x - cx) + (y - cy) * (y - cy));
                if (dist > 65) return;  // Outside radar range

                // Use faction color or threat color
                if (e.faction && FACTIONS[e.faction]) {
                    ctx.strokeStyle = FACTIONS[e.faction].color;
                } else {
                    ctx.strokeStyle = e.type === 'boss' ? '#ff00ff' : e.type === 'heavy' ? '#ff8800' : '#ff4444';
                }
                ctx.lineWidth = 1.5;

                const size = e.type === 'boss' ? 5 : e.type === 'heavy' ? 4 : 3;

                // Wireframe diamond marker
                ctx.beginPath();
                ctx.moveTo(x, y - size);
                ctx.lineTo(x + size, y);
                ctx.lineTo(x, y + size);
                ctx.lineTo(x - size, y);
                ctx.closePath();
                ctx.stroke();

                // Highlight current target
                if (currentTarget === e) {
                    ctx.strokeStyle = '#00ff00';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.arc(x, y, size + 2, 0, Math.PI * 2);
                    ctx.stroke();
                }
            });

            // Pickups - small wireframe crosses
            ctx.strokeStyle = '#ffff00';
            ctx.lineWidth = 1;
            pickups.forEach(p => {
                const x = cx + (p.x - playerState.x) * scale;
                const y = cy + (p.y - playerState.y) * scale;
                const dist = Math.sqrt((x - cx) * (x - cx) + (y - cy) * (y - cy));
                if (dist > 65) return;

                ctx.beginPath();
                ctx.moveTo(x - 2, y);
                ctx.lineTo(x + 2, y);
                ctx.moveTo(x, y - 2);
                ctx.lineTo(x, y + 2);
                ctx.stroke();
            });

            // Player - wireframe ship marker
            ctx.restore();  // Remove clip
            ctx.save();
            ctx.translate(cx, cy);
            ctx.rotate(-playerState.rotation + Math.PI / 2);

            // Outer wireframe (smaller for new minimap)
            ctx.strokeStyle = '#00ffff';
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.moveTo(0, -7);
            ctx.lineTo(-4, 4);
            ctx.lineTo(0, 2);
            ctx.lineTo(4, 4);
            ctx.closePath();
            ctx.stroke();

            // Inner fill for visibility
            ctx.fillStyle = '#00ffff';
            ctx.beginPath();
            ctx.arc(0, 0, 1.5, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();

            // Radar range outer ring
            ctx.strokeStyle = '#00aa00';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.arc(cx, cy, 68, 0, Math.PI * 2);
            ctx.stroke();
        }

        function gameOver() {
            gameRunning = false;
            createExplosion(playerState.x, playerState.y, 4);
            scene.remove(playerShip);

            setTimeout(() => {
                // Show distance traveled instead of sectors
                document.getElementById('finalSectors').textContent = playerState.distanceTraveled || 0;
                document.getElementById('finalKills').textContent = playerState.kills;
                document.getElementById('finalCredits').textContent = playerState.credits;
                document.getElementById('finalLevel').textContent = playerState.shipLevel;
                document.getElementById('gameOverScreen').style.display = 'flex';
                document.getElementById('crosshair').style.display = 'none';
            }, 1500);
        }

        function onWindowResize() {
            const aspect = window.innerWidth / window.innerHeight;
            const viewSize = 450;
            camera.left = -viewSize * aspect;
            camera.right = viewSize * aspect;
            camera.top = viewSize;
            camera.bottom = -viewSize;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            const dt = 1 / 60;

            if (gameRunning) {
                updatePlayer(dt);
                updateEnemies(dt);
                updateProjectiles(dt);
                updatePickups(dt);
                updateParticles(dt);
                updateStations(dt);
                updateMinimap();
            }

            renderer.render(scene, camera);
        }

        window.startGame = startGame;
        init();
    </script>
</body>
</html>
